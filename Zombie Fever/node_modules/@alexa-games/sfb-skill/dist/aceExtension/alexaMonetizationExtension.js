"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const sfb_f_1 = require("@alexa-games/sfb-f");
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const sfb_util_1 = require("@alexa-games/sfb-util");
class AlexaMonetizationExtension {
    constructor(locale, configAccessor) {
        this.enterMonetization = false;
        this.workflowType = "";
        this.activeProductISP = "";
        const resourcePath = configAccessor.getResourcePath(locale);
        const ispConfigPath = path.resolve(resourcePath, configAccessor.getValue("isp-config-filename", undefined, locale));
        this.productToISP = {};
        if (!fs.existsSync(ispConfigPath)) {
            console.warn(`[WARN] ISP config '${ispConfigPath}' cannot be found.`);
        }
        else {
            try {
                let productISPConfig = JSON.parse(sfb_util_1.readUtf8FileExcludingBomSync(ispConfigPath));
                for (let ispItem of productISPConfig) {
                    this.productToISP[ispItem.productName] = ispItem.ISPID;
                }
            }
            catch (err) {
                console.warn(`[WARN] Badly formed JSON : ISP config '${ispConfigPath}' could not be opened.`);
            }
        }
    }
    async post(param) {
        const handlerInput = param.userInputHelper.getHandlerInput();
        if (this.enterMonetization && handlerInput) {
            let directive = undefined;
            if (this.enterMonetization) {
                switch (this.workflowType) {
                    case "buy": {
                        directive = this.generateBuyDirective(this.activeProductISP);
                        break;
                    }
                    case "refund": {
                        directive = this.generateCancelDirective(this.activeProductISP);
                        break;
                    }
                }
            }
            if (directive) {
                handlerInput.responseBuilder.addDirective(directive);
            }
        }
    }
    async pre(param) {
        const handlerInput = param.userInputHelper.getHandlerInput();
        if (handlerInput && handlerInput.requestEnvelope.request.type == "Connections.Response") {
            sfb_f_1.StoryStateHelper.setStoryPaused(param.storyState, false);
            param.userInputHelper.setInputIntent(this.parseAlexaMonetizationResponse(handlerInput.requestEnvelope));
        }
    }
    async buy(param) {
        this.workflowType = "buy";
        this.registerMonetizationChoices(param);
    }
    async refund(param) {
        this.workflowType = "refund";
        this.registerMonetizationChoices(param);
    }
    registerMonetizationChoices(param) {
        const instructionParam = param.instructionParameters;
        const successTarget = instructionParam.success ? instructionParam.success.trim() : "";
        const failTarget = instructionParam.fail ? instructionParam.fail.trim() : "";
        const declineTarget = instructionParam.declined ? instructionParam.declined.trim() : failTarget;
        const errorTarget = instructionParam.error ? instructionParam.error.trim() : failTarget;
        const alreadyTarget = instructionParam.already_purchased ? instructionParam.already_purchased.trim() : failTarget;
        this.enterMonetization = true;
        let isp = this.productToISP[instructionParam.item];
        if (isp) {
            this.activeProductISP = isp;
        }
        else {
            throw new Error(`[AlexaMonetizationExtension Syntax Error] monetized item=[${instructionParam.item}] does not have the ISP configured.`);
        }
        if (this.enterMonetization) {
            let successChoice = {
                id: "purchase result sucess",
                sceneDirections: new sfb_f_1.SceneDirectionBuilder().goTo(successTarget).build(),
                utterances: ["Connections.Response.ACCEPTED"],
                saveToHistory: false
            };
            let declinedChoice = {
                id: "purchase result decline",
                sceneDirections: new sfb_f_1.SceneDirectionBuilder().goTo(declineTarget).build(),
                utterances: ["Connections.Response.DECLINED"],
                saveToHistory: false
            };
            let alreadyChoice = {
                id: "purchase result already purchased",
                sceneDirections: new sfb_f_1.SceneDirectionBuilder().goTo(alreadyTarget).build(),
                utterances: ["Connections.Response.ALREADY_PURCHASED"],
                saveToHistory: false
            };
            let errorChoice = {
                id: "purchase result error",
                sceneDirections: new sfb_f_1.SceneDirectionBuilder().goTo(errorTarget).build(),
                utterances: ["Connections.Response.ERROR"],
                saveToHistory: false
            };
            let forcedRelaunchChoice = {
                id: "purchase result launch",
                sceneDirections: new sfb_f_1.SceneDirectionBuilder().goTo(failTarget).build(),
                utterances: ["LaunchRequest"],
                saveToHistory: false
            };
            sfb_f_1.StoryStateHelper.enqueueAvailableChoice(param.storyState, successChoice);
            sfb_f_1.StoryStateHelper.enqueueAvailableChoice(param.storyState, declinedChoice);
            sfb_f_1.StoryStateHelper.enqueueAvailableChoice(param.storyState, alreadyChoice);
            sfb_f_1.StoryStateHelper.enqueueAvailableChoice(param.storyState, errorChoice);
            sfb_f_1.StoryStateHelper.enqueueAvailableChoice(param.storyState, forcedRelaunchChoice);
        }
    }
    parseAlexaMonetizationResponse(response) {
        let purchaseResult = "ERROR";
        if (response.request.payload) {
            purchaseResult = response.request.payload.purchaseResult;
            let productId = response.request.payload.productId;
            console.log("[INFO] Purchase Result: " + purchaseResult + " for Product ID: " + productId);
        }
        return `Connections.Response.${purchaseResult}`;
    }
    generateBuyDirective(productId, token) {
        if (!token) {
            token = "noTokenProvided";
        }
        let buyDirective = {
            type: "Connections.SendRequest",
            name: "Buy",
            payload: {
                "InSkillProduct": {
                    "productId": productId
                }
            },
            token: token
        };
        return buyDirective;
    }
    generateCancelDirective(productID, token = "noTokenProvided") {
        return {
            type: 'Connections.SendRequest',
            name: 'Cancel',
            payload: {
                InSkillProduct: {
                    productId: productID,
                }
            },
            token: token
        };
    }
}
exports.AlexaMonetizationExtension = AlexaMonetizationExtension;
//# sourceMappingURL=alexaMonetizationExtension.js.map