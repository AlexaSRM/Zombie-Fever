{"version":3,"file":"advancedAPLExtension.js","sourceRoot":"","sources":["../../src/aceExtension/advancedAPLExtension.ts"],"names":[],"mappings":"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","sourcesContent":["import { ACEDriver, DriverExtensionParameter, VisualOptions } from '@alexa-games/sfb-f';\nimport { ConfigAccessor } from './../configAccessor';\nimport { AlexaAPLExtension } from './alexaAPLExtension';\nimport { HandlerInput } from 'ask-sdk';\nimport * as _ from 'lodash';\n\nconst ALEXA_SPEECH_TEXT_BLOCK_ID = \"alexaSpeechTextBlock\";\nconst ALEXA_SPEECH_ID = \"alexaSpeech\";\n\nexport class AdvancedAPLExtension extends AlexaAPLExtension {\n\n    constructor(locale: string, configAccessor: ConfigAccessor) {\n        super(locale, configAccessor);\n    }\n\n    async post(param: DriverExtensionParameter) {\n        const handlerInput = param.userInputHelper.getHandlerInput();\n        const driver = param.driver;\n\n        let visualProperties: VisualOptions[] | undefined = await driver.getVisuals();\n        // Visual properties list looks like\n        /*\n            [\n                {\n                    \"template\": \"default\",\n                    \"background\": \"https://s3.amazonaws.com/alexa-ml/project-bird/en-US/images/1_1.png\",\n                    \"title\": \"\",\n                    \"subtitle\": \"\",\n                    \"sceneID\": \"intro\"\n                }\n                ,\n                {\n                    \"template\": \"default2\",\n                    \"background\": \"https://s3.amazonaws.com/alexa-ml/project-bird/en-US/images/1_2.png\",\n                    \"title\": \"\",\n                    \"subtitle\": \"\",\n                    \"sceneID\": \"intro2\"\n                }\n            ]\n        */\n\n        // Only handle the visual response if there are some visual properties in this request\n        if (handlerInput && visualProperties && visualProperties.length > 0 && this.aplHelper.supportsDisplay(handlerInput)) {\n            await this.handleVisualResponse(visualProperties, handlerInput, driver);\n        }\n    }\n\n    // Handle touch events\n    async pre(param: DriverExtensionParameter) {\n        const handlerInput = param.userInputHelper.getHandlerInput();\n\n        // Arguments are in format: [\"Utterance\", \"utterance goes here\"]\n        // or [\"SlotNameValue\", \"slotName goes here\", \"slotValue goes here\"]\n\n        if (_.get(handlerInput, \"requestEnvelope.request.type\", \"\") === \"Alexa.Presentation.APL.UserEvent\") {\n\n            const command = _.get(handlerInput, \"requestEnvelope.request.arguments[0]\", \"\");\n\n            if(command === \"Utterance\") {\n                const utterance = _.get(handlerInput, \"requestEnvelope.request.arguments[1]\", \"\");\n                if(utterance) {\n                    param.userInputHelper.setInputValue(utterance);\n                }\n            }\n\n            if(command === \"SlotNameValue\") {\n                const slotName = _.get(handlerInput, \"requestEnvelope.request.arguments[1]\", \"\");\n                const slotValue = _.get(handlerInput, \"requestEnvelope.request.arguments[2]\", \"\");\n\n                if(slotName && slotValue) {\n                    param.userInputHelper.addInputSlot(slotName, slotValue);\n                }\n            }\n        }\n    }\n    \n\n    async handleVisualResponse(visualProperties: VisualOptions[], handlerInput: HandlerInput, driver: ACEDriver) {\n\n        this.deserializeVisualProperties(visualProperties);\n\n        // Handle the visual options for this response\n        let combinedVisualProps = { ...visualProperties[0] };\n\n        // Then add a list of all of the visual properties for scenes that follow, including the first one\n        combinedVisualProps.scenes = [];\n\n        visualProperties.forEach((visualProp) => {\n\n            // Only add scenes that actually specify templates or layouts, otherwise they could just be commands that don't\n            // want to transition scenes\n            // TOOD: Check for onlyCommands on a default template, which means to not add it to this list or above when\n            // adding nextScene commands\n            if( (visualProp.template && visualProp.template !== \"default\") || visualProp.layout) {\n                combinedVisualProps.scenes.push(visualProp);\n            }\n        });\n\n        // render our default response. Note: This function really should only always return a single apl directive.\n        let visualDirectives: any[] = this.aplHelper.generateAPLDirectiveWithVisualOptions([combinedVisualProps]);\n\n        // If no APL directives, then don't return any extra APL commands or APL audio\n        if (visualDirectives.length > 0) {\n\n            // Make a clone so that when layouts/commands are added it does not modify the original template\n            visualDirectives[0] = _.cloneDeep(visualDirectives[0]);\n\n            // special case: If this was a 'dynamic-pager' template, load all layouts/commands dynamically\n            if(combinedVisualProps && combinedVisualProps.template === 'dynamic-pager') {\n                this.addLayoutsAndCommandsToDynamicPagerDirective(visualDirectives[0], combinedVisualProps.scenes);\n            }\n\n            const aplCommandResult = await this.buildAPLCommandsAndAudio(visualDirectives, visualProperties, handlerInput, driver);\n\n            // Only if there were some additional visual directives to execute, modify the apl document to include extra SpeakItem components\n            if (aplCommandResult.addedANonAudioCommand) {\n\n                // Before returning the direcives, add any additional speak item text components and datasources\n                for (let aplDirective of visualDirectives) {\n\n                    // Find the SFB containger in the APL doc to add these SpeakItem components to\n                    const aplSFBContainer = deepSearch(aplDirective, \"id\", (k : string, v : any) => v === 'SFBAudioAndAlexaSpeechContainer');\n\n                    if(aplSFBContainer && aplSFBContainer.items) {\n                        // Add in any speak item text blocks\n                        aplCommandResult.textComponents.forEach((speakItemTextComponent: any) => {\n                            aplSFBContainer.items.push(speakItemTextComponent);\n                        });\n                    }\n\n                    // Add in any additional datasources\n                    aplCommandResult.textDatasources.forEach((speakItemTextDatasource: any, index: number) => {\n                        aplDirective.datasources[ALEXA_SPEECH_ID + index] = speakItemTextDatasource;\n                    });\n                }\n            }\n\n            // Now add the directives\n            for (let aplDirective of visualDirectives) {\n                handlerInput.responseBuilder.addDirective(aplDirective);\n            }\n\n            // Only if there were some additional visual directives to execute, add them and blank out the \"speak\" from this request.\n            if (aplCommandResult.addedANonAudioCommand) {\n\n                handlerInput.responseBuilder.addDirective({\n                    \"type\": \"Alexa.Presentation.APL.ExecuteCommands\",\n                    \"token\": \"ABC_RENDERED_DOCUMENT\",\n                    \"commands\": aplCommandResult.commands\n                });\n\n                handlerInput.responseBuilder.speak(\"\");\n            }\n        }\n\n    }\n\n    addLayoutsAndCommandsToDynamicPagerDirective(visualDirective: any, scenes: any[]) {\n        \n        const allAplTemplates = this.aplHelper.getAPLTemplates();\n        if(!allAplTemplates) {\n            return;\n        }\n\n        visualDirective.document.layouts = visualDirective.document.layouts || {};\n        visualDirective.document.commands = visualDirective.document.commands || {};\n\n        let layoutNames = new Set();\n\n        // Loop through all requested layouts, and add them to a set\n        scenes.forEach((scene) => {\n            const layoutName = scene.layout;\n            if(layoutName) {\n                layoutNames.add(layoutName);\n            }\n        });\n\n        // Now loop through all templates, and find all relevant templates\n        Object.keys(allAplTemplates).forEach((templateName) => {\n\n            const templateLayouts = allAplTemplates[templateName].document.layouts;\n            const templateCommands = allAplTemplates[templateName].document.commands;\n\n            if(templateLayouts) {\n                for(const layoutName of Object.keys(templateLayouts)) {\n\n                    if(layoutNames.has(layoutName)) {\n\n                        // If this templateName contains at least one layout that is relevant, add all the layouts and commands from this apl template\n                        visualDirective.document.layouts = _.assign(visualDirective.document.layouts, templateLayouts);\n                        visualDirective.document.commands = _.assign(visualDirective.document.commands, templateCommands);\n\n                        break;\n                    }\n                };\n            }\n        });\n\n        // Now the visualDirective has all layouts/commands added from relevant APL Template files\n    }\n\n    // Build up the sequential and parallel command sequences to group each visual scene's audio elements with any APL commands for that scene\n    async buildAPLCommandsAndAudio(visualDirectives: any[], visualProperties: VisualOptions[], handlerInput: HandlerInput, driver: ACEDriver) {\n\n        const firstAPLDirective = visualDirectives[0];\n        const alexaSpokenDialogueList : string[] = [];\n\n        // Get specific apl commands for this scene if there are any 'commands' in the document section\n        const documentSpecificCommands = (firstAPLDirective.document && firstAPLDirective.document.commands) ? firstAPLDirective.document.commands : {};\n\n        // Now get the text per scene\n        const speechOutputScenesPerScene: any[] = await driver.getSpeechSSMLTextPerScene();\n        const visitedSceneIds: string[] = driver.getVisitedSceneIDsOnRun();\n\n        console.log(\"VISUALSCENES\");\n        console.log(JSON.stringify(visualProperties, undefined, 4));\n        console.log(JSON.stringify(speechOutputScenesPerScene, undefined, 4));\n\n        // Now build a series of apl commands, which start each scene's narrationa and commands in parallel for each scene.\n\n        const overallAplCommandList: any[] = [];\n\n        // Loop variables for the speech/audio scenes\n        let speechOutputSceneIndex = 0;\n        let nextSpeechScene: any = undefined;\n        if (speechOutputScenesPerScene.length > speechOutputSceneIndex) {\n            nextSpeechScene = speechOutputScenesPerScene[speechOutputSceneIndex];\n        }\n\n        // Loop variables for the visual scenes\n        let visualSceneIndex = 0;\n        let visualTemplateLayoutPgIndex = 0;\n        let nextVisualScene: any = undefined;\n        if (visualProperties.length > visualSceneIndex) {\n            nextVisualScene = visualProperties[visualSceneIndex];\n        }\n\n        let addedANonAudioCommand = false;\n\n        visitedSceneIds.forEach((visitedSceneId, sceneIndex) => {\n\n            const sceneCommandList: any[] = [];\n\n            console.log(\"SCENE\");\n            console.log(JSON.stringify(nextVisualScene, undefined, 4));\n            console.log(JSON.stringify(nextSpeechScene, undefined, 4));\n\n            if (nextSpeechScene && nextSpeechScene.sceneID === visitedSceneId) {\n\n                // Add any audio/narration for this scene\n                this.addAudioForScene(nextSpeechScene, sceneCommandList, alexaSpokenDialogueList);\n\n                // Advance to next speech scene\n                speechOutputSceneIndex++;\n                if (speechOutputScenesPerScene && speechOutputScenesPerScene.length > speechOutputSceneIndex) {\n                    nextSpeechScene = speechOutputScenesPerScene[speechOutputSceneIndex];\n                } else {\n                    nextSpeechScene = undefined;\n                }\n            }\n\n            if (nextVisualScene && nextVisualScene.sceneID === visitedSceneId) {\n\n                const beforeCount = sceneCommandList.length;\n\n                // Add any commands for this scene\n                this.addVisualCommandsForScene(nextVisualScene, sceneCommandList, visualTemplateLayoutPgIndex, documentSpecificCommands);\n\n                // Check to see if any visual scenes were added, flag if so otherwise keep flag value\n                addedANonAudioCommand = addedANonAudioCommand || (beforeCount !== sceneCommandList.length);\n\n                // Advance to next visual scene\n                visualSceneIndex++;\n                if (visualProperties && visualProperties.length > visualSceneIndex) {\n                    nextVisualScene = visualProperties[visualSceneIndex];\n                } else {\n                    nextVisualScene = undefined;\n                }\n\n                // Check to see if we really need to advance the visual template/layout index, as some visual properties only\n                // contain commands\n                if( nextVisualScene && ((nextVisualScene.template && nextVisualScene.template !== \"default\") || nextVisualScene.layout)) {\n                    visualTemplateLayoutPgIndex++;\n                }\n\n            }\n\n            // Now add all these commands in parallel to the overall command list\n            if (sceneCommandList.length > 0) {\n                overallAplCommandList.push(\n                    {\n                        \"type\": \"Parallel\",\n                        \"commands\": sceneCommandList\n                    }\n                );\n            }\n\n        });\n\n        // Generate extra components/datasources required for Alexa SpeakItem requests\n        const speakItemRequests = this.generateAlexaSpeakItemComponents(alexaSpokenDialogueList);\n\n        // Return a list of commands and also a flag indicating if any were non audio commands (like user defined APL commands)\n        return {commands: overallAplCommandList, addedANonAudioCommand, textComponents: speakItemRequests.textComponents, textDatasources: speakItemRequests.textDatasources};\n    }\n\n    generateAlexaSpeakItemComponents(alexaSpeechList: string[]) : { textComponents: any[], textDatasources: any[] } {\n\n        let additionalTextBlocks: any[] = [];\n        let additionalDataSources: any[] = [];\n\n        alexaSpeechList.forEach((speechSSML, index) => {\n\n            additionalTextBlocks.push(\n                {\n                    \"type\": \"Text\",\n                    \"speech\": \"${payload.\" + ALEXA_SPEECH_ID + index + \".properties.speech}\",\n                    \"id\": ALEXA_SPEECH_TEXT_BLOCK_ID + index\n                }\n            );\n\n            additionalDataSources.push(\n                {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"ssml\": `<speak>${speechSSML}</speak>`\n                    },\n                    \"transformers\": [\n                        {\n                            \"inputPath\": \"ssml\",\n                            \"outputName\": \"speech\",\n                            \"transformer\": \"ssmlToSpeech\"\n                        }\n                    ]\n                }\n            );\n        });\n\n        return { textComponents: additionalTextBlocks, textDatasources: additionalDataSources};\n    }\n\n    // Add audio commands for all the audio files in this scenes SSML text, play them sequentially\n    // Scene content looks like\n    /*\n    {\n        \"sceneID\": \"intro\",\n        \"sceneAudioItem\": {\n            \"sceneID\": \"intro\",\n            \"foreground\": [\n                {\n                    \"type\": \"polly\",\n                    \"content\": \"St. Pigeonation's. A school blessed with <emphasis>extensive</emphasis> curricula and facilities.\",\n                    \"volume\": \"1.0\",\n                    \"delay\": 0,\n                    \"options\": {\n                        \"pitch\": \"+22%\",\n                        \"rate\": \"+12%\",\n                        \"voice\": \"Salli\"\n                    }\n                }\n            ],\n            \"background\": [\n                {\n                    \"type\": \"audio\",\n                    \"content\": \"https://s3.amazonaws.com/alexa-ml/project-bird/en-US/audio/bgm_school.mp3\",\n                    \"volume\": 1,\n                    \"delay\": 0,\n                    \"options\": {\n                        \"blend\": \"undefined\"\n                    }\n                }\n            ]\n        },\n        \"ssml\": \"<audio src='https://s3.amazonaws.com/alexa-ml/tempPolly/445aab7b1dccffaf51254f4cecc5b900.mp3' /><audio src='https://s3.amazonaws.com/alexa-ml/tempPolly/otherSfx.mp3' />\"\n    }\n    */\n    addAudioForScene(scene: any, sceneCommandList: any[], alexaSpokenDialogueList: string[]) {\n        // Handle Alexa voice as well as audio tag responses and mixtures of the two\n        let audioCommandListToPlay: any[] = [];\n\n        // Trim string if defined\n        const ssml = scene.ssml ? scene.ssml.trim() : scene.ssml;\n\n        let partitioningRegex: RegExp = /(<audio[\\s]+src='[^><]+?'[\\s]*?\\/>)|([\\s\\S]+?)(?=<audio|$)/g;    \n        let partitionMatch: string[] | null = partitioningRegex.exec(ssml);\n    \n        while (partitionMatch != null) {\n            \n            if (partitionMatch[1] && partitionMatch[1].trim().length > 0) {\n\n                const srcUrlRegex = /<audio src='([^']*?)'/g;\n                let srcUrlMatch = srcUrlRegex.exec(partitionMatch[1]);\n\n                if (srcUrlMatch && srcUrlMatch.length > 1) {\n                    const audioUrl = srcUrlMatch[1];\n\n                    // Play all the audio files in the *say section for this scene\n                    let playAudioCommand: any = {\n                        \"type\": \"PlayMedia\",\n                        \"componentId\": \"audioPlayerId\",\n                        \"source\": audioUrl\n                    };\n\n                    audioCommandListToPlay.push(playAudioCommand);\n                }\n\n\n            } else if (partitionMatch[2] && partitionMatch[2].trim().length > 0) {   \n\n                // Add a command for the SpeakItem and add it to the spken dialogue list so that a text component and datasource can be created for this SpeakItem\n                const speakItemText = partitionMatch[2].trim();\n\n                let speakItemCommand = {\n                    \"delay\": 200,\n                    \"type\": \"SpeakItem\",\n                    \"componentId\": ALEXA_SPEECH_TEXT_BLOCK_ID + alexaSpokenDialogueList.length,\n                    \"highlightMode\": \"line\",\n                    \"align\": \"center\"\n                };\n\n                audioCommandListToPlay.push(speakItemCommand);\n\n                alexaSpokenDialogueList.push(speakItemText);\n            }\n    \n            partitionMatch = partitioningRegex.exec(ssml);\n        }\n\n\n        if (audioCommandListToPlay.length > 0) {\n            sceneCommandList.push({\n                \"type\": \"Sequential\",\n                \"commands\": audioCommandListToPlay\n            });\n        }\n    }\n\n    addVisualCommandsForScene(scene: any, sceneCommandList: any[], pgIndex: number, documentSpecificCommands: any) {\n        // Make sure these are done in parallel with the PlayMedia/Speech command further below\n        // Also make sure they are done in parallel with each other? (because you could use different scenes if you wanted them sequentially?)\n        // or use some sort of flag to group parallel vs. sequential commands\n\n        if (pgIndex !== 0) {\n            // Add a nextScene command if defined and not the first pgIndex,\n            // and the given visual scenes has a \"template\" or \"layout\" property, and that they are not default because that could\n            // mean that they are only using commands\n            if( (scene.template && scene.template !== \"default\") || scene.layout) {\n                this.addCommandIfExists(\"nextScene\", sceneCommandList, documentSpecificCommands, pgIndex);\n            }\n        }\n\n        // Push any commands from this visual command\n        if (scene.commands) {\n            scene.commands.forEach((commandName: string) => {\n                this.addCommandIfExists(commandName, sceneCommandList, documentSpecificCommands, pgIndex);\n            });\n        }\n    }\n\n    addCommandIfExists(command: string, commandList: any[], documentSpecificCommands: any, pgIndex: number) {\n        // Check for document specific nextScene command first, then default nextScene from apl-commands file second\n        if (documentSpecificCommands[command]) {\n            commandList.push({\n                \"type\": command,\n                \"pgIndex\": pgIndex // Set pgIndex which can be used to reference components by id of what page they are on\n            });\n\n        } else {\n            const commandFromCommonFile = this.aplHelper.generateAPLCommand(command);\n            if (commandFromCommonFile) {\n                commandFromCommonFile['pgIndex'] = pgIndex; // Set pgIndex which can be used to reference components by id of what page they are on\n                commandList.push(commandFromCommonFile);\n            }\n        }\n    }\n\n    // Mutate visualProperties from string values to objects if the string starts with [ or {, as it could be a JSON\n    // array or object. \n    deserializeVisualProperties(visualProperties: VisualOptions[]) {\n\n        visualProperties.forEach((visualProp) => {\n\n            for(var propt in visualProp){\n                if(typeof(visualProp[propt]) === 'string') {\n                    if(visualProp[propt].startsWith(\"{\") || visualProp[propt].startsWith(\"[\")) {\n                        try {\n                            // try to deserialize from JSON\n                            const jsonObj = JSON.parse(visualProp[propt]);\n\n                            visualProp[propt] = jsonObj;\n\n                        } catch(e) {\n                            // Not a JSON object so do nothing\n                        }\n                    }\n                }\n            }\n            \n        });\n    }\n\n}\n\nfunction deepSearch(object : any, key : string, predicate : any) : any {\n\n    if (object.hasOwnProperty(key) && predicate(key, object[key]) === true) {\n        return object;\n    }\n\n    for (let i = 0; i < Object.keys(object).length; i++) {\n      if (typeof object[Object.keys(object)[i]] === \"object\") {\n        let o : any = deepSearch(object[Object.keys(object)[i]], key, predicate);\n        if (o != null) {\n            return o;\n        }\n      }\n    }\n    return null;\n}\n\n"]}