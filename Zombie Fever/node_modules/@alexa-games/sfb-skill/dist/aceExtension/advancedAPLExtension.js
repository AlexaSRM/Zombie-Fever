"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const alexaAPLExtension_1 = require("./alexaAPLExtension");
const _ = __importStar(require("lodash"));
const ALEXA_SPEECH_TEXT_BLOCK_ID = "alexaSpeechTextBlock";
const ALEXA_SPEECH_ID = "alexaSpeech";
class AdvancedAPLExtension extends alexaAPLExtension_1.AlexaAPLExtension {
    constructor(locale, configAccessor) {
        super(locale, configAccessor);
    }
    async post(param) {
        const handlerInput = param.userInputHelper.getHandlerInput();
        const driver = param.driver;
        let visualProperties = await driver.getVisuals();
        if (handlerInput && visualProperties && visualProperties.length > 0 && this.aplHelper.supportsDisplay(handlerInput)) {
            await this.handleVisualResponse(visualProperties, handlerInput, driver);
        }
    }
    async pre(param) {
        const handlerInput = param.userInputHelper.getHandlerInput();
        if (_.get(handlerInput, "requestEnvelope.request.type", "") === "Alexa.Presentation.APL.UserEvent") {
            const command = _.get(handlerInput, "requestEnvelope.request.arguments[0]", "");
            if (command === "Utterance") {
                const utterance = _.get(handlerInput, "requestEnvelope.request.arguments[1]", "");
                if (utterance) {
                    param.userInputHelper.setInputValue(utterance);
                }
            }
            if (command === "SlotNameValue") {
                const slotName = _.get(handlerInput, "requestEnvelope.request.arguments[1]", "");
                const slotValue = _.get(handlerInput, "requestEnvelope.request.arguments[2]", "");
                if (slotName && slotValue) {
                    param.userInputHelper.addInputSlot(slotName, slotValue);
                }
            }
        }
    }
    async handleVisualResponse(visualProperties, handlerInput, driver) {
        this.deserializeVisualProperties(visualProperties);
        let combinedVisualProps = Object.assign({}, visualProperties[0]);
        combinedVisualProps.scenes = [];
        visualProperties.forEach((visualProp) => {
            if ((visualProp.template && visualProp.template !== "default") || visualProp.layout) {
                combinedVisualProps.scenes.push(visualProp);
            }
        });
        let visualDirectives = this.aplHelper.generateAPLDirectiveWithVisualOptions([combinedVisualProps]);
        if (visualDirectives.length > 0) {
            visualDirectives[0] = _.cloneDeep(visualDirectives[0]);
            if (combinedVisualProps && combinedVisualProps.template === 'dynamic-pager') {
                this.addLayoutsAndCommandsToDynamicPagerDirective(visualDirectives[0], combinedVisualProps.scenes);
            }
            const aplCommandResult = await this.buildAPLCommandsAndAudio(visualDirectives, visualProperties, handlerInput, driver);
            if (aplCommandResult.addedANonAudioCommand) {
                for (let aplDirective of visualDirectives) {
                    const aplSFBContainer = deepSearch(aplDirective, "id", (k, v) => v === 'SFBAudioAndAlexaSpeechContainer');
                    if (aplSFBContainer && aplSFBContainer.items) {
                        aplCommandResult.textComponents.forEach((speakItemTextComponent) => {
                            aplSFBContainer.items.push(speakItemTextComponent);
                        });
                    }
                    aplCommandResult.textDatasources.forEach((speakItemTextDatasource, index) => {
                        aplDirective.datasources[ALEXA_SPEECH_ID + index] = speakItemTextDatasource;
                    });
                }
            }
            for (let aplDirective of visualDirectives) {
                handlerInput.responseBuilder.addDirective(aplDirective);
            }
            if (aplCommandResult.addedANonAudioCommand) {
                handlerInput.responseBuilder.addDirective({
                    "type": "Alexa.Presentation.APL.ExecuteCommands",
                    "token": "ABC_RENDERED_DOCUMENT",
                    "commands": aplCommandResult.commands
                });
                handlerInput.responseBuilder.speak("");
            }
        }
    }
    addLayoutsAndCommandsToDynamicPagerDirective(visualDirective, scenes) {
        const allAplTemplates = this.aplHelper.getAPLTemplates();
        if (!allAplTemplates) {
            return;
        }
        visualDirective.document.layouts = visualDirective.document.layouts || {};
        visualDirective.document.commands = visualDirective.document.commands || {};
        let layoutNames = new Set();
        scenes.forEach((scene) => {
            const layoutName = scene.layout;
            if (layoutName) {
                layoutNames.add(layoutName);
            }
        });
        Object.keys(allAplTemplates).forEach((templateName) => {
            const templateLayouts = allAplTemplates[templateName].document.layouts;
            const templateCommands = allAplTemplates[templateName].document.commands;
            if (templateLayouts) {
                for (const layoutName of Object.keys(templateLayouts)) {
                    if (layoutNames.has(layoutName)) {
                        visualDirective.document.layouts = _.assign(visualDirective.document.layouts, templateLayouts);
                        visualDirective.document.commands = _.assign(visualDirective.document.commands, templateCommands);
                        break;
                    }
                }
                ;
            }
        });
    }
    async buildAPLCommandsAndAudio(visualDirectives, visualProperties, handlerInput, driver) {
        const firstAPLDirective = visualDirectives[0];
        const alexaSpokenDialogueList = [];
        const documentSpecificCommands = (firstAPLDirective.document && firstAPLDirective.document.commands) ? firstAPLDirective.document.commands : {};
        const speechOutputScenesPerScene = await driver.getSpeechSSMLTextPerScene();
        const visitedSceneIds = driver.getVisitedSceneIDsOnRun();
        console.log("VISUALSCENES");
        console.log(JSON.stringify(visualProperties, undefined, 4));
        console.log(JSON.stringify(speechOutputScenesPerScene, undefined, 4));
        const overallAplCommandList = [];
        let speechOutputSceneIndex = 0;
        let nextSpeechScene = undefined;
        if (speechOutputScenesPerScene.length > speechOutputSceneIndex) {
            nextSpeechScene = speechOutputScenesPerScene[speechOutputSceneIndex];
        }
        let visualSceneIndex = 0;
        let visualTemplateLayoutPgIndex = 0;
        let nextVisualScene = undefined;
        if (visualProperties.length > visualSceneIndex) {
            nextVisualScene = visualProperties[visualSceneIndex];
        }
        let addedANonAudioCommand = false;
        visitedSceneIds.forEach((visitedSceneId, sceneIndex) => {
            const sceneCommandList = [];
            console.log("SCENE");
            console.log(JSON.stringify(nextVisualScene, undefined, 4));
            console.log(JSON.stringify(nextSpeechScene, undefined, 4));
            if (nextSpeechScene && nextSpeechScene.sceneID === visitedSceneId) {
                this.addAudioForScene(nextSpeechScene, sceneCommandList, alexaSpokenDialogueList);
                speechOutputSceneIndex++;
                if (speechOutputScenesPerScene && speechOutputScenesPerScene.length > speechOutputSceneIndex) {
                    nextSpeechScene = speechOutputScenesPerScene[speechOutputSceneIndex];
                }
                else {
                    nextSpeechScene = undefined;
                }
            }
            if (nextVisualScene && nextVisualScene.sceneID === visitedSceneId) {
                const beforeCount = sceneCommandList.length;
                this.addVisualCommandsForScene(nextVisualScene, sceneCommandList, visualTemplateLayoutPgIndex, documentSpecificCommands);
                addedANonAudioCommand = addedANonAudioCommand || (beforeCount !== sceneCommandList.length);
                visualSceneIndex++;
                if (visualProperties && visualProperties.length > visualSceneIndex) {
                    nextVisualScene = visualProperties[visualSceneIndex];
                }
                else {
                    nextVisualScene = undefined;
                }
                if (nextVisualScene && ((nextVisualScene.template && nextVisualScene.template !== "default") || nextVisualScene.layout)) {
                    visualTemplateLayoutPgIndex++;
                }
            }
            if (sceneCommandList.length > 0) {
                overallAplCommandList.push({
                    "type": "Parallel",
                    "commands": sceneCommandList
                });
            }
        });
        const speakItemRequests = this.generateAlexaSpeakItemComponents(alexaSpokenDialogueList);
        return { commands: overallAplCommandList, addedANonAudioCommand, textComponents: speakItemRequests.textComponents, textDatasources: speakItemRequests.textDatasources };
    }
    generateAlexaSpeakItemComponents(alexaSpeechList) {
        let additionalTextBlocks = [];
        let additionalDataSources = [];
        alexaSpeechList.forEach((speechSSML, index) => {
            additionalTextBlocks.push({
                "type": "Text",
                "speech": "${payload." + ALEXA_SPEECH_ID + index + ".properties.speech}",
                "id": ALEXA_SPEECH_TEXT_BLOCK_ID + index
            });
            additionalDataSources.push({
                "type": "object",
                "properties": {
                    "ssml": `<speak>${speechSSML}</speak>`
                },
                "transformers": [
                    {
                        "inputPath": "ssml",
                        "outputName": "speech",
                        "transformer": "ssmlToSpeech"
                    }
                ]
            });
        });
        return { textComponents: additionalTextBlocks, textDatasources: additionalDataSources };
    }
    addAudioForScene(scene, sceneCommandList, alexaSpokenDialogueList) {
        let audioCommandListToPlay = [];
        const ssml = scene.ssml ? scene.ssml.trim() : scene.ssml;
        let partitioningRegex = /(<audio[\s]+src='[^><]+?'[\s]*?\/>)|([\s\S]+?)(?=<audio|$)/g;
        let partitionMatch = partitioningRegex.exec(ssml);
        while (partitionMatch != null) {
            if (partitionMatch[1] && partitionMatch[1].trim().length > 0) {
                const srcUrlRegex = /<audio src='([^']*?)'/g;
                let srcUrlMatch = srcUrlRegex.exec(partitionMatch[1]);
                if (srcUrlMatch && srcUrlMatch.length > 1) {
                    const audioUrl = srcUrlMatch[1];
                    let playAudioCommand = {
                        "type": "PlayMedia",
                        "componentId": "audioPlayerId",
                        "source": audioUrl
                    };
                    audioCommandListToPlay.push(playAudioCommand);
                }
            }
            else if (partitionMatch[2] && partitionMatch[2].trim().length > 0) {
                const speakItemText = partitionMatch[2].trim();
                let speakItemCommand = {
                    "delay": 200,
                    "type": "SpeakItem",
                    "componentId": ALEXA_SPEECH_TEXT_BLOCK_ID + alexaSpokenDialogueList.length,
                    "highlightMode": "line",
                    "align": "center"
                };
                audioCommandListToPlay.push(speakItemCommand);
                alexaSpokenDialogueList.push(speakItemText);
            }
            partitionMatch = partitioningRegex.exec(ssml);
        }
        if (audioCommandListToPlay.length > 0) {
            sceneCommandList.push({
                "type": "Sequential",
                "commands": audioCommandListToPlay
            });
        }
    }
    addVisualCommandsForScene(scene, sceneCommandList, pgIndex, documentSpecificCommands) {
        if (pgIndex !== 0) {
            if ((scene.template && scene.template !== "default") || scene.layout) {
                this.addCommandIfExists("nextScene", sceneCommandList, documentSpecificCommands, pgIndex);
            }
        }
        if (scene.commands) {
            scene.commands.forEach((commandName) => {
                this.addCommandIfExists(commandName, sceneCommandList, documentSpecificCommands, pgIndex);
            });
        }
    }
    addCommandIfExists(command, commandList, documentSpecificCommands, pgIndex) {
        if (documentSpecificCommands[command]) {
            commandList.push({
                "type": command,
                "pgIndex": pgIndex
            });
        }
        else {
            const commandFromCommonFile = this.aplHelper.generateAPLCommand(command);
            if (commandFromCommonFile) {
                commandFromCommonFile['pgIndex'] = pgIndex;
                commandList.push(commandFromCommonFile);
            }
        }
    }
    deserializeVisualProperties(visualProperties) {
        visualProperties.forEach((visualProp) => {
            for (var propt in visualProp) {
                if (typeof (visualProp[propt]) === 'string') {
                    if (visualProp[propt].startsWith("{") || visualProp[propt].startsWith("[")) {
                        try {
                            const jsonObj = JSON.parse(visualProp[propt]);
                            visualProp[propt] = jsonObj;
                        }
                        catch (e) {
                        }
                    }
                }
            }
        });
    }
}
exports.AdvancedAPLExtension = AdvancedAPLExtension;
function deepSearch(object, key, predicate) {
    if (object.hasOwnProperty(key) && predicate(key, object[key]) === true) {
        return object;
    }
    for (let i = 0; i < Object.keys(object).length; i++) {
        if (typeof object[Object.keys(object)[i]] === "object") {
            let o = deepSearch(object[Object.keys(object)[i]], key, predicate);
            if (o != null) {
                return o;
            }
        }
    }
    return null;
}
//# sourceMappingURL=advancedAPLExtension.js.map