"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const aws_sdk_1 = require("aws-sdk");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const mp3Duration = require('mp3-duration');
var PollyOutFormat;
(function (PollyOutFormat) {
    PollyOutFormat["MP3"] = "mp3";
    PollyOutFormat["JSON"] = "json";
})(PollyOutFormat = exports.PollyOutFormat || (exports.PollyOutFormat = {}));
class PollyUtil {
    constructor(audioAccessor, pollyClient, awsRegion) {
        this.audioAccessor = audioAccessor;
        if (pollyClient) {
            PollyUtil.pollyClient = pollyClient;
        }
        else {
            PollyUtil.pollyClient = new aws_sdk_1.Polly({
                region: awsRegion || "us-east-1",
                signatureVersion: "v4"
            });
        }
    }
    static configurePolly(config) {
        PollyUtil.pollyConfig = config;
        if (config.awsRegion) {
            aws_sdk_1.config.region = config.awsRegion;
        }
        if (config.awsProfileName) {
            const credentials = new aws_sdk_1.SharedIniFileCredentials({ profile: config.awsProfileName });
            aws_sdk_1.config.credentials = credentials;
        }
        if (config.cognito) {
            const cognitoOptions = {
                "IdentityPoolId": config.cognito.identityPoolId
            };
            if (config.cognito.loginWithAmazonAccessToken) {
                cognitoOptions.Logins = {
                    "www.amazon.com": config.cognito.loginWithAmazonAccessToken
                };
            }
            aws_sdk_1.config.credentials = new aws_sdk_1.CognitoIdentityCredentials(cognitoOptions);
        }
    }
    synthesize(request, workingDir, filename, outputFormat = PollyOutFormat.MP3) {
        return new Promise((resolve, reject) => {
            let speechText = request.text.trim();
            let contentExtract = /^<speak>([\s\S]*?)<\/speak>$/.exec(speechText);
            if (contentExtract != null) {
                speechText = contentExtract[1];
            }
            const hasPitchChange = !!(request.pitch && request.pitch.length > 0 && request.pitch !== "+0%" && request.pitch !== "-0%");
            const hasRateChange = !!(request.rate && request.rate.length > 0 && request.rate !== "100%");
            const hasVolumeChange = !!(request.volume !== "1.0" && request.volume !== "1");
            let prosodyOpenTag = "";
            let prosodyCloseTag = "";
            if (hasPitchChange || hasRateChange || hasVolumeChange) {
                let prosodyOptions = "";
                if (hasPitchChange) {
                    prosodyOptions += `pitch='${request.pitch}'`;
                }
                if (hasRateChange) {
                    prosodyOptions += ` rate='${request.rate}'`;
                }
                if (hasVolumeChange) {
                    prosodyOptions += ` volume='${request.volume}'`;
                }
                prosodyOpenTag += `<prosody ${prosodyOptions}>`;
                prosodyCloseTag = `</prosody>`;
            }
            const params = {
                'Text': `<speak>${prosodyOpenTag}${speechText}${prosodyCloseTag}</speak>`,
                'TextType': 'ssml',
                'OutputFormat': outputFormat,
                'VoiceId': request.name,
                'SampleRate': '24000',
            };
            if (request.engine) {
                params.Engine = request.engine;
            }
            if (request.speechMarkTypes) {
                params.SpeechMarkTypes = request.speechMarkTypes;
            }
            PollyUtil.pollyClient.synthesizeSpeech(params, (err, data) => {
                if (err) {
                    // Adding a hook for catching Missing Credentails Error from cognito and say that it is because you are offline
                    if (err.message && err.message.match(/Missing credentials in config/g)) {
                        err.message = "Voice Preview Error: Voice Preview will not work in offline mode. Please connect to an Internet connection or disable Voice Preview.";
                    }
                    else {
                        err.message = "Voice Preview Error: '" + err.message + "' given voice '" + request.name + "' and text '" + request.text + "'";
                    }
                    return reject(err);
                }
                else if (data) {
                    if (data.AudioStream instanceof Buffer) {
                        // If outputFormat is ssml, just return the metadata directly in our callback instead of saving to disk
                        if (outputFormat === PollyOutFormat.JSON) {
                            const speechMarksData = data.AudioStream.toString('utf-8');
                            try {
                                const jsonSpeechMarksObj = JSON.parse(speechMarksData);
                                return resolve(jsonSpeechMarksObj);
                            }
                            catch (err) {
                                reject(err);
                            }
                        }
                        else {
                            const pollyFilename = path.join(workingDir, filename);
                            try {
                                fs.writeFileSync(pollyFilename, data.AudioStream);
                                resolve();
                            }
                            catch (err) {
                                reject(err);
                            }
                        }
                    }
                }
            });
        });
    }
    async estimateSSMLDuration(ssml, workingDir) {
        const audioTagRegex = /<audio[ \t]+?src=['"']([ \S]*?)['"][ \t]*?\/[ \t]*?>/g;
        let match = audioTagRegex.exec(ssml);
        let duration = 0;
        while (match !== null) {
            const url = match[1];
            const fileName = path.basename(url);
            const filePath = path.resolve(workingDir, fileName);
            if (!fs.existsSync(filePath)) {
                await this.audioAccessor.downloadAudio(url, workingDir);
            }
            duration += await this.calculateMP3Duration(filePath);
            match = audioTagRegex.exec(ssml);
        }
        duration += await this.estimateNonAudioTagDuration(ssml, workingDir);
        return duration;
    }
    calculateMP3Duration(filePath) {
        return new Promise((resolve, reject) => {
            mp3Duration(filePath, function (err, durationForThisFile) {
                if (err) {
                    return reject(err);
                }
                const durationInMs = durationForThisFile * 1000.0; // convert to milliseconds
                return resolve(durationInMs);
            });
        });
    }
    async estimateNonAudioTagDuration(ssml, workingDir) {
        let duration = 0;
        const audioTagRegex = /<audio[ \t]+?src=['"'][ \S]*?['"][ \t]*?\/[ \t]*?>/g;
        let nonAudioOnlyText = ssml.replace(audioTagRegex, " ");
        // In tests, the Joanna voice takes the same time to read text as Alexa's natural voice does
        const defaultVoice = 'Joanna';
        // Add a <mark name='the_end'/> tag to the end of the request
        nonAudioOnlyText = nonAudioOnlyText.trim();
        if (nonAudioOnlyText && nonAudioOnlyText.length > 0) {
            nonAudioOnlyText += "<mark name='the_end'/>";
            const pollyConfig = {
                name: defaultVoice,
                text: nonAudioOnlyText,
                delayMs: 0,
                engine: "standard",
                speechMarkTypes: ["ssml"],
                pitch: "+0%",
                rate: "100%",
                volume: "1.0"
            };
            const speechMarks = await this.synthesize(pollyConfig, workingDir, "", PollyOutFormat.JSON);
            if (speechMarks && speechMarks.time) {
                duration = speechMarks.time;
            }
        }
        return duration;
    }
}
exports.PollyUtil = PollyUtil;
//# sourceMappingURL=pollyUtil.js.map