"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const instructionBuilder_1 = require("./instructionBuilder");
/**
 * Builder for [[StoryMetadata]] used for SFB.
 */
class StoryMetadataBuilder {
    constructor(storyID, storyTitle) {
        this.storyID = storyID;
        this.storyTitle = storyTitle;
        this.scenes = [];
    }
    addScene(sceneParam) {
        this.scenes.push(sceneParam);
    }
    setSceneSay(sceneId, say) {
        const i = this.indexOf(sceneId);
        if (i < 0) {
            throw new Error(`Cannot find a scene with ID: '${sceneId}'`);
        }
        this.scenes[i].say = say;
    }
    setSceneRecap(sceneId, recap) {
        const i = this.indexOf(sceneId);
        if (i < 0) {
            throw new Error(`Cannot find a scene with ID: '${sceneId}'`);
        }
        this.scenes[i].recap = recap;
    }
    setSceneReprompt(sceneId, reprompt) {
        const i = this.indexOf(sceneId);
        if (i < 0) {
            throw new Error(`Cannot find a scene with ID: '${sceneId}'`);
        }
        this.scenes[i].reprompt = reprompt;
    }
    setSceneInstructions(sceneId, instructions) {
        const i = this.indexOf(sceneId);
        if (i < 0) {
            throw new Error(`Cannot find a scene with ID: '${sceneId}'`);
        }
        this.scenes[i].then = instructions;
    }
    appendSceneSay(sceneId, say) {
        const i = this.indexOf(sceneId);
        if (i < 0) {
            throw new Error(`Cannot find a scene with ID: '${sceneId}'`);
        }
        this.scenes[i].say += " " + say;
    }
    appendSceneRecap(sceneId, recap) {
        const i = this.indexOf(sceneId);
        if (i < 0) {
            throw new Error(`Cannot find a scene with ID: '${sceneId}'`);
        }
        this.scenes[i].recap += " " + recap;
    }
    appendSceneReprompt(sceneId, reprompt) {
        const i = this.indexOf(sceneId);
        if (i < 0) {
            throw new Error(`Cannot find a scene with ID: '${sceneId}'`);
        }
        this.scenes[i].reprompt += " " + reprompt;
    }
    appendSceneInstructions(sceneId, instructions) {
        const i = this.indexOf(sceneId);
        if (i < 0) {
            throw new Error(`Cannot find a scene with ID: '${sceneId}'`);
        }
        this.scenes[i].then = (this.scenes[i].then || []).concat(instructions);
    }
    indexOf(sceneId) {
        for (let i = 0; i < this.scenes.length; i++) {
            const scene = this.scenes[i];
            if (scene.id === sceneId) {
                return i;
            }
        }
        return -1;
    }
    build() {
        const story = {
            pluginName: "default",
            storyID: this.storyID,
            storyTitle: this.storyTitle,
            scenes: []
        };
        this.scenes.forEach((builderScene) => {
            const instructionBuilder = new instructionBuilder_1.InstructionBuilder();
            if (builderScene.recap) {
                instructionBuilder.setRecap(builderScene.recap);
            }
            if (builderScene.reprompt) {
                instructionBuilder.setReprompt(builderScene.reprompt);
            }
            if (builderScene.then) {
                builderScene.then.forEach((instruction) => {
                    instructionBuilder.addInstruction(instruction);
                });
            }
            story.scenes.push({
                id: builderScene.id,
                contents: [
                    {
                        narration: builderScene.say,
                        sceneDirections: instructionBuilder.build()
                    }
                ]
            });
        });
        return story;
    }
}
exports.StoryMetadataBuilder = StoryMetadataBuilder;
//# sourceMappingURL=storyMetadataBuilder.js.map