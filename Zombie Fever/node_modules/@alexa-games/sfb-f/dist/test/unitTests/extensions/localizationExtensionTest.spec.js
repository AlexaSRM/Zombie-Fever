"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LocalizationExtension_1 = require("./../../../extensions/coreExtensions/LocalizationExtension");
const storyMetadata_1 = require("./../../../story/storyMetadata");
const storyMetadataHelper_1 = require("../../../importPlugins/storyMetadataHelper");
const assert_1 = require("assert");
const sourceContentHelper_1 = require("../../../importPlugins/sourceContentHelper");
describe("Localization Extension Test", function () {
    it("Source Locale Generation Only", async function () {
        const testingLocale = "en-US";
        const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
        const localizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, {}, undefined, "en-US");
        await localizationExtension.extendImportedContent(storyHelper);
        const languageStrings = localizationExtension.getLocalizedStringsObject();
        const resultingStartNarration = languageStrings[testingLocale].translation['start.narration'];
        const expectedStartNarration = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY).getSceneByID('start').contents[0].narration;
        const resultingStartNarrationOnImportedStory = storyHelper.getSceneNarration("start");
        assert_1.strict.equal(resultingStartNarrationOnImportedStory, expectedStartNarration);
        assert_1.strict.equal(resultingStartNarration, expectedStartNarration);
        // utterance translation check
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-restart'], "restart");
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-start over'], "start over");
    });
    it("Undefined source locale resolves to en-US", async function () {
        const testingLocale = "en-US";
        const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
        const localizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, {}, undefined, undefined);
        await localizationExtension.extendImportedContent(storyHelper);
        const languageStrings = localizationExtension.getLocalizedStringsObject();
        const resultingStartNarration = languageStrings[testingLocale].translation['start.narration'];
        const expectedStartNarration = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY).getSceneByID('start').contents[0].narration;
        const resultingStartNarrationOnImportedStory = storyHelper.getSceneNarration("start");
        assert_1.strict.equal(resultingStartNarrationOnImportedStory, expectedStartNarration);
        assert_1.strict.equal(resultingStartNarration, expectedStartNarration);
        // utterance translation check
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-restart'], "restart");
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-start over'], "start over");
    });
    it("None Source Locale Generation Only", async function () {
        const testingLocale = "en-GB";
        const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
        const localizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, {}, undefined, "en-US");
        await localizationExtension.extendImportedContent(storyHelper);
        const languageStrings = localizationExtension.getLocalizedStringsObject();
        const resultingStartNarration = languageStrings[testingLocale].translation['start.narration'];
        const expectedStartNarration = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY).getSceneByID('start').contents[0].narration;
        const resultingStartNarrationOnImportedStory = storyHelper.getSceneNarration("start");
        assert_1.strict.equal(resultingStartNarrationOnImportedStory, expectedStartNarration);
        assert_1.strict.equal(resultingStartNarration, expectedStartNarration);
        // utterance translation check
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-restart'], "restart");
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-start over'], "start over");
    });
    it("Duplicate Source String When Generating None Source Locale String For the First Time", async function () {
        const sourceLocale = "en-US";
        const testingLocale = "en-GB";
        const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
        const localizationExtension = new LocalizationExtension_1.LocalizationExtension(sourceLocale, {}, undefined, sourceLocale);
        await localizationExtension.extendImportedContent(new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY));
        const languageStrings = localizationExtension.getLocalizedStringsObject();
        const noneSrcExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, languageStrings, undefined, sourceLocale);
        await noneSrcExtension.extendImportedContent(storyHelper);
        // en-US (source locale)
        const resultingSourceStartNarration = languageStrings[sourceLocale].translation['start.narration'];
        const expectedSourceStartNarration = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY).getSceneByID('start').contents[0].narration;
        assert_1.strict.equal(resultingSourceStartNarration, expectedSourceStartNarration);
        assert_1.strict.equal(languageStrings[sourceLocale].translation['utterance-restart'], "restart");
        assert_1.strict.equal(languageStrings[sourceLocale].translation['utterance-start over'], "start over");
        // en-GB (second locale)
        const resultingStartNarration = languageStrings[testingLocale].translation['start.narration'];
        const expectedStartNarration = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY).getSceneByID('start').contents[0].narration;
        const resultingStartNarrationOnImportedStory = storyHelper.getSceneNarration("start");
        assert_1.strict.equal(resultingStartNarrationOnImportedStory, expectedStartNarration);
        assert_1.strict.equal(resultingStartNarration, expectedStartNarration);
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-restart'], "restart");
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-start over'], "start over");
    });
    it("Translation for None Source Locale is Not Overwritten On Overwrite == true", async function () {
        const testingLocale = "en-GB";
        const translation = "Translated Text";
        const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
        const localizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, {}, undefined, "en-US");
        await localizationExtension.extendImportedContent(new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY));
        const firstlanguageStrings = localizationExtension.getLocalizedStringsObject();
        firstlanguageStrings[testingLocale].translation['start.narration'] = translation;
        const secondLocalizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, firstlanguageStrings, true, "en-US");
        await secondLocalizationExtension.extendImportedContent(storyHelper);
        const languageStrings = secondLocalizationExtension.getLocalizedStringsObject();
        const resultingStartNarration = languageStrings[testingLocale].translation['start.narration'];
        const expectedStartNarration = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY).getSceneByID('start').contents[0].narration;
        const resultingStartNarrationOnImportedStory = storyHelper.getSceneNarration("start");
        assert_1.strict.notEqual(resultingStartNarrationOnImportedStory, expectedStartNarration);
        assert_1.strict.notEqual(resultingStartNarration, expectedStartNarration);
        assert_1.strict.equal(resultingStartNarration, translation);
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-restart'], "restart");
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-start over'], "start over");
    });
    it("Translation for None Source Locale is Not Overwritten On Overwrite == false", async function () {
        const testingLocale = "en-GB";
        const translation = "Translated Text";
        const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
        const localizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, {}, undefined, "en-US");
        await localizationExtension.extendImportedContent(new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY));
        const firstLanguageStrings = localizationExtension.getLocalizedStringsObject();
        firstLanguageStrings[testingLocale].translation['start.narration'] = translation;
        const secondLocalizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, firstLanguageStrings, false, "en-US");
        await secondLocalizationExtension.extendImportedContent(storyHelper);
        const languageStrings = secondLocalizationExtension.getLocalizedStringsObject();
        const resultingStartNarration = languageStrings[testingLocale].translation['start.narration'];
        const expectedStartNarration = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY).getSceneByID('start').contents[0].narration;
        const resultingStartNarrationOnImportedStory = storyHelper.getSceneNarration("start");
        assert_1.strict.notEqual(resultingStartNarrationOnImportedStory, expectedStartNarration);
        assert_1.strict.notEqual(resultingStartNarration, expectedStartNarration);
        assert_1.strict.equal(resultingStartNarration, translation);
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-restart'], "restart");
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-start over'], "start over");
    });
    it("Translation for None Source Locale Is Not Overwritten On Overwrite == undefined", async function () {
        const testingLocale = "en-GB";
        const translation = "Translated Text";
        const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
        const localizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, {}, undefined, "en-US");
        await localizationExtension.extendImportedContent(new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY));
        const firstLanguageStrings = localizationExtension.getLocalizedStringsObject();
        firstLanguageStrings[testingLocale].translation['start.narration'] = translation;
        const secondLocalizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, firstLanguageStrings, undefined, "en-US");
        await secondLocalizationExtension.extendImportedContent(storyHelper);
        const languageStrings = secondLocalizationExtension.getLocalizedStringsObject();
        const resultingStartNarration = languageStrings[testingLocale].translation['start.narration'];
        const expectedStartNarration = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY).getSceneByID('start').contents[0].narration;
        const resultingStartNarrationOnImportedStory = storyHelper.getSceneNarration("start");
        assert_1.strict.notEqual(resultingStartNarrationOnImportedStory, expectedStartNarration);
        assert_1.strict.notEqual(resultingStartNarration, expectedStartNarration);
        assert_1.strict.equal(resultingStartNarrationOnImportedStory, translation);
        assert_1.strict.equal(resultingStartNarration, translation);
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-restart'], "restart");
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-start over'], "start over");
    });
    it("Edits on languageString for SOURCE is Overwritten when Overwrite == true", async function () {
        const testingLocale = "en-US";
        const translation = "Translated Text";
        const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
        const localizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, {}, undefined, "en-US");
        await localizationExtension.extendImportedContent(new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY));
        const firstLanguageStrings = localizationExtension.getLocalizedStringsObject();
        firstLanguageStrings[testingLocale].translation['start.narration'] = translation;
        const secondLocalizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, firstLanguageStrings, true, "en-US");
        await secondLocalizationExtension.extendImportedContent(storyHelper);
        const languageStrings = secondLocalizationExtension.getLocalizedStringsObject();
        const resultingStartNarration = languageStrings[testingLocale].translation['start.narration'];
        const expectedStartNarration = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY).getSceneByID('start').contents[0].narration;
        const resultingStartNarrationOnImportedStory = storyHelper.getSceneNarration("start");
        assert_1.strict.equal(resultingStartNarrationOnImportedStory, expectedStartNarration);
        assert_1.strict.equal(resultingStartNarration, expectedStartNarration);
        assert_1.strict.notEqual(resultingStartNarrationOnImportedStory, translation);
        assert_1.strict.notEqual(resultingStartNarration, translation);
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-restart'], "restart");
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-start over'], "start over");
    });
    it("Edits on languageString for SOURCE is Not Overwritten by the Source Content When Overwrite == false", async function () {
        const testingLocale = "en-US";
        const translation = "Translated Text";
        const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
        const localizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, {}, undefined, "en-US");
        await localizationExtension.extendImportedContent(new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY));
        const firstLanguageStrings = localizationExtension.getLocalizedStringsObject();
        firstLanguageStrings[testingLocale].translation['start.narration'] = translation;
        const secondLocalizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, firstLanguageStrings, false, "en-US");
        await secondLocalizationExtension.extendImportedContent(storyHelper);
        const languageStrings = secondLocalizationExtension.getLocalizedStringsObject();
        const resultingStartNarration = languageStrings[testingLocale].translation['start.narration'];
        const expectedStartNarration = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY).getSceneByID('start').contents[0].narration;
        const resultingStartNarrationOnImportedStory = storyHelper.getSceneNarration("start");
        assert_1.strict.notEqual(resultingStartNarrationOnImportedStory, expectedStartNarration);
        assert_1.strict.notEqual(resultingStartNarration, expectedStartNarration);
        assert_1.strict.equal(resultingStartNarrationOnImportedStory, translation);
        assert_1.strict.equal(resultingStartNarration, translation);
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-restart'], "restart");
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-start over'], "start over");
    });
    it("Edits on languageString for SOURCE is Not Overwritten by the Source Content When Overwrite == undefined", async function () {
        const testingLocale = "en-US";
        const translation = "Translated Text";
        const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
        const localizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, {}, undefined, "en-US");
        await localizationExtension.extendImportedContent(new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY));
        const firstLanguageStrings = localizationExtension.getLocalizedStringsObject();
        firstLanguageStrings[testingLocale].translation['start.narration'] = translation;
        const secondLocalizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, firstLanguageStrings, undefined, "en-US");
        await secondLocalizationExtension.extendImportedContent(storyHelper);
        const languageStrings = secondLocalizationExtension.getLocalizedStringsObject();
        const resultingStartNarration = languageStrings[testingLocale].translation['start.narration'];
        const expectedStartNarration = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY).getSceneByID('start').contents[0].narration;
        const resultingStartNarrationOnImportedStory = storyHelper.getSceneNarration("start");
        assert_1.strict.notEqual(resultingStartNarrationOnImportedStory, expectedStartNarration);
        assert_1.strict.notEqual(resultingStartNarration, expectedStartNarration);
        assert_1.strict.equal(resultingStartNarrationOnImportedStory, translation);
        assert_1.strict.equal(resultingStartNarration, translation);
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-restart'], "restart");
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-start over'], "start over");
    });
    it("A key on languageString deleted by mistake gets repopulated", async function () {
        const testingLocale = "en-US";
        const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
        const localizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, {}, undefined, "en-US");
        await localizationExtension.extendImportedContent(new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY));
        const firstLanguageStrings = localizationExtension.getLocalizedStringsObject();
        delete firstLanguageStrings[testingLocale].translation['start.narration'];
        const secondLocalizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, firstLanguageStrings, undefined, "en-US");
        await secondLocalizationExtension.extendImportedContent(storyHelper);
        const languageStrings = secondLocalizationExtension.getLocalizedStringsObject();
        const resultingStartNarration = languageStrings[testingLocale].translation['start.narration'];
        const expectedStartNarration = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY).getSceneByID('start').contents[0].narration;
        const resultingStartNarrationOnImportedStory = storyHelper.getSceneNarration("start");
        assert_1.strict.equal(resultingStartNarrationOnImportedStory, expectedStartNarration);
        assert_1.strict.equal(resultingStartNarration, expectedStartNarration);
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-restart'], "restart");
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-start over'], "start over");
    });
    it("Source String Delete => Correlating String ID deleted in languageStrings for all locales, when Overwrite == true", async function () {
        const sourceLocale = "en-US";
        const testingLocales = [
            "en-US",
            "en-GB"
        ];
        let languageString = {};
        // first run; string generation
        for (let locale of testingLocales) {
            const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
            const localizationExtension = new LocalizationExtension_1.LocalizationExtension(locale, languageString, true, sourceLocale);
            await localizationExtension.extendImportedContent(storyHelper);
            languageString = localizationExtension.getLocalizedStringsObject();
        }
        // re-run with deleted scene
        for (let locale of testingLocales) {
            const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(DELETED_STORY);
            const localizationExtension = new LocalizationExtension_1.LocalizationExtension(locale, languageString, true, sourceLocale);
            await localizationExtension.extendImportedContent(storyHelper);
            languageString = localizationExtension.getLocalizedStringsObject();
        }
        // assert in all locales
        for (let locale of testingLocales) {
            const untouchedString = languageString[locale].translation['start.narration'];
            const deletedString = languageString[locale].translation['start.something else'];
            assert_1.strict.notEqual(untouchedString, undefined);
            assert_1.strict.equal(deletedString, undefined);
        }
    });
    it("Source String Delete => Correlating String ID deleted in languageStrings for all locales, when Overwrite == false", async function () {
        const sourceLocale = "en-US";
        const testingLocales = [
            "en-US",
            "en-GB"
        ];
        let languageString = {};
        // first run; string generation
        for (let locale of testingLocales) {
            const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
            const localizationExtension = new LocalizationExtension_1.LocalizationExtension(locale, languageString, false, sourceLocale);
            await localizationExtension.extendImportedContent(storyHelper);
            languageString = localizationExtension.getLocalizedStringsObject();
        }
        // re-run with deleted scene
        for (let locale of testingLocales) {
            const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(DELETED_STORY);
            const localizationExtension = new LocalizationExtension_1.LocalizationExtension(locale, languageString, false, sourceLocale);
            await localizationExtension.extendImportedContent(storyHelper);
            languageString = localizationExtension.getLocalizedStringsObject();
        }
        // assert in all locales
        for (let locale of testingLocales) {
            const untouchedString = languageString[locale].translation['start.narration'];
            const deletedString = languageString[locale].translation['start.something else'];
            assert_1.strict.notEqual(untouchedString, undefined);
            assert_1.strict.equal(deletedString, undefined);
        }
    });
    it("Source String Delete => Correlating String ID deleted in languageStrings for all locales, when Overwrite == undefined", async function () {
        const sourceLocale = "en-US";
        const testingLocales = [
            "en-US",
            "en-GB"
        ];
        let languageString = {};
        // first run; string generation
        for (let locale of testingLocales) {
            const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
            const localizationExtension = new LocalizationExtension_1.LocalizationExtension(locale, languageString, undefined, sourceLocale);
            await localizationExtension.extendImportedContent(storyHelper);
            languageString = localizationExtension.getLocalizedStringsObject();
        }
        // re-run with deleted scene
        for (let locale of testingLocales) {
            const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(DELETED_STORY);
            const localizationExtension = new LocalizationExtension_1.LocalizationExtension(locale, languageString, undefined, sourceLocale);
            await localizationExtension.extendImportedContent(storyHelper);
            languageString = localizationExtension.getLocalizedStringsObject();
        }
        // assert in all locales
        for (let locale of testingLocales) {
            const untouchedString = languageString[locale].translation['start.narration'];
            const deletedString = languageString[locale].translation['start.something else'];
            assert_1.strict.notEqual(untouchedString, undefined);
            assert_1.strict.equal(deletedString, undefined);
        }
    });
    it("Source String Added => Correlating String ID added in languageStrings for all locales, when Overwrite == true", async function () {
        const sourceLocale = "en-US";
        const testingLocales = [
            "en-US",
            "en-GB"
        ];
        let languageString = {};
        // first run; string generation
        for (let locale of testingLocales) {
            const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
            const localizationExtension = new LocalizationExtension_1.LocalizationExtension(locale, languageString, true, sourceLocale);
            await localizationExtension.extendImportedContent(storyHelper);
            languageString = localizationExtension.getLocalizedStringsObject();
        }
        // re-run with deleted scene
        for (let locale of testingLocales) {
            const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(ADDED_STORY);
            const localizationExtension = new LocalizationExtension_1.LocalizationExtension(locale, languageString, true, sourceLocale);
            await localizationExtension.extendImportedContent(storyHelper);
            languageString = localizationExtension.getLocalizedStringsObject();
        }
        // assert in all locales
        for (let locale of testingLocales) {
            const untouchedString = languageString[locale].translation['start.narration'];
            const addedString = languageString[locale].translation['added scene.narration'];
            assert_1.strict.notEqual(untouchedString, undefined);
            assert_1.strict.notEqual(addedString, undefined);
        }
    });
    it("Source String Added => Correlating String ID added in languageStrings for all locales, when Overwrite == false", async function () {
        const sourceLocale = "en-US";
        const testingLocales = [
            "en-US",
            "en-GB"
        ];
        let languageString = {};
        // first run; string generation
        for (let locale of testingLocales) {
            const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
            const localizationExtension = new LocalizationExtension_1.LocalizationExtension(locale, languageString, false, sourceLocale);
            await localizationExtension.extendImportedContent(storyHelper);
            languageString = localizationExtension.getLocalizedStringsObject();
        }
        // re-run with deleted scene
        for (let locale of testingLocales) {
            const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(ADDED_STORY);
            const localizationExtension = new LocalizationExtension_1.LocalizationExtension(locale, languageString, false, sourceLocale);
            await localizationExtension.extendImportedContent(storyHelper);
            languageString = localizationExtension.getLocalizedStringsObject();
        }
        // assert in all locales
        for (let locale of testingLocales) {
            const untouchedString = languageString[locale].translation['start.narration'];
            const addedString = languageString[locale].translation['added scene.narration'];
            assert_1.strict.notEqual(untouchedString, undefined);
            assert_1.strict.notEqual(addedString, undefined);
        }
    });
    it("Source String Added => Correlating String ID added in languageStrings for all locales, when Overwrite == undefined", async function () {
        const sourceLocale = "en-US";
        const testingLocales = [
            "en-US",
            "en-GB"
        ];
        let languageString = {};
        // first run; string generation
        for (let locale of testingLocales) {
            const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY);
            const localizationExtension = new LocalizationExtension_1.LocalizationExtension(locale, languageString, undefined, sourceLocale);
            await localizationExtension.extendImportedContent(storyHelper);
            languageString = localizationExtension.getLocalizedStringsObject();
        }
        // re-run with deleted scene
        for (let locale of testingLocales) {
            const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(ADDED_STORY);
            const localizationExtension = new LocalizationExtension_1.LocalizationExtension(locale, languageString, undefined, sourceLocale);
            await localizationExtension.extendImportedContent(storyHelper);
            languageString = localizationExtension.getLocalizedStringsObject();
        }
        // assert in all locales
        for (let locale of testingLocales) {
            const untouchedString = languageString[locale].translation['start.narration'];
            const addedString = languageString[locale].translation['added scene.narration'];
            assert_1.strict.notEqual(untouchedString, undefined);
            assert_1.strict.notEqual(addedString, undefined);
        }
    });
    it("Edit in SOURCE updates source locale language string when Overwrite == true", async function () {
        const testingLocale = "en-US";
        const localizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, {}, undefined, "en-US");
        await localizationExtension.extendImportedContent(new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY));
        const firstLanguageStrings = localizationExtension.getLocalizedStringsObject();
        const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(CHANGED_STORY);
        const secondLocalizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, firstLanguageStrings, true, "en-US");
        await secondLocalizationExtension.extendImportedContent(storyHelper);
        const languageStrings = secondLocalizationExtension.getLocalizedStringsObject();
        const resultingStartNarration = languageStrings[testingLocale].translation['start.narration'];
        const originalNarration = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY).getSceneByID('start').contents[0].narration;
        const changedNarration = new storyMetadataHelper_1.StoryMetadataHelper(CHANGED_STORY).getSceneByID('start').contents[0].narration;
        const resultingStartNarrationOnImportedStory = storyHelper.getSceneNarration("start");
        assert_1.strict.equal(resultingStartNarrationOnImportedStory, changedNarration);
        assert_1.strict.equal(resultingStartNarration, changedNarration);
        assert_1.strict.notEqual(resultingStartNarrationOnImportedStory, originalNarration);
        assert_1.strict.notEqual(resultingStartNarration, originalNarration);
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-restart'], "restart");
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-start over'], "start over");
    });
    it("Edit in SOURCE does NOT update source locale language string when Overwrite == false", async function () {
        const testingLocale = "en-US";
        const localizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, {}, undefined, "en-US");
        await localizationExtension.extendImportedContent(new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY));
        const firstLanguageStrings = localizationExtension.getLocalizedStringsObject();
        const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(CHANGED_STORY);
        const secondLocalizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, firstLanguageStrings, false, "en-US");
        await secondLocalizationExtension.extendImportedContent(storyHelper);
        const languageStrings = secondLocalizationExtension.getLocalizedStringsObject();
        const resultingStartNarration = languageStrings[testingLocale].translation['start.narration'];
        const originalNarration = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY).getSceneByID('start').contents[0].narration;
        const changedNarration = new storyMetadataHelper_1.StoryMetadataHelper(CHANGED_STORY).getSceneByID('start').contents[0].narration;
        const resultingStartNarrationOnImportedStory = storyHelper.getSceneNarration("start");
        assert_1.strict.equal(resultingStartNarrationOnImportedStory, originalNarration);
        assert_1.strict.equal(resultingStartNarration, originalNarration);
        assert_1.strict.notEqual(resultingStartNarrationOnImportedStory, changedNarration);
        assert_1.strict.notEqual(resultingStartNarration, changedNarration);
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-restart'], "restart");
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-start over'], "start over");
    });
    it("Edit in SOURCE does NOT update source locale language string when Overwrite == undefined", async function () {
        const testingLocale = "en-US";
        const localizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, {}, undefined, "en-US");
        await localizationExtension.extendImportedContent(new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY));
        const firstLanguageStrings = localizationExtension.getLocalizedStringsObject();
        const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(CHANGED_STORY);
        const secondLocalizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, firstLanguageStrings, undefined, "en-US");
        await secondLocalizationExtension.extendImportedContent(storyHelper);
        const languageStrings = secondLocalizationExtension.getLocalizedStringsObject();
        const resultingStartNarration = languageStrings[testingLocale].translation['start.narration'];
        const originalNarration = new storyMetadataHelper_1.StoryMetadataHelper(TEST_STORY).getSceneByID('start').contents[0].narration;
        const changedNarration = new storyMetadataHelper_1.StoryMetadataHelper(CHANGED_STORY).getSceneByID('start').contents[0].narration;
        const resultingStartNarrationOnImportedStory = storyHelper.getSceneNarration("start");
        assert_1.strict.equal(resultingStartNarrationOnImportedStory, originalNarration);
        assert_1.strict.equal(resultingStartNarration, originalNarration);
        assert_1.strict.notEqual(resultingStartNarrationOnImportedStory, changedNarration);
        assert_1.strict.notEqual(resultingStartNarration, changedNarration);
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-restart'], "restart");
        assert_1.strict.equal(languageStrings[testingLocale].translation['utterance-start over'], "start over");
    });
    it("Unused extension method 'extendSourceContent' does not throw when called", async function () {
        const testingLocale = "en-GB";
        const localizationExtension = new LocalizationExtension_1.LocalizationExtension(testingLocale, {}, undefined, "en-US");
        await localizationExtension.extendSourceContent(new sourceContentHelper_1.SourceContentHelper([
            {
                id: "test.abc",
                text: "@start"
            }
        ]));
    });
});
const TEST_STORY = {
    pluginName: "something",
    scenes: [
        {
            contents: [
                {
                    narration: "testing narration",
                    sceneDirections: [
                        {
                            directionType: storyMetadata_1.InstructionType.REPROMPT,
                            parameters: {
                                message: "this is a reprompt"
                            }
                        },
                        {
                            directionType: storyMetadata_1.InstructionType.REPROMPT,
                            parameters: {
                                message: "this is a recap"
                            }
                        },
                        {
                            directionType: storyMetadata_1.InstructionType.CHOICE,
                            parameters: {
                                "utterances": [
                                    "restart",
                                    "start over"
                                ],
                                "saveToHistory": "true",
                                "directions": [
                                    {
                                        "directionType": "bookmark",
                                        "parameters": {
                                            "variableName": "bookmark"
                                        },
                                    },
                                    {
                                        "directionType": "go to",
                                        "parameters": {
                                            "target": "restart confirm",
                                            "targetSceneProperty": "narration"
                                        },
                                    }
                                ]
                            }
                        }
                    ]
                },
            ],
            id: "start"
        },
        {
            contents: [
                {
                    narration: "testing narration",
                    sceneDirections: [
                        {
                            directionType: storyMetadata_1.InstructionType.CHOICE,
                            parameters: {
                                "utterances": [
                                    "restart",
                                    "start over"
                                ],
                                "saveToHistory": "true",
                                "directions": [
                                    {
                                        "directionType": "bookmark",
                                        "parameters": {
                                            "variableName": "bookmark"
                                        },
                                    },
                                    {
                                        "directionType": "go to",
                                        "parameters": {
                                            "target": "restart confirm",
                                            "targetSceneProperty": "narration"
                                        },
                                    }
                                ]
                            }
                        }
                    ]
                },
            ],
            id: "something else"
        }
    ],
    storyID: "something",
    storyTitle: "something"
};
const CHANGED_STORY = {
    pluginName: "something",
    scenes: [
        {
            contents: [
                {
                    narration: "Changed Narration",
                    sceneDirections: [
                        {
                            directionType: storyMetadata_1.InstructionType.REPROMPT,
                            parameters: {
                                message: "this is a reprompt"
                            }
                        },
                        {
                            directionType: storyMetadata_1.InstructionType.REPROMPT,
                            parameters: {
                                message: "this is a recap"
                            }
                        },
                        {
                            directionType: storyMetadata_1.InstructionType.CHOICE,
                            parameters: {
                                "utterances": [
                                    "restart",
                                    "start over"
                                ],
                                "saveToHistory": "true",
                                "directions": [
                                    {
                                        "directionType": "bookmark",
                                        "parameters": {
                                            "variableName": "bookmark"
                                        },
                                    },
                                    {
                                        "directionType": "go to",
                                        "parameters": {
                                            "target": "restart confirm",
                                            "targetSceneProperty": "narration"
                                        },
                                    }
                                ]
                            }
                        }
                    ]
                },
            ],
            id: "start"
        }
    ],
    storyID: "something",
    storyTitle: "something"
};
const DELETED_STORY = {
    pluginName: "something",
    scenes: [
        {
            contents: [
                {
                    narration: "testing narration",
                    sceneDirections: [
                        {
                            directionType: storyMetadata_1.InstructionType.REPROMPT,
                            parameters: {
                                message: "this is a reprompt"
                            }
                        },
                        {
                            directionType: storyMetadata_1.InstructionType.REPROMPT,
                            parameters: {
                                message: "this is a recap"
                            }
                        },
                        {
                            directionType: storyMetadata_1.InstructionType.CHOICE,
                            parameters: {
                                "utterances": [
                                    "restart",
                                    "start over"
                                ],
                                "saveToHistory": "true",
                                "directions": [
                                    {
                                        "directionType": "bookmark",
                                        "parameters": {
                                            "variableName": "bookmark"
                                        },
                                    },
                                    {
                                        "directionType": "go to",
                                        "parameters": {
                                            "target": "restart confirm",
                                            "targetSceneProperty": "narration"
                                        },
                                    }
                                ]
                            }
                        }
                    ]
                },
            ],
            id: "start"
        }
    ],
    storyID: "something",
    storyTitle: "something"
};
const ADDED_STORY = {
    pluginName: "something",
    scenes: [
        {
            contents: [
                {
                    narration: "testing narration",
                    sceneDirections: [
                        {
                            directionType: storyMetadata_1.InstructionType.REPROMPT,
                            parameters: {
                                message: "this is a reprompt"
                            }
                        },
                        {
                            directionType: storyMetadata_1.InstructionType.REPROMPT,
                            parameters: {
                                message: "this is a recap"
                            }
                        },
                        {
                            directionType: storyMetadata_1.InstructionType.CHOICE,
                            parameters: {
                                "utterances": [
                                    "restart",
                                    "start over"
                                ],
                                "saveToHistory": "true",
                                "directions": [
                                    {
                                        "directionType": "bookmark",
                                        "parameters": {
                                            "variableName": "bookmark"
                                        },
                                    },
                                    {
                                        "directionType": "go to",
                                        "parameters": {
                                            "target": "restart confirm",
                                            "targetSceneProperty": "narration"
                                        },
                                    }
                                ]
                            }
                        }
                    ]
                },
            ],
            id: "start"
        },
        {
            contents: [
                {
                    narration: "testing narration",
                    sceneDirections: [
                        {
                            directionType: storyMetadata_1.InstructionType.CHOICE,
                            parameters: {
                                "utterances": [
                                    "restart",
                                    "start over"
                                ],
                                "saveToHistory": "true",
                                "directions": [
                                    {
                                        "directionType": "bookmark",
                                        "parameters": {
                                            "variableName": "bookmark"
                                        },
                                    },
                                    {
                                        "directionType": "go to",
                                        "parameters": {
                                            "target": "restart confirm",
                                            "targetSceneProperty": "narration"
                                        },
                                    }
                                ]
                            }
                        }
                    ]
                },
            ],
            id: "something else"
        },
        {
            contents: [
                {
                    narration: "testing narration",
                    sceneDirections: [
                        {
                            directionType: storyMetadata_1.InstructionType.CHOICE,
                            parameters: {
                                "utterances": [
                                    "restart",
                                    "start over"
                                ],
                                "saveToHistory": "true",
                                "directions": [
                                    {
                                        "directionType": "bookmark",
                                        "parameters": {
                                            "variableName": "bookmark"
                                        },
                                    },
                                    {
                                        "directionType": "go to",
                                        "parameters": {
                                            "target": "restart confirm",
                                            "targetSceneProperty": "narration"
                                        },
                                    }
                                ]
                            }
                        }
                    ]
                },
            ],
            id: "added scene"
        }
    ],
    storyID: "something",
    storyTitle: "something"
};
//# sourceMappingURL=localizationExtensionTest.spec.js.map