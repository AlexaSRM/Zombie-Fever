{"version":3,"file":"segmenter.spec.js","sourceRoot":"","sources":["../../../../test/unitTests/parsers/segmenter.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { SegmentType, SegmenterBuilder } from '../../../transformers/segmenter';\nimport { strict as assert } from 'assert';\n\n// Segmenter is stateless and so can be used globally.\nconst segmenterAll = SegmenterBuilder.getAllSegmenter();\nconst segmenterVar = SegmenterBuilder.getVariableSegmenter();\n\ndescribe(\"Segmenter\", function () {\n    it(\"simple plain text string\", function () {\n        \n        const outputString = \"Simple single segment plain text string.\";\n\n        const segments = segmenterAll.parse(outputString);\n\n        \n        assert.equal(segments.length, 1, 'Should produce a single segment.');\n        assert.equal(segments[0].type, SegmentType.PlainText, 'This is a plain text example.');\n        assert.equal(segments[0].value, outputString, 'Single segment value should equal original value.');\n        assert.equal(segments[0].original, segments[0].value, 'Plain text segment value and original are the same.');\n    });\n\n    it(\"simple {variable} string\", function () {\n        \n        const outputString = \"{var}\";\n\n        const segments = segmenterAll.parse(outputString);\n        \n        assert.equal(segments.length, 1, 'Should produce a single segment.');\n        assert.equal(segments[0].type, SegmentType.Variable, 'This is a variable example.');\n        assert.equal(segments[0].value, 'var', 'Single segment value should not equal original value.');\n        assert.equal(segments[0].original, outputString, 'Original should match the whole string.');\n    });\n\n    it(\"simple {error string\", function () {\n        \n        const outputString = \"{error\";\n\n        const segments = segmenterAll.parse(outputString);\n        \n        assert.equal(segments.length, 1, 'Should produce a single segment.');\n        assert.equal(segments[0].type, SegmentType.Error, 'This is a error example.');\n        assert.equal(segments[0].value, outputString, 'Single segment value should equal original value.');\n        assert.equal(segments[0].original, outputString, 'Original should match the whole string.');\n    });\n\n    it(\"simple plain text and variable string\", function () {\n        \n        const outputString = \"Hi {name}, you should see the look on {otherPerson}'s face.\";\n\n        const segments = segmenterAll.parse(outputString);\n        \n        assert.equal(segments.length, 5, 'Should produce 5 segments.');\n        assert.equal(segments[0].type, SegmentType.PlainText, 'This is a plain text example.');\n        assert.equal(segments[1].type, SegmentType.Variable, 'This is a variable example.');\n        assert.equal(segments[2].type, SegmentType.PlainText, 'This is a plain text example.');\n        assert.equal(segments[3].type, SegmentType.Variable, 'This is a variable example.');\n        assert.equal(segments[4].type, SegmentType.PlainText, 'This is a plain text example.');\n\n        assert.equal(segments[3].value, 'otherPerson');\n        assert.equal(segments[4].value, '\\'s face.');\n\n        const reassembled = segments.map((s) => s.original).join('');\n\n        assert.equal(outputString, reassembled, 'String reassembled from original segments should match original string.');\n    });\n   \n\n    it(\"Nested bracket types.\", function () {\n        \n        const outputString = \"One {<not an element>} but rather [{is a snippet]\";\n\n        const segments = segmenterAll.parse(outputString);\n        \n        assert.equal(segments.length, 4, 'Should produce 4 segments.');\n        assert.equal(segments[0].type, SegmentType.PlainText, 'This is a plain text example.');\n        assert.equal(segments[1].type, SegmentType.Variable, 'This is a variable example.');\n        assert.equal(segments[2].type, SegmentType.PlainText, 'This is a plain text example.');\n        assert.equal(segments[3].type, SegmentType.Snippet, 'This is a snippet example.');\n\n        assert.equal(segments[1].value, '<not an element>');\n        assert.equal(segments[2].value, ' but rather ');\n\n        const reassembled = segments.map((s) => s.original).join('');\n\n        assert.equal(outputString, reassembled, 'String reassembled from original segments should match original string.');\n    });\n\n    it(\"Mixed with an error.\", function () {\n        \n        const outputString = \"I have a compl{ex<type} with an [error because I forgot to close the snippet.\";\n\n        const segments = segmenterAll.parse(outputString);\n        \n        assert.equal(segments.length, 4, 'Should produce 4 segments.');\n        assert.equal(segments[0].type, SegmentType.PlainText, 'This is a plain text example.');\n        assert.equal(segments[1].type, SegmentType.Variable, 'This is a variable example.');\n        assert.equal(segments[2].type, SegmentType.PlainText, 'This is a plain text example.');\n        assert.equal(segments[3].type, SegmentType.Error, 'This is a error example.');\n\n        assert.equal(segments[0].value, 'I have a compl');\n        assert.equal(segments[1].value, 'ex<type');\n        assert.equal(segments[2].value, ' with an ');\n        assert.equal(segments[3].value, '[error because I forgot to close the snippet.');\n\n        const reassembled = segments.map((s) => s.original).join('');\n\n        assert.equal(outputString, reassembled, 'String reassembled from original segments should match original string.');\n    });\n\n    it(\"Mixed without plain text.\", function () {\n        \n        const outputString = \"{var1}{var2}{var1}[snippet1]<element1>{var4}[snippet2]\";\n\n        const segments = segmenterAll.parse(outputString);\n        \n        assert.equal(segments.length, 7, 'Should produce 7 segments.');\n        assert.equal(segments[0].type, SegmentType.Variable, 'This is a variable text example.');\n        assert.equal(segments[1].type, SegmentType.Variable, 'This is a variable example.');\n        assert.equal(segments[2].type, SegmentType.Variable, 'This is a variable text example.');\n        assert.equal(segments[3].type, SegmentType.Snippet, 'This is a snippet example.');\n        assert.equal(segments[4].type, SegmentType.Element, 'This is a element example.');\n        assert.equal(segments[5].type, SegmentType.Variable, 'This is a variable example.');\n        assert.equal(segments[6].type, SegmentType.Snippet, 'This is a snippet example.');\n\n        assert.equal(segments[0].value, 'var1');\n        assert.equal(segments[1].value, 'var2');\n        assert.equal(segments[2].value, 'var1');\n        assert.equal(segments[3].value, 'snippet1');\n        assert.equal(segments[4].value, '<element1>');\n        assert.equal(segments[5].value, 'var4');\n        assert.equal(segments[6].value, 'snippet2');\n\n        const reassembled = segments.map((s) => s.original).join('');\n\n        assert.equal(outputString, reassembled, 'String reassembled from original segments should match original string.');\n    });\n\n\n    it(\"Mixed but Variable segmenter only.\", function () {\n        \n        const outputString = \"{var1}{var2}{var1}[snippet1]<element1>{var4}[snippet2]\";\n\n        const segments = segmenterVar.parse(outputString);\n        \n        assert.equal(segments.length, 6, 'Should produce 6 segments.');\n        assert.equal(segments[0].type, SegmentType.Variable, 'This is a variable text example.');\n        assert.equal(segments[1].type, SegmentType.Variable, 'This is a variable example.');\n        assert.equal(segments[2].type, SegmentType.Variable, 'This is a variable text example.');\n        assert.equal(segments[3].type, SegmentType.PlainText, 'This is a snippet example.');\n        assert.equal(segments[4].type, SegmentType.Variable, 'This is a variable example.');\n        assert.equal(segments[5].type, SegmentType.PlainText, 'This is a snippet example.');\n\n        assert.equal(segments[0].value, 'var1');\n        assert.equal(segments[1].value, 'var2');\n        assert.equal(segments[2].value, 'var1');\n        assert.equal(segments[3].value, '[snippet1]<element1>');\n        assert.equal(segments[4].value, 'var4');\n        assert.equal(segments[5].value, '[snippet2]');\n\n        const reassembled = segments.map((s) => s.original).join('');\n\n        assert.equal(outputString, reassembled, 'String reassembled from original segments should match original string.');\n    });\n});"]}