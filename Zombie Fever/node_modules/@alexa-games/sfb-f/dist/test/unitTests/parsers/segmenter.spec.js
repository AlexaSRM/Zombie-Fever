"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const segmenter_1 = require("../../../transformers/segmenter");
const assert_1 = require("assert");
// Segmenter is stateless and so can be used globally.
const segmenterAll = segmenter_1.SegmenterBuilder.getAllSegmenter();
const segmenterVar = segmenter_1.SegmenterBuilder.getVariableSegmenter();
describe("Segmenter", function () {
    it("simple plain text string", function () {
        const outputString = "Simple single segment plain text string.";
        const segments = segmenterAll.parse(outputString);
        assert_1.strict.equal(segments.length, 1, 'Should produce a single segment.');
        assert_1.strict.equal(segments[0].type, segmenter_1.SegmentType.PlainText, 'This is a plain text example.');
        assert_1.strict.equal(segments[0].value, outputString, 'Single segment value should equal original value.');
        assert_1.strict.equal(segments[0].original, segments[0].value, 'Plain text segment value and original are the same.');
    });
    it("simple {variable} string", function () {
        const outputString = "{var}";
        const segments = segmenterAll.parse(outputString);
        assert_1.strict.equal(segments.length, 1, 'Should produce a single segment.');
        assert_1.strict.equal(segments[0].type, segmenter_1.SegmentType.Variable, 'This is a variable example.');
        assert_1.strict.equal(segments[0].value, 'var', 'Single segment value should not equal original value.');
        assert_1.strict.equal(segments[0].original, outputString, 'Original should match the whole string.');
    });
    it("simple {error string", function () {
        const outputString = "{error";
        const segments = segmenterAll.parse(outputString);
        assert_1.strict.equal(segments.length, 1, 'Should produce a single segment.');
        assert_1.strict.equal(segments[0].type, segmenter_1.SegmentType.Error, 'This is a error example.');
        assert_1.strict.equal(segments[0].value, outputString, 'Single segment value should equal original value.');
        assert_1.strict.equal(segments[0].original, outputString, 'Original should match the whole string.');
    });
    it("simple plain text and variable string", function () {
        const outputString = "Hi {name}, you should see the look on {otherPerson}'s face.";
        const segments = segmenterAll.parse(outputString);
        assert_1.strict.equal(segments.length, 5, 'Should produce 5 segments.');
        assert_1.strict.equal(segments[0].type, segmenter_1.SegmentType.PlainText, 'This is a plain text example.');
        assert_1.strict.equal(segments[1].type, segmenter_1.SegmentType.Variable, 'This is a variable example.');
        assert_1.strict.equal(segments[2].type, segmenter_1.SegmentType.PlainText, 'This is a plain text example.');
        assert_1.strict.equal(segments[3].type, segmenter_1.SegmentType.Variable, 'This is a variable example.');
        assert_1.strict.equal(segments[4].type, segmenter_1.SegmentType.PlainText, 'This is a plain text example.');
        assert_1.strict.equal(segments[3].value, 'otherPerson');
        assert_1.strict.equal(segments[4].value, '\'s face.');
        const reassembled = segments.map((s) => s.original).join('');
        assert_1.strict.equal(outputString, reassembled, 'String reassembled from original segments should match original string.');
    });
    it("Nested bracket types.", function () {
        const outputString = "One {<not an element>} but rather [{is a snippet]";
        const segments = segmenterAll.parse(outputString);
        assert_1.strict.equal(segments.length, 4, 'Should produce 4 segments.');
        assert_1.strict.equal(segments[0].type, segmenter_1.SegmentType.PlainText, 'This is a plain text example.');
        assert_1.strict.equal(segments[1].type, segmenter_1.SegmentType.Variable, 'This is a variable example.');
        assert_1.strict.equal(segments[2].type, segmenter_1.SegmentType.PlainText, 'This is a plain text example.');
        assert_1.strict.equal(segments[3].type, segmenter_1.SegmentType.Snippet, 'This is a snippet example.');
        assert_1.strict.equal(segments[1].value, '<not an element>');
        assert_1.strict.equal(segments[2].value, ' but rather ');
        const reassembled = segments.map((s) => s.original).join('');
        assert_1.strict.equal(outputString, reassembled, 'String reassembled from original segments should match original string.');
    });
    it("Mixed with an error.", function () {
        const outputString = "I have a compl{ex<type} with an [error because I forgot to close the snippet.";
        const segments = segmenterAll.parse(outputString);
        assert_1.strict.equal(segments.length, 4, 'Should produce 4 segments.');
        assert_1.strict.equal(segments[0].type, segmenter_1.SegmentType.PlainText, 'This is a plain text example.');
        assert_1.strict.equal(segments[1].type, segmenter_1.SegmentType.Variable, 'This is a variable example.');
        assert_1.strict.equal(segments[2].type, segmenter_1.SegmentType.PlainText, 'This is a plain text example.');
        assert_1.strict.equal(segments[3].type, segmenter_1.SegmentType.Error, 'This is a error example.');
        assert_1.strict.equal(segments[0].value, 'I have a compl');
        assert_1.strict.equal(segments[1].value, 'ex<type');
        assert_1.strict.equal(segments[2].value, ' with an ');
        assert_1.strict.equal(segments[3].value, '[error because I forgot to close the snippet.');
        const reassembled = segments.map((s) => s.original).join('');
        assert_1.strict.equal(outputString, reassembled, 'String reassembled from original segments should match original string.');
    });
    it("Mixed without plain text.", function () {
        const outputString = "{var1}{var2}{var1}[snippet1]<element1>{var4}[snippet2]";
        const segments = segmenterAll.parse(outputString);
        assert_1.strict.equal(segments.length, 7, 'Should produce 7 segments.');
        assert_1.strict.equal(segments[0].type, segmenter_1.SegmentType.Variable, 'This is a variable text example.');
        assert_1.strict.equal(segments[1].type, segmenter_1.SegmentType.Variable, 'This is a variable example.');
        assert_1.strict.equal(segments[2].type, segmenter_1.SegmentType.Variable, 'This is a variable text example.');
        assert_1.strict.equal(segments[3].type, segmenter_1.SegmentType.Snippet, 'This is a snippet example.');
        assert_1.strict.equal(segments[4].type, segmenter_1.SegmentType.Element, 'This is a element example.');
        assert_1.strict.equal(segments[5].type, segmenter_1.SegmentType.Variable, 'This is a variable example.');
        assert_1.strict.equal(segments[6].type, segmenter_1.SegmentType.Snippet, 'This is a snippet example.');
        assert_1.strict.equal(segments[0].value, 'var1');
        assert_1.strict.equal(segments[1].value, 'var2');
        assert_1.strict.equal(segments[2].value, 'var1');
        assert_1.strict.equal(segments[3].value, 'snippet1');
        assert_1.strict.equal(segments[4].value, '<element1>');
        assert_1.strict.equal(segments[5].value, 'var4');
        assert_1.strict.equal(segments[6].value, 'snippet2');
        const reassembled = segments.map((s) => s.original).join('');
        assert_1.strict.equal(outputString, reassembled, 'String reassembled from original segments should match original string.');
    });
    it("Mixed but Variable segmenter only.", function () {
        const outputString = "{var1}{var2}{var1}[snippet1]<element1>{var4}[snippet2]";
        const segments = segmenterVar.parse(outputString);
        assert_1.strict.equal(segments.length, 6, 'Should produce 6 segments.');
        assert_1.strict.equal(segments[0].type, segmenter_1.SegmentType.Variable, 'This is a variable text example.');
        assert_1.strict.equal(segments[1].type, segmenter_1.SegmentType.Variable, 'This is a variable example.');
        assert_1.strict.equal(segments[2].type, segmenter_1.SegmentType.Variable, 'This is a variable text example.');
        assert_1.strict.equal(segments[3].type, segmenter_1.SegmentType.PlainText, 'This is a snippet example.');
        assert_1.strict.equal(segments[4].type, segmenter_1.SegmentType.Variable, 'This is a variable example.');
        assert_1.strict.equal(segments[5].type, segmenter_1.SegmentType.PlainText, 'This is a snippet example.');
        assert_1.strict.equal(segments[0].value, 'var1');
        assert_1.strict.equal(segments[1].value, 'var2');
        assert_1.strict.equal(segments[2].value, 'var1');
        assert_1.strict.equal(segments[3].value, '[snippet1]<element1>');
        assert_1.strict.equal(segments[4].value, 'var4');
        assert_1.strict.equal(segments[5].value, '[snippet2]');
        const reassembled = segments.map((s) => s.original).join('');
        assert_1.strict.equal(outputString, reassembled, 'String reassembled from original segments should match original string.');
    });
});
//# sourceMappingURL=segmenter.spec.js.map