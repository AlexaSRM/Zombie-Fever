"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const driver_1 = require("../../driver/driver");
const driverEntity_1 = require("./../../driver/driverEntity");
const sfb_polly_1 = require("@alexa-games/sfb-polly");
const assert_1 = require("assert");
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const ffmpeg = require('ffmpeg-static');
const testOutputDir = path.resolve(".", ".out");
if (!fs.existsSync(testOutputDir)) {
    fs.mkdirSync(testOutputDir);
}
describe("Driver Unit Test", function () {
    it("buildAudioScenes(): modified polly item w/ SFB polly disabled.", async function () {
        const driver = getDefaultBaseDriver();
        const testVoiceName = "Brian";
        const testPitch = "+10%";
        const testRate = "120%";
        const testContent = "this the text to be wrapped in polly tag.";
        // polly audio item with pitch and/or rate changed
        const modifiedPollyAudio = {
            sceneID: "modified polly audio scene",
            background: [],
            foreground: [{
                    content: testContent,
                    delay: 0,
                    options: {
                        voice: testVoiceName,
                        pitch: testPitch,
                        rate: testRate
                    },
                    type: driverEntity_1.AlexaAudioType.POLLY,
                    volume: 1
                }]
        };
        const { ssml, pretty } = await driver.buildAudioScenes([modifiedPollyAudio]);
        assert_1.strict.equal(ssml, `<voice name='${testVoiceName}'><prosody pitch='${testPitch}' rate='${testRate}'>${testContent}</prosody></voice>`);
        assert_1.strict.equal(pretty, `<voice name='${testVoiceName}'><prosody pitch='${testPitch}' rate='${testRate}'>${testContent}</prosody></voice>`);
    });
    it("buildAudioScenes(): UN-modified polly item w/ SFB polly disabled.", async function () {
        const driver = getDefaultBaseDriver();
        // polly audio item with pitch and/or rate UN-changed
        const testVoiceName = "Brian";
        const testPitch = "+0%";
        const testRate = "100%";
        const testContent = "this the text to be wrapped in polly tag.";
        const unmodifiedPollyAudio = {
            sceneID: "modified polly audio scene",
            background: [],
            foreground: [{
                    content: testContent,
                    delay: 0,
                    options: {
                        voice: testVoiceName,
                        pitch: testPitch,
                        rate: testRate
                    },
                    type: driverEntity_1.AlexaAudioType.POLLY,
                    volume: 1
                }]
        };
        const { ssml, pretty } = await driver.buildAudioScenes([unmodifiedPollyAudio]);
        assert_1.strict.equal(ssml, `<voice name='${testVoiceName}'>${testContent}</voice>`);
        assert_1.strict.equal(pretty, `<voice name='${testVoiceName}'>${testContent}</voice>`);
    });
    /**
     * Background audio items should be ignored when SFB polly is not used.
     */
    it("buildAudioScenes(): background exists w/ SFB polly disabled. ", async function () {
        const driver = getDefaultBaseDriver();
        const testContent = "https://audio.url/file.mp3";
        const testBackgroundContent = "https://background.url/file.mp3";
        const audioTagItem = {
            sceneID: "modified polly audio scene",
            background: [{
                    content: testBackgroundContent,
                    delay: 0,
                    type: driverEntity_1.AlexaAudioType.AUDIO,
                    volume: 1
                }],
            foreground: [{
                    content: testContent,
                    delay: 0,
                    type: driverEntity_1.AlexaAudioType.AUDIO,
                    volume: 1
                }]
        };
        const { ssml, pretty } = await driver.buildAudioScenes([audioTagItem]);
        assert_1.strict.equal(ssml, `<audio src='${testContent}' />`);
        assert_1.strict.equal(pretty, `<audio src='${testContent}' />`);
    });
    it("buildAudioScenes(): modified polly item w/ SFB polly enabled.", async function () {
        this.timeout(10000);
        const mockAudioAccessor = new HappyAudioAccessor();
        const mockPollyUtil = new HappyPollyUtil(mockAudioAccessor);
        const driver = getSFBPollyEnabledDriver(mockAudioAccessor, mockPollyUtil);
        const testVoiceName = "Brian";
        const testPitch = "+10%";
        const testRate = "120%";
        const testContent = "this the text to be wrapped in polly tag.";
        // polly audio item with pitch and/or rate changed
        const modifiedPollyAudio = {
            sceneID: "modified polly audio scene",
            background: [],
            foreground: [{
                    content: testContent,
                    delay: 0,
                    options: {
                        voice: testVoiceName,
                        pitch: testPitch,
                        rate: testRate
                    },
                    type: driverEntity_1.AlexaAudioType.POLLY,
                    volume: 1
                }]
        };
        const { ssml, pretty } = await driver.buildAudioScenes([modifiedPollyAudio]);
        assert_1.strict.equal(ssml, `<audio src='fake.url/pollyb3bd98f337deb388f02cc9e180790018.mp3' />`);
        assert_1.strict.equal(pretty, `<voice name='${testVoiceName}'><prosody pitch='${testPitch}' rate='${testRate}'>${testContent}</prosody></voice>`);
    });
    it("buildAudioScenes(): UN-modified polly item w/ SFB polly enabled.", async function () {
        this.timeout(10000);
        const mockAudioAccessor = new HappyAudioAccessor();
        const mockPollyUtil = new HappyPollyUtil(mockAudioAccessor);
        const driver = getSFBPollyEnabledDriver(mockAudioAccessor, mockPollyUtil);
        // polly audio item with pitch and/or rate UN-changed
        const testVoiceName = "Brian";
        const testPitch = "+0%";
        const testRate = "100%";
        const testContent = "this the text to be wrapped in polly tag.";
        const unmodifiedPollyAudio = {
            sceneID: "modified polly audio scene",
            background: [],
            foreground: [{
                    content: testContent,
                    delay: 0,
                    options: {
                        voice: testVoiceName,
                        pitch: testPitch,
                        rate: testRate
                    },
                    type: driverEntity_1.AlexaAudioType.POLLY,
                    volume: 1
                }]
        };
        const { ssml, pretty } = await driver.buildAudioScenes([unmodifiedPollyAudio]);
        assert_1.strict.equal(ssml, `<audio src='fake.url/polly1e53b9853a4800f917b7718b64b39321.mp3' />`);
        assert_1.strict.equal(pretty, `<voice name='${testVoiceName}'>${testContent}</voice>`);
    });
    it("buildAudioScenes(): Audio tag", async function () {
        const driver = getDefaultBaseDriver();
        const testContent = "https://audio.url/file.mp3";
        const audioTagItem = {
            sceneID: "modified polly audio scene",
            background: [],
            foreground: [{
                    content: testContent,
                    delay: 0,
                    type: driverEntity_1.AlexaAudioType.AUDIO,
                    volume: 1
                }]
        };
        const { ssml, pretty } = await driver.buildAudioScenes([audioTagItem]);
        assert_1.strict.equal(ssml, `<audio src='${testContent}' />`);
        assert_1.strict.equal(pretty, `<audio src='${testContent}' />`);
    });
    it("buildAudioScenes(): reduce 6 consecutive audio to 5 audio tags", async function () {
        const mockAudioAccessor = new HappyAudioAccessor();
        const mockPollyUtil = new HappyPollyUtil(mockAudioAccessor);
        const driver = getSFBPollyEnabledDriver(mockAudioAccessor, mockPollyUtil);
        const testContent = "https://audio.url/file";
        const audioTagItem = {
            sceneID: "modified polly audio scene",
            background: [],
            foreground: [{
                    content: `${testContent}1.mp3`,
                    delay: 0,
                    type: driverEntity_1.AlexaAudioType.AUDIO,
                    volume: 1
                },
                {
                    content: `${testContent}2.mp3`,
                    delay: 0,
                    type: driverEntity_1.AlexaAudioType.AUDIO,
                    volume: 1
                },
                {
                    content: `${testContent}3.mp3`,
                    delay: 0,
                    type: driverEntity_1.AlexaAudioType.AUDIO,
                    volume: 1
                },
                {
                    content: `${testContent}4.mp3`,
                    delay: 0,
                    type: driverEntity_1.AlexaAudioType.AUDIO,
                    volume: 1
                },
                {
                    content: `${testContent}5.mp3`,
                    delay: 0,
                    type: driverEntity_1.AlexaAudioType.AUDIO,
                    volume: 1
                },
                {
                    content: `${testContent}6.mp3`,
                    delay: 0,
                    type: driverEntity_1.AlexaAudioType.AUDIO,
                    volume: 1
                }]
        };
        const { ssml, pretty } = await driver.buildAudioScenes([audioTagItem]);
        const tagMatch = ssml.match(/<audio src=\'[\S]+?\' \/>/g);
        if (tagMatch !== null) {
            assert_1.strict.equal(tagMatch.length, 5);
        }
        else {
            assert_1.strict.fail();
        }
        assert_1.strict.equal(ssml, `<audio src='fake.url/a455dfecd690dcdfe1a5874e3228747b.mp3' /><audio src='${testContent}3.mp3' /><audio src='${testContent}4.mp3' /><audio src='${testContent}5.mp3' /><audio src='${testContent}6.mp3' />`);
        assert_1.strict.equal(pretty, `<audio src='${testContent}1.mp3' /><audio src='${testContent}2.mp3' /><audio src='${testContent}3.mp3' /><audio src='${testContent}4.mp3' /><audio src='${testContent}5.mp3' /><audio src='${testContent}6.mp3' />`);
    });
    it("buildAudioScenes(): reduce 6 audio items with text item in the middle to 5 audio tags", async function () {
        const mockAudioAccessor = new HappyAudioAccessor();
        const mockPollyUtil = new HappyPollyUtil(mockAudioAccessor);
        const driver = getSFBPollyEnabledDriver(mockAudioAccessor, mockPollyUtil);
        const testContent = "https://audio.url/file";
        const audioTagItem = {
            sceneID: "modified polly audio scene",
            background: [],
            foreground: [{
                    content: `${testContent}1.mp3`,
                    delay: 0,
                    type: driverEntity_1.AlexaAudioType.AUDIO,
                    volume: 1
                },
                {
                    content: `${testContent}2.mp3`,
                    delay: 0,
                    type: driverEntity_1.AlexaAudioType.AUDIO,
                    volume: 1
                },
                {
                    content: `${testContent}3.mp3`,
                    delay: 0,
                    type: driverEntity_1.AlexaAudioType.AUDIO,
                    volume: 1
                },
                {
                    content: `some text`,
                    delay: 0,
                    type: driverEntity_1.AlexaAudioType.TEXT,
                    volume: 1
                },
                {
                    content: `${testContent}4.mp3`,
                    delay: 0,
                    type: driverEntity_1.AlexaAudioType.AUDIO,
                    volume: 1
                },
                {
                    content: `${testContent}5.mp3`,
                    delay: 0,
                    type: driverEntity_1.AlexaAudioType.AUDIO,
                    volume: 1
                },
                {
                    content: `${testContent}6.mp3`,
                    delay: 0,
                    type: driverEntity_1.AlexaAudioType.AUDIO,
                    volume: 1
                }]
        };
        const { ssml, pretty } = await driver.buildAudioScenes([audioTagItem]);
        const tagMatch = ssml.match(/<audio src=\'[\S]+?\' \/>/g);
        if (tagMatch !== null) {
            assert_1.strict.equal(tagMatch.length, 5);
        }
        else {
            assert_1.strict.fail();
        }
        assert_1.strict.equal(ssml, `<audio src='fake.url/a455dfecd690dcdfe1a5874e3228747b.mp3' /><audio src='${testContent}3.mp3' /> some text<audio src='${testContent}4.mp3' /><audio src='${testContent}5.mp3' /><audio src='${testContent}6.mp3' />`);
        assert_1.strict.equal(pretty, `<audio src='${testContent}1.mp3' /><audio src='${testContent}2.mp3' /><audio src='${testContent}3.mp3' /> some text<audio src='${testContent}4.mp3' /><audio src='${testContent}5.mp3' /><audio src='${testContent}6.mp3' />`);
    });
});
function getDefaultBaseDriver() {
    const driver = new driver_1.ACEDriver({
        storyTitle: 'test story',
        storyID: "test-story",
        pluginName: 'default',
        scenes: [{
                id: "start",
                contents: [
                    {
                        narration: "test narration"
                    }
                ]
            }]
    });
    return driver;
}
function getSFBPollyEnabledDriver(audioAccessorMock, pollyUtilMock) {
    const driver = new driver_1.ACEDriver({
        storyTitle: 'test story',
        storyID: "test-story",
        pluginName: 'default',
        scenes: [{
                id: "start",
                contents: [
                    {
                        narration: "test narration"
                    }
                ]
            }]
    }, undefined, undefined, {
        "enabled": true,
        "combineAudioTags": true,
        "dontUseCache": false,
        "FFMPEGLocation": ffmpeg.path,
        "workingDir": testOutputDir,
        "bucketName": "test-bucket",
        "s3DomainName": "s3.amazon.com",
        "cognito": {
            identityPoolId: "us-east-1:11cce95b-36e9-4d5e-8e95-db76d27d1ab0",
            loginWithAmazonAccessToken: ""
        }
    }, undefined, audioAccessorMock, pollyUtilMock);
    return driver;
}
class HappyAudioAccessor {
    async exists(audioName) {
        return true;
    }
    async downloadAudio(audioName, workingDirectoryPath) {
        //do nothing
    }
    async getAudioURL(audioName) {
        return `fake.url/${audioName}`;
    }
    async uploadAudio(audioName, workingDirectoryPath) {
        return await this.getAudioURL(audioName);
    }
}
class HappyPollyUtil extends sfb_polly_1.PollyUtil {
    async synthesize(request, workingDir, filename, outputFormat) {
        return;
    }
    async estimateSSMLDuration(ssml, workingDir) {
        return 1000;
    }
}
//# sourceMappingURL=driver.spec.js.map