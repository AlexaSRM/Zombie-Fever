"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const VoiceModelBuilder_1 = require("./../../../bakeUtilities/VoiceModelBuilder");
const assert_1 = require("assert");
const numberToAlphabetCounting = VoiceModelBuilder_1.ModelBuilderHelper.numberToAlphabetCounting;
describe("auto voice model generating utility test", function () {
    before(async function () {
        VoiceModelBuilder_1.ModelBuilderHelper.autoSlotCount = 0;
        VoiceModelBuilder_1.ModelBuilderHelper.autoIntentCount = 0;
    });
    it("Slot Number to Alphabet Conversion", async function () {
        assert_1.strict.equal(numberToAlphabetCounting(0), 'a');
        assert_1.strict.equal(numberToAlphabetCounting(1), 'b');
        assert_1.strict.equal(numberToAlphabetCounting(2), 'c');
        assert_1.strict.equal(numberToAlphabetCounting(3), 'd');
        assert_1.strict.equal(numberToAlphabetCounting(4), 'e');
        assert_1.strict.equal(numberToAlphabetCounting(5), 'f');
        assert_1.strict.equal(numberToAlphabetCounting(6), 'g');
        assert_1.strict.equal(numberToAlphabetCounting(7), 'h');
        assert_1.strict.equal(numberToAlphabetCounting(8), 'i');
        assert_1.strict.equal(numberToAlphabetCounting(9), 'j');
        assert_1.strict.equal(numberToAlphabetCounting(10), 'k');
        assert_1.strict.equal(numberToAlphabetCounting(11), 'l');
        assert_1.strict.equal(numberToAlphabetCounting(12), 'm');
        assert_1.strict.equal(numberToAlphabetCounting(13), 'n');
        assert_1.strict.equal(numberToAlphabetCounting(14), 'o');
        assert_1.strict.equal(numberToAlphabetCounting(15), 'p');
        assert_1.strict.equal(numberToAlphabetCounting(16), 'q');
        assert_1.strict.equal(numberToAlphabetCounting(17), 'r');
        assert_1.strict.equal(numberToAlphabetCounting(18), 's');
        assert_1.strict.equal(numberToAlphabetCounting(19), 't');
        assert_1.strict.equal(numberToAlphabetCounting(20), 'u');
        assert_1.strict.equal(numberToAlphabetCounting(21), 'v');
        assert_1.strict.equal(numberToAlphabetCounting(22), 'w');
        assert_1.strict.equal(numberToAlphabetCounting(23), 'x');
        assert_1.strict.equal(numberToAlphabetCounting(24), 'y');
        assert_1.strict.equal(numberToAlphabetCounting(25), 'z');
        assert_1.strict.equal(numberToAlphabetCounting(26), 'ba');
        assert_1.strict.equal(numberToAlphabetCounting(27), 'bb');
        assert_1.strict.equal(numberToAlphabetCounting(100), 'dw');
    });
    it("buildCategoriesFromUtteranceTyping() - empty utterance lists", async function () {
        const result = VoiceModelBuilder_1.ModelBuilderHelper.buildCategoriesFromUtteranceTyping([], [], [], [], {}, {});
        assert_1.strict.equal(result.length, 0);
    });
    it("buildCategoriesFromUtteranceTyping() - generate new intent category", async function () {
        const result = VoiceModelBuilder_1.ModelBuilderHelper.buildCategoriesFromUtteranceTyping([], ["test one", "test two", "test three"], [], [], {}, {});
        assert_1.strict.equal(result.length, 1);
        assert_1.strict.equal(result[0].id, "flexaIntent");
    });
    it("buildCategoriesFromUtteranceTyping() - intent utterances already used in existing categories", async function () {
        const testingCategoryName = "already used intent";
        const testingCategoryName2 = "already used intent2";
        const existingCategoryMap = {
            "test one": {
                id: testingCategoryName,
                type: VoiceModelBuilder_1.CategoryType.INTENT,
                utterances: ["test one"]
            },
            "test four": {
                id: testingCategoryName2,
                type: VoiceModelBuilder_1.CategoryType.INTENT,
                utterances: ["test four"]
            }
        };
        const oneOverlapResult = VoiceModelBuilder_1.ModelBuilderHelper.buildCategoriesFromUtteranceTyping([], ["test one", "test two", "test three"], [], [], {}, existingCategoryMap);
        assert_1.strict.equal(oneOverlapResult.length, 1);
        assert_1.strict.equal(oneOverlapResult[0].utterances.length, 3);
        assert_1.strict.ok(oneOverlapResult[0].utterances.includes("test one"));
        assert_1.strict.ok(oneOverlapResult[0].utterances.includes("test two"));
        assert_1.strict.ok(oneOverlapResult[0].utterances.includes("test three"));
        const twoOverlapResult = VoiceModelBuilder_1.ModelBuilderHelper.buildCategoriesFromUtteranceTyping([], ["test one", "test two", "test three", "test four", "test five"], [], [], {}, existingCategoryMap);
        assert_1.strict.equal(twoOverlapResult.length, 2);
        assert_1.strict.equal(twoOverlapResult[0].utterances.length, 3);
        assert_1.strict.ok(twoOverlapResult[0].utterances.includes("test one"));
        assert_1.strict.ok(twoOverlapResult[0].utterances.includes("test two"));
        assert_1.strict.ok(twoOverlapResult[0].utterances.includes("test three"));
        assert_1.strict.equal(twoOverlapResult[1].utterances.length, 2);
        assert_1.strict.ok(twoOverlapResult[1].utterances.includes("test four"));
        assert_1.strict.ok(twoOverlapResult[1].utterances.includes("test five"));
    });
    it("buildVoiceModelFromCategory() - intents with empty utterances", async function () {
        const testCategories = [
            {
                id: "intentOne",
                type: VoiceModelBuilder_1.CategoryType.INTENT,
                utterances: [
                    "sample one",
                    "sample two",
                    "sample three"
                ]
            },
            {
                id: "intentTwo",
                type: VoiceModelBuilder_1.CategoryType.INTENT,
                utterances: []
            },
        ];
        const result = VoiceModelBuilder_1.ModelBuilderHelper.buildVoiceModelFromCategory(testCategories, "testInvocation", {}, {});
        assert_1.strict.equal(result.languageModel.intents.length, 1, "Unexpected number of resulting intents.");
        for (let i = 0; i < result.languageModel.intents.length; i++) {
            const intent = result.languageModel.intents[i];
            if (intent.samples) {
                assert_1.strict.notEqual(intent.samples.length, 0, "Detected intents with 0 samples");
            }
            else {
                assert_1.strict.fail(`Unexpected intent without samples: ${intent.name}`);
            }
        }
    });
    it("buildVoiceModelFromCategory() - build model from [[CategoryType.AUTO_SLOT]] category items", async function () {
        const testCategories = [
            {
                id: "intentOne",
                type: VoiceModelBuilder_1.CategoryType.AUTO_SLOT,
                utterances: [
                    "sample one",
                    "sample two",
                    "sample three"
                ]
            },
            {
                id: "intenTwo",
                type: VoiceModelBuilder_1.CategoryType.AUTO_SLOT,
                utterances: [
                    "sample four",
                    "sample five"
                ]
            },
        ];
        const result = VoiceModelBuilder_1.ModelBuilderHelper.buildVoiceModelFromCategory(testCategories, "testInvocation", {}, {});
        assert_1.strict.equal(result.languageModel.intents.length, 1, "Unexpected number of resulting intents.");
        if (result.languageModel.intents[0].samples) {
            assert_1.strict.equal(result.languageModel.intents[0].samples.length, 2);
        }
        else {
            assert_1.strict.fail(`Samples for ${result.languageModel.intents[0].name} is unexptectedly empty.`);
        }
        if (result.languageModel.types) {
            assert_1.strict.equal(result.languageModel.types.length, 2);
            assert_1.strict.equal(result.languageModel.types[0].name, testCategories[0].id + "Type");
            assert_1.strict.equal(result.languageModel.types[1].name, testCategories[1].id + "Type");
        }
        else {
            assert_1.strict.fail(`SlotType is expected, but was not present.`);
        }
    });
    it("buildBuiltInSampleToIntentMap() - generate utterance to intent name map for built-in intent", async function () {
        const resultMap = VoiceModelBuilder_1.ModelBuilderHelper.buildBuiltInSampleToIntentMap({
            "TestBuiltInIntent1": [
                "utterance 1 for TestBuiltInIntent1",
                "utterance 2 for TestBuiltInIntent1",
                "utterance 3 for TestBuiltInIntent1"
            ],
            "TestBuiltInIntent2": [
                "utterance 1 for TestBuiltInIntent2",
                "utterance 2 for TestBuiltInIntent2",
                "utterance 3 for TestBuiltInIntent2"
            ]
        });
        assert_1.strict.equal(resultMap["utterance 1 for TestBuiltInIntent1"], undefined, "The utterance for intent was not LowerCased");
        assert_1.strict.equal(resultMap["utterance 1 for testbuiltinintent1"], "TestBuiltInIntent1", "utterance does not map correctly to the test intent: TestBuiltInIntent1");
        assert_1.strict.equal(resultMap["utterance 2 for testbuiltinintent1"], "TestBuiltInIntent1", "utterance does not map correctly to the test intent: TestBuiltInIntent1");
        assert_1.strict.equal(resultMap["utterance 3 for testbuiltinintent1"], "TestBuiltInIntent1", "utterance does not map correctly to the test intent: TestBuiltInIntent1");
        assert_1.strict.equal(resultMap["utterance 1 for testbuiltinintent2"], "TestBuiltInIntent2", "utterance does not map correctly to the test intent: TestBuiltInIntent2");
        assert_1.strict.equal(resultMap["utterance 2 for testbuiltinintent2"], "TestBuiltInIntent2", "utterance does not map correctly to the test intent: TestBuiltInIntent2");
        assert_1.strict.equal(resultMap["utterance 3 for testbuiltinintent2"], "TestBuiltInIntent2", "utterance does not map correctly to the test intent: TestBuiltInIntent2");
    });
    it("buildBuiltInSampleToIntentMap() - non EN lower casing test", async function () {
        const resultMap = VoiceModelBuilder_1.ModelBuilderHelper.buildBuiltInSampleToIntentMap({
            "TestBuiltInIntent1": [
                "TestBuiltInIntent1の発話1",
                "TestBuiltInIntent1の発話2",
                "TestBuiltInIntent1の発話3"
            ],
            "TestBuiltInIntent2": [
                "TestBuiltInIntent2の発話1",
                "TestBuiltInIntent2の発話2",
                "TestBuiltInIntent2の発話3"
            ]
        });
        assert_1.strict.equal(resultMap["TestBuiltInIntent1の発話1"], undefined, "The utterance for intent was not LowerCased");
        assert_1.strict.equal(resultMap["testbuiltinintent1の発話1"], "TestBuiltInIntent1", "utterance 'testbuiltinintent1の発話1' does not map correctly to the test intent: TestBuiltInIntent1");
        assert_1.strict.equal(resultMap["testbuiltinintent1の発話2"], "TestBuiltInIntent1", "utterance 'testbuiltinintent1の発話2' does not map correctly to the test intent: TestBuiltInIntent1");
        assert_1.strict.equal(resultMap["testbuiltinintent1の発話3"], "TestBuiltInIntent1", "utterance 'testbuiltinintent1の発話3' does not map correctly to the test intent: TestBuiltInIntent1");
        assert_1.strict.equal(resultMap["testbuiltinintent2の発話1"], "TestBuiltInIntent2", "utterance 'testbuiltinintent2の発話1' does not map correctly to the test intent: TestBuiltInIntent2");
        assert_1.strict.equal(resultMap["testbuiltinintent2の発話2"], "TestBuiltInIntent2", "utterance 'testbuiltinintent2の発話2' does not map correctly to the test intent: TestBuiltInIntent2");
        assert_1.strict.equal(resultMap["testbuiltinintent2の発話3"], "TestBuiltInIntent2", "utterance 'testbuiltinintent3の発話3' does not map correctly to the test intent: TestBuiltInIntent2");
    });
    it("splitUtteranceType() - splits to types appropriately", async function () {
        const autoIntentTarget = "utterance one";
        const autoSlotNumericTarget = "utterance 2";
        const customSlotTarget = "{slotName} woo hoo";
        const builtInTarget = "built in utterance";
        const result = VoiceModelBuilder_1.ModelBuilderHelper.splitUtteranceType([autoIntentTarget, autoSlotNumericTarget, customSlotTarget, builtInTarget], {
            [builtInTarget]: 'BuiltInIntent'
        }, {
            "slotName": 'CustomSlotType'
        });
        assert_1.strict.equal(result.autoIntents[0], autoIntentTarget);
        assert_1.strict.equal(result.autoSlots[0], autoSlotNumericTarget);
        assert_1.strict.equal(result.builtInIntents[0], builtInTarget);
        assert_1.strict.equal(result.customSlots[0], customSlotTarget.replace("{slotName}", "{slotName as CustomSlotType}"));
    });
    it("buildCategoriesForChoice() - test for proper categorization and de-duping of category.", async function () {
        const autoIntentTarget = "utterance one";
        const autoSlotNumericTarget = "utterance 2";
        const customSlotTarget = "{slotName} woo hoo";
        const builtInTarget = "built in utterance";
        const usedUtterance = "Already Used Within Scene Utterance";
        const lowerCaseUsedUtterance = usedUtterance.toLowerCase();
        const testUtterances = [
            autoIntentTarget,
            autoSlotNumericTarget,
            customSlotTarget,
            builtInTarget,
            usedUtterance
        ];
        const existingCategory = {
            id: "AlreadyUsedIntent",
            type: VoiceModelBuilder_1.CategoryType.INTENT,
            utterances: [
                lowerCaseUsedUtterance
            ]
        };
        const result = VoiceModelBuilder_1.ModelBuilderHelper.buildCategoriesForChoice(testUtterances, {
            [existingCategory.id]: true
        }, {
            "slotName": 'CustomSlotType'
        }, {
            [builtInTarget]: 'BuiltInIntent'
        }, {
            [lowerCaseUsedUtterance]: existingCategory
        });
        assert_1.strict.equal(existingCategory.utterances.length, 0, "duplicating utterance is not removed from the existing category.");
        let hasBuiltIn = false;
        let hasAutoSlot = false;
        let hasCustomSlot = false;
        let hasIntent = false;
        for (let category of result) {
            if (category.type === VoiceModelBuilder_1.CategoryType.BUILT_IN_INTENT) {
                hasBuiltIn = true;
                assert_1.strict.equal(category.utterances.length, 0, "BuiltInIntent utterances should always be empty.");
            }
            else if (category.type === VoiceModelBuilder_1.CategoryType.AUTO_SLOT) {
                hasAutoSlot = true;
                assert_1.strict.equal(category.utterances.length, 1);
                assert_1.strict.ok(category.utterances.includes(autoSlotNumericTarget), `Expected utterance for auto slot '${autoSlotNumericTarget}' is not found.`);
            }
            else if (category.type === VoiceModelBuilder_1.CategoryType.CUSTOM_SLOT) {
                hasCustomSlot = true;
                assert_1.strict.equal(category.utterances.length, 1);
                assert_1.strict.equal(category.utterances[0], customSlotTarget.replace("{slotName}", "{slotName as CustomSlotType}"));
            }
            else if (category.type === VoiceModelBuilder_1.CategoryType.INTENT) {
                hasIntent = true;
                assert_1.strict.equal(category.utterances.length, 2);
                assert_1.strict.ok(category.utterances.includes(lowerCaseUsedUtterance));
                assert_1.strict.ok(category.utterances.includes(autoIntentTarget));
            }
        }
        assert_1.strict.ok(hasBuiltIn, "Expected intent 'BuiltInIntent' does not exist in the reuslt");
        assert_1.strict.ok(hasAutoSlot, "Expected category type 'Auto Slot' does not exist in the reuslt");
        assert_1.strict.ok(hasCustomSlot, "Expected category type 'Custom Slot' does not exist in the reuslt");
        assert_1.strict.ok(hasIntent, "Expected category type 'Intent' does not exist in the reuslt");
    });
});
//# sourceMappingURL=voiceModelBuilder.spec.js.map