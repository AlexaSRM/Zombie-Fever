"use strict";
/**
 * Last Updated Aug-13-2019
 * As found in https://developer.amazon.com/docs/smapi/interaction-model-schema.html
 */
Object.defineProperty(exports, "__esModule", { value: true });
class LanguageModelBuilder {
    constructor(invocationName) {
        this.model = {
            languageModel: {
                intents: [],
                invocationName: invocationName,
            }
        };
    }
    build() {
        return this.model;
    }
    addSlotSamplesToIntent(intentName, samples, slots) {
        if (this.intentExists(intentName)) {
            for (let intentItem of this.model.languageModel.intents) {
                if (intentItem.name === intentName) {
                    const combinedSamples = this.concatDedupe(samples, intentItem.samples || [], (a) => {
                        return a;
                    });
                    const combinedSlots = this.concatDedupe(slots, intentItem.slots || [], (a) => {
                        return a.name;
                    });
                    intentItem.samples = combinedSamples;
                    intentItem.slots = combinedSlots;
                    break;
                }
            }
        }
        else {
            this.addIntent({
                name: intentName,
                samples: samples,
                slots: slots
            });
        }
        return this;
    }
    addIntent(intent) {
        if (this.intentExists(intent.name)) {
            for (let intentItem of this.model.languageModel.intents) {
                if (intentItem.name === intent.name) {
                    intentItem.samples = intent.samples;
                    intentItem.slots = intent.slots;
                    break;
                }
            }
        }
        else {
            this.model.languageModel.intents.push(intent);
        }
        return this;
    }
    addSlotType(slotType) {
        if (!this.model.languageModel.types) {
            this.model.languageModel.types = [];
        }
        if (this.slotTypeExists(slotType.name)) {
            for (let typeItem of this.model.languageModel.types) {
                if (typeItem.name === slotType.name) {
                    typeItem.values = slotType.values;
                    break;
                }
            }
        }
        else {
            this.model.languageModel.types.push(slotType);
        }
        return this;
    }
    addSlotValues(slotTypeName, values) {
        if (!this.model.languageModel.types) {
            this.model.languageModel.types = [];
        }
        const slotValues = [];
        for (let valueItem of values) {
            if (LanguageModelBuilder.isSlotValue(valueItem)) {
                slotValues.push(valueItem);
            }
            else if (typeof (valueItem) === "string") {
                slotValues.push(this.buildSlotValue(valueItem));
            }
        }
        if (this.slotTypeExists(slotTypeName)) {
            for (let typeItem of this.model.languageModel.types) {
                if (typeItem.name === slotTypeName) {
                    const combined = this.concatDedupe(typeItem.values, slotValues, (a) => {
                        return JSON.stringify(a);
                    });
                    typeItem.values = combined;
                    break;
                }
            }
        }
        else {
            this.model.languageModel.types.push({
                name: slotTypeName,
                values: slotValues
            });
        }
    }
    slotTypeExists(slotTypeName) {
        if (this.model.languageModel.types) {
            for (let type of this.model.languageModel.types) {
                if (type.name === slotTypeName) {
                    return true;
                }
            }
        }
        return false;
    }
    intentExists(intentName) {
        for (let intent of this.model.languageModel.intents) {
            if (intent.name === intentName) {
                return true;
            }
        }
        return false;
    }
    buildSlotValue(value) {
        return {
            name: {
                value: value
            }
        };
    }
    concatDedupe(arr1, arry2, hash) {
        const result = {};
        arr1.forEach((item) => {
            const itemHash = hash(item);
            result[itemHash] = item;
        });
        arry2.forEach((item) => {
            const itemHash = hash(item);
            result[itemHash] = item;
        });
        return Object.values(result);
    }
    /**
     * Verifies if the object is an instance of interface [[LanguageModelValue]]
     */
    static isSlotValue(object) {
        let isSlotValue = true;
        const isObject = typeof (object) === "object";
        isSlotValue = isSlotValue && isObject;
        if (isObject) {
            const hasID = "id" in object;
            const hasName = "name" in object;
            isSlotValue = isSlotValue && hasName;
            if (hasID) {
                isSlotValue = isSlotValue && typeof (object.id) === "string";
            }
            if (hasName) {
                const isNameCorrect = typeof (object.name) === "object";
                const isNameValueCorrect = isNameCorrect && "value" in object.name && typeof (object.name.value) === "string";
                const hasSynonyms = isNameCorrect && "synonyms" in object.name;
                isSlotValue = isSlotValue && isNameCorrect && isNameValueCorrect;
                if (hasSynonyms) {
                    const isNameSynonymsCorrect = typeof (object.name.synonyms) === "object";
                    isSlotValue = isSlotValue && isNameSynonymsCorrect;
                    const hasNameSynonymsItem = isNameSynonymsCorrect && object.name.synonyms[0];
                    if (hasNameSynonymsItem) {
                        const isNameSynonymsItemCorrect = typeof (object.name.synonyms[0]) === "string";
                        isSlotValue = isSlotValue && isNameSynonymsItemCorrect;
                    }
                }
            }
        }
        return isSlotValue;
    }
}
exports.LanguageModelBuilder = LanguageModelBuilder;
//# sourceMappingURL=languageModel.js.map