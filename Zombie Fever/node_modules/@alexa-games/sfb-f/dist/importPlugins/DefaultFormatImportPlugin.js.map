{"version":3,"file":"DefaultFormatImportPlugin.js","sourceRoot":"","sources":["../../importPlugins/DefaultFormatImportPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { ImportResult, ImportErrorLine } from '../importer/importerEntity';\nimport { VisualOptions } from '../driver/driverEntity';\nimport { ABCImportPlugin } from '../importPlugins/importerPlugin';\nimport { Scene, Instruction, InstructionType, SceneVariation } from '../story/storyMetadata';\nimport { InstructionBuilder } from '../story/instructionBuilder';\nimport { ContentItem } from '../importer/importer';\n\nexport class DefaultFormatImportPlugin implements ABCImportPlugin {\t\n    parameters: any = {};\n    pluginName = \"default\";\n    public defaultRenderTemplate: string = \"default\";\n\n    public static languageVersion = 1;\n\n    public getVersion(): number {\n        return DefaultFormatImportPlugin.languageVersion;\n    }\n\n    public async importData(contents : ContentItem[], param?: any): Promise<ImportResult> {\n        const contentItems: ContentItem[] = contents;\n\n        let parseSceneResult: ImportResult = parseScenes.call(this, contentItems, param.ignoreSyntaxError);\n\n        if (param) {\n            this.parameters = JSON.parse(JSON.stringify(param));\n        }\n        \n        return parseSceneResult;\n    }\n\n    // Loop through all update commands and apply them, then return resulting content.\n    public applyCommands(originalContents : string, updateCommandList : UpdateCommand[]) {\n\n        let returnValues = {};\n        let newContents = originalContents;\n\n        for(let command of updateCommandList) {\n            newContents = command.apply(newContents, returnValues);\n        }\n        \n        return { content: newContents, returnValues: returnValues };\n    }\n}\n\nfunction updateSceneProperty(scenePropertyName : string, newValues : any) {\n    let updatedContentText = \"\";\n    switch (scenePropertyName) {\n        case \"say\": \n        case \"recap\": \n        case \"reprompt\": {\n                // Don't put anything if not set, this will essentially clear things\n            if(newValues.params[scenePropertyName] && newValues.params[scenePropertyName].length > 0) {\n\n                updatedContentText += \"\\t*\" + scenePropertyName + \"\\n\\t\\t\";\n\n                for(let i = 0; i < newValues.params[scenePropertyName].length; i++) {\n                    updatedContentText += newValues.params[scenePropertyName][i] + \"\\n\";\n\n                    if(i < newValues.params[scenePropertyName].length - 1) {\n                        updatedContentText += \"||\\n\";\n                    }\n                }\n            }\n            \n            break;\n        }\n        default: {\n            updatedContentText += \"\\t*\" + scenePropertyName + \"\\n\\t\\t\" + newValues.params[scenePropertyName] + \"\\n\";\n            break;\n        }\n    }\n    return updatedContentText;\n}\n\nfunction parseContentAndReplace(contentText : string, newValues : any) {\n    const CONTENT_PARSE_REGEX: RegExp = /([\\s]*\\*[\\s]*)([^\\n]*?)\\n([\\s\\S]+?)(?=\\n[\\s]*\\*|$)/gi;\n\n    var updatedContentText = \"\";\n    var contentMatch = CONTENT_PARSE_REGEX.exec(contentText);\n    //console.log(\"Matching content: \" + JSON.stringify(contentMatch, null, 2));\n    var originalSource = contentText;\n    var parsedNodes = [];\n    var prompts = \"\";\n    var reprompts = \"\";\n    var visualInstruction = undefined;\n    let foundSceneProperties : any = {};\n\n    updatedContentText += \"@\" + newValues.sceneId + \"\\n\";\n\n    while (contentMatch != null) {\n        var scenePropertyName = contentMatch[2].trim();\n        var contentValue = contentMatch[3].trim();\n\n        foundSceneProperties[scenePropertyName] = 1;\n\n        if(scenePropertyName in newValues.params) {\n            updatedContentText += updateSceneProperty(scenePropertyName, newValues);\n        } else {\n            updatedContentText += \"\\t*\" + scenePropertyName + \"\\n\\t\\t\" + contentValue + \"\\n\";\n        }\n\n        contentMatch = CONTENT_PARSE_REGEX.exec(contentText);\n    }\n\n    // Add items that weren't already in the scene already\n    for (let key of Object.keys(newValues.params)) {\n        if(!(key in foundSceneProperties) && newValues.params[key] && newValues.params[key].length > 0) {\n            updatedContentText += updateSceneProperty(key, newValues) + \"\\n\";    \n        }\n    }\n\n    return updatedContentText;\n}\n\nfunction updateThenWithHear(contentText : string, original : HearActionMetadata, newHear : string, gotoId : string, action : string) {\n    \n    let newContent = \"\";\n\n    newContent += \"\\t*then\\n\\t\\t\";\n\n    let replacedHear = false;\n    let deletedHear = false;\n\n    // Holds in process hear sections\n    let hearSectionLines : string[] = [];\n    let pullOutCurrentHearSection = false;\n    let currentHearSectionContainsMatchingGoto = false;\n\n    for (let line of contentText.split('\\n')) {\n\n        let trimmedline: string = line.trim();\n\n        if(pullOutCurrentHearSection) {\n            hearSectionLines.push(line);\n\n            // Check processing hear section to see if it contains a goto target we are looking for\n            if(original.goto && (trimmedline === (\"-> \" + original.goto) || trimmedline === (\"<-> \" + original.goto))) {\n                currentHearSectionContainsMatchingGoto = true;\n            }\n\n            // Only handles single nesting of \"}\" signs\n            if(trimmedline === (\"}\")) {\n\n                let deletingHear = false;\n                // Check to see if this was a hear section we wanted\n                // If no goto set, or if goto matched existing then we are ready to modify this hear section\n                if(!original.goto || currentHearSectionContainsMatchingGoto) {\n\n                    // Process the pulled out hear section\n                    if(!newHear) {\n                        deletingHear = true;                \n                        deletedHear = true;\n                    } else {\n                        hearSectionLines[0] = \"\\t\\thear \" + newHear + \" {\";        \n                        replacedHear = true;\n                    }\n\n                    hearSectionLines = hearSectionLines.map((innerLine) => {\n                        const innerLineTrimmed = innerLine.trim();\n\n                        if((!original.goto && (innerLineTrimmed.startsWith(\"->\") \n                                               || innerLineTrimmed.startsWith(\"<->\"))) \n                            ||\n                            (original.goto && (innerLineTrimmed === (\"-> \" + original.goto) \n                                               || innerLineTrimmed === (\"<-> \" + original.goto)))\n                            ) {\n                            return \"\\t\\t\\t\" + getFormattedStringForAction(action, gotoId); \n                        }\n\n                        // Else return the line as is\n                        return innerLine;\n                    });\n                }\n\n                if(!deletingHear) {\n                    // Now add this entire hear section as you normally would\n                    hearSectionLines.forEach((line) => { newContent += line + \"\\n\"});\n                }\n    \n                // Now break out of this inner conditional looping if\n                pullOutCurrentHearSection = false;\n            }\n            continue;\n        }\n\n        // TODO: Make into regex\n        if(trimmedline === `hear ${original.hear} {`) {\n            hearSectionLines = [];\n            hearSectionLines.push(line);\n            pullOutCurrentHearSection = true;\n            currentHearSectionContainsMatchingGoto = false;\n        } else {\n            newContent += line + \"\\n\";\n        }\n    };\n\n    if(!deletedHear && !replacedHear) {\n        newContent += \"\\t\\thear \" + newHear + \" {\\n\";\n        newContent += \"\\t\\t\\t\" + getFormattedStringForAction(action, gotoId) + \"\\n\";\n        newContent += \"\\t\\t}\\n\";\n    }\n\n    return newContent;\n}\n\nfunction getFormattedStringForAction(action : string, gotoId : string) {\n\n    let val = \"\";\n\n    if(action === InstructionType.SAVE_AND_GO) {\n        val += \"<-> \" + gotoId;\n    } else if(action === InstructionType.GO_TO) {\n        val += \"-> \" + gotoId;\n    } else if(action === InstructionType.RESTART) {\n        val += \">> RESTART\";\n    } else if(action === InstructionType.PAUSE) {\n        val += \">> PAUSE\";\n    } else if(action === InstructionType.RESUME) {\n        val += \">> RESUME\";\n    } else if(action === InstructionType.REPEAT) {\n        val += \">> REPEAT\";\n    } else if(action === InstructionType.REPROMPT) {\n        val += \">> REPROMPT\";\n    } else if(action === InstructionType.BACK) {\n        val += \">> BACK\";\n    } else if(action === InstructionType.END) {\n        val += \">> END\";\n    } else if(action === InstructionType.RETURN) {\n        val += \">> RETURN\";\n    }\n\n    return val;\n}\n\nfunction updateThenWithGoto(contentText : string, originalGoto : string, gotoId : string, action : string) {\n    \n    let newContent = \"\";\n\n    newContent += \"\\t*then\\n\\t\\t\";\n\n    let replacedGoto = false;\n\n    for (let line of contentText.split('\\n')) {\n\n        let trimmedline: string = line.trim();\n\n        // TODO: Check to see if we are in any nested hear { } signs and don't change those goto commands\n\n        // TODO: Make into regex\n        if(trimmedline === (\"-> \" + originalGoto) || trimmedline === (\"<-> \" + originalGoto)) {\n\n            if(!gotoId) {\n                // Don't append the line, we are deleting this goto\n            } else {\n\n                let firstPartSpacing = \"\";\n                if(trimmedline === (\"-> \" + originalGoto)) {\n                    firstPartSpacing = line.split(\"->\")[0];\n                } else if(trimmedline === (\"<-> \" + originalGoto)) {\n                    firstPartSpacing = line.split(\"<->\")[0];\n                }\n\n                // Then this is the one we should update\n                newContent += firstPartSpacing + getFormattedStringForAction(action, gotoId) + \"\\n\";\n                replacedGoto = true;\n            }\n        } else {\n            newContent += line + \"\\n\";\n        }\n    };\n\n    if(!replacedGoto) {\n        newContent += \"\\t\\t\" + getFormattedStringForAction(action, gotoId) + \"\\n\";\n    }\n\n    return newContent;\n}\n\ninterface HearActionMetadata {\n    hear: string;\n    goto: string;\n    action: string;\n}\n\nfunction updateHear(contentText : string, sceneId : string, original : HearActionMetadata, newHear : string, gotoId : string, action : string) {\n    const CONTENT_PARSE_REGEX: RegExp = /([\\s]*\\*[\\s]*)([^\\n]*?)\\n([\\s\\S]+?)(?=\\n[\\s]*\\*|$)/gi;\n\n    var updatedContentText = \"\";\n    var contentMatch = CONTENT_PARSE_REGEX.exec(contentText);\n    //console.log(\"Matching content: \" + JSON.stringify(contentMatch, null, 2));\n    var originalSource = contentText;\n    var parsedNodes = [];\n    var prompts = \"\";\n    var reprompts = \"\";\n    var visualInstruction = undefined;\n    let foundSceneProperties : any = {};\n\n    updatedContentText += \"@\" + sceneId + \"\\n\";\n\n    while (contentMatch != null) {\n        var scenePropertyName = contentMatch[2].trim();\n        var contentValue = contentMatch[3].trim();\n\n        foundSceneProperties[scenePropertyName] = 1;\n\n        if(scenePropertyName === \"then\") {\n            updatedContentText += updateThenWithHear(contentValue, original, newHear, gotoId, action);\n        } else {\n            updatedContentText += \"\\t*\" + scenePropertyName + \"\\n\\t\\t\" + contentValue + \"\\n\";\n        }\n\n        contentMatch = CONTENT_PARSE_REGEX.exec(contentText);\n    }\n\n    if(!foundSceneProperties[\"then\"] && newHear) {\n        updatedContentText += \"\\t*then\\n\\t\\thear \" + newHear + \" {\\n\\t\\t\\t\" + getFormattedStringForAction(action, gotoId) + \"\\n\\t\\t}\\n\\n\";\n    }\n\n    return updatedContentText;\n}\n\nfunction updateGoto(contentText : string, sceneId : string, originalGoto : string, gotoId : string, action : string) {\n    const CONTENT_PARSE_REGEX: RegExp = /([\\s]*\\*[\\s]*)([^\\n]*?)\\n([\\s\\S]+?)(?=\\n[\\s]*\\*|$)/gi;\n\n    var updatedContentText = \"\";\n    var contentMatch = CONTENT_PARSE_REGEX.exec(contentText);\n    //console.log(\"Matching content: \" + JSON.stringify(contentMatch, null, 2));\n    var originalSource = contentText;\n    var parsedNodes = [];\n    var prompts = \"\";\n    var reprompts = \"\";\n    var visualInstruction = undefined;\n    let foundSceneProperties : any = {};\n\n    updatedContentText += \"@\" + sceneId + \"\\n\";\n\n    while (contentMatch != null) {\n        var scenePropertyName = contentMatch[2].trim();\n        var contentValue = contentMatch[3].trim();\n\n        foundSceneProperties[scenePropertyName] = 1;\n\n        if(scenePropertyName === \"then\") {\n            updatedContentText += updateThenWithGoto(contentValue, originalGoto, gotoId, action);\n        } else {\n            updatedContentText += \"\\t*\" + scenePropertyName + \"\\n\\t\\t\" + contentValue + \"\\n\";\n        }\n\n        contentMatch = CONTENT_PARSE_REGEX.exec(contentText);\n    }\n\n    if(!foundSceneProperties[\"then\"] && gotoId) {\n        updatedContentText += \"\\t*then\\n\\t\" + getFormattedStringForAction(action, gotoId) + \"\\n\\n\";\n    }\n\n    return updatedContentText;\n}\n\nfunction removeReferencesFromThen(contentText : string, sceneIdToRemove : string) {\n    \n    let newContent = \"\";\n\n    newContent += \"\\t*then\\n\\t\\t\";\n\n    let replacedHear = false;\n    let replaceNextGoto = false;\n\n    let insideHereMutex = 0;\n\n    let insideHearContent = \"\";\n    let containedSceneIdToRemove = false;\n\n    for (let line of contentText.split('\\n')) {\n\n        let trimmedline: string = line.trim();\n\n        if(trimmedline.startsWith(\"hear\")) {\n\n            insideHereMutex++;\n\n            // Then this is the one we should update\n            insideHearContent += line + \"\\n\";\n\n            // TODO: Need to count other \"{\" signs found and increment the mutex\n\n        } else if(trimmedline === (\"}\")) {\n\n                if(insideHereMutex > 0) {\n                    insideHereMutex--;\n                }\n                \n                // Then this is the one we should update\n                insideHearContent += line + \"\\n\";\n\n                if(insideHereMutex == 0) {\n                    // Actually, don't append anything if this contained the goto we were looking for\n                    if(containedSceneIdToRemove) {\n\n                    } else {\n                        // Otherwise, append this good hear to the content\n                        newContent += insideHearContent;\n                    }\n                    insideHearContent = \"\";\n                    containedSceneIdToRemove = false;\n                }\n    \n        } else if (trimmedline === (\"-> \" + sceneIdToRemove) ||\n                   trimmedline === (\"<-> \" + sceneIdToRemove)){\n            if(insideHereMutex > 0) {\n                containedSceneIdToRemove = true;\n            }\n\n            // Otherwise, this may have been a global -> that wasn't in a hear, so don't output it here either.\n\n        } else {\n            if(insideHereMutex > 0) {\n                insideHearContent += line + \"\\n\";\n            } else {\n                newContent += line + \"\\n\";\n            }\n        }\n    };\n\n    return newContent;\n}\n\nfunction updateReferencesFromThen(contentText : string, originalSceneIdRef : string, newSceneIdRef : string) {\n    \n    let newContent = \"\";\n\n    newContent += \"\\t*then\\n\\t\\t\";\n\n    for (let line of contentText.split('\\n')) {\n\n        let trimmedline: string = line.trim();\n\n        if (trimmedline === (\"-> \" + originalSceneIdRef)){\n            // Trying to preserve original indentation\n            newContent += line.split(\"->\")[0] + \"-> \" + newSceneIdRef + \"\\n\";\n        } else if (trimmedline === (\"<-> \" + originalSceneIdRef)){\n            // Trying to preserve original indentation\n            newContent += line.split(\"<->\")[0] + \"<-> \" + newSceneIdRef + \"\\n\";\n        } else {\n            newContent += line + \"\\n\";\n        }\n    };\n\n    return newContent;\n}\n\nfunction updateReferencesFromScene(contentText : string, sceneId : string, originalSceneIdRef : string, newSceneIdRef: string) {\n    const CONTENT_PARSE_REGEX: RegExp = /([\\s]*\\*[\\s]*)([^\\n]*?)\\n([\\s\\S]+?)(?=\\n[\\s]*\\*|$)/gi;\n\n    var updatedContentText = \"\";\n    var contentMatch = CONTENT_PARSE_REGEX.exec(contentText);\n    //console.log(\"Matching content: \" + JSON.stringify(contentMatch, null, 2));\n    var originalSource = contentText;\n    var parsedNodes = [];\n    var prompts = \"\";\n    var reprompts = \"\";\n    var visualInstruction = undefined;\n    let foundSceneProperties : any = {};\n\n    updatedContentText += \"@\" + sceneId + \"\\n\";\n\n    while (contentMatch != null) {\n        var scenePropertyName = contentMatch[2].trim();\n        var contentValue = contentMatch[3].trim();\n\n        foundSceneProperties[scenePropertyName] = 1;\n\n        if(scenePropertyName === \"then\") {\n            updatedContentText += updateReferencesFromThen(contentValue, originalSceneIdRef, newSceneIdRef);\n        } else {\n            updatedContentText += \"\\t*\" + scenePropertyName + \"\\n\\t\\t\" + contentValue + \"\\n\";\n        }\n\n        contentMatch = CONTENT_PARSE_REGEX.exec(contentText);\n    }\n\n    updatedContentText += \"\\n\";\n\n    return updatedContentText;\n}\n\nfunction removeReferencesFromScene(contentText : string, sceneId : string, sceneIdToRemove : string) {\n    const CONTENT_PARSE_REGEX: RegExp = /([\\s]*\\*[\\s]*)([^\\n]*?)\\n([\\s\\S]+?)(?=\\n[\\s]*\\*|$)/gi;\n\n    var updatedContentText = \"\";\n    var contentMatch = CONTENT_PARSE_REGEX.exec(contentText);\n    //console.log(\"Matching content: \" + JSON.stringify(contentMatch, null, 2));\n    var originalSource = contentText;\n    var parsedNodes = [];\n    var prompts = \"\";\n    var reprompts = \"\";\n    var visualInstruction = undefined;\n    let foundSceneProperties : any = {};\n\n    updatedContentText += \"@\" + sceneId + \"\\n\";\n\n    while (contentMatch != null) {\n        var scenePropertyName = contentMatch[2].trim();\n        var contentValue = contentMatch[3].trim();\n\n        foundSceneProperties[scenePropertyName] = 1;\n\n        if(scenePropertyName === \"then\") {\n            updatedContentText += removeReferencesFromThen(contentValue, sceneIdToRemove);\n        } else {\n            updatedContentText += \"\\t*\" + scenePropertyName + \"\\n\\t\\t\" + contentValue + \"\\n\";\n        }\n\n        contentMatch = CONTENT_PARSE_REGEX.exec(contentText);\n    }\n\n    updatedContentText += \"\\n\";\n\n    return updatedContentText;\n}\n\nfunction parseScenesForReplacement(text : string, sceneId : string | undefined, updatedScene : any, applyFunc? : any) {\n    let newText = \"\";\n\n    let sceneParseRegex: RegExp = /(?:(?:\\n[ \\t]*?)|^)\\@[\\s]*([^\\n]*?)\\n([\\s\\S]+?)(?=\\n[\\s]*\\@|$)/gi;\n    var sceneMatch = sceneParseRegex.exec(text);\n    while (sceneMatch != null) {\n        var sceneID = sceneMatch[1].trim();\n        var sceneContent = sceneMatch[2].trim();\n\n            if(!sceneId && applyFunc) {\n                newText += applyFunc(sceneContent, sceneID);\n            } else if(sceneId === sceneID) {\n\n                if(applyFunc) {\n                    //console.log(\"Found scene to update with an apply function\");\n                    newText += applyFunc(sceneContent, sceneID);        \n                } else {\n                    //console.log(\"Found scene to update\");\n                    newText += parseContentAndReplace(sceneContent, updatedScene);        \n                }\n\n            } else {\n                newText += \"@\" + sceneID + \"\\n\\t\" + sceneContent + \"\\n\\n\";\n            }\n        sceneMatch = sceneParseRegex.exec(text);\n    }\n    return newText;\n}\n\nexport class UpdateCommand {\t\n    sceneId = \"\";\n\n    constructor(params : any) {\n        this.sceneId = params.sceneId;\n    }\n\n    // Desired new scene id, ok if blank, will inherit from parent\n    public setSceneId(sceneId : string) {\n        this.sceneId = sceneId;\n    }\n    \n    // Actually apply this content to the original content\n    apply(originalContent: string, returnValues: any) : string {\n        return originalContent;\n    }\n}\n\nfunction getSceneNames(originalContent : string) {\n\n    let sceneMap : any = {};\n\n    let sceneParseRegex: RegExp = /(?:(?:\\n[ \\t]*?)|^)\\@[\\s]*([^\\n]*?)\\n([\\s\\S]+?)(?=\\n[\\s]*\\@|$)/gi;\n    var sceneMatch = sceneParseRegex.exec(originalContent);\n    while (sceneMatch != null) {\n        var sceneID = sceneMatch[1].trim();\n\n        sceneMap[sceneID] = 1;\n\n        sceneMatch = sceneParseRegex.exec(originalContent);\n    }\n\n    return sceneMap;\n}\n\nfunction generateNextSceneId(originalContent : string, parentSceneId : string) {\n\n    let newSceneId = \"\";\n\n    let sceneMap : any = getSceneNames(originalContent);\n\n    // Trim the parent scene id at the first _\n    if(parentSceneId) {\n        parentSceneId = parentSceneId.split(\"_\")[0];\n    }\n\n    let count = 1;\n    newSceneId = parentSceneId + \"_\" + count;\n    while(sceneMap[newSceneId]) {\n        count++;\n        newSceneId = parentSceneId + \"_\" + count;\n    }\n\n    return newSceneId;\n}\n\nexport class NewNodeCommand extends UpdateCommand {\n\n    parentSceneId = \"\";\n    say = \"\";\n    reprompt = \"\";\n    then = \"\";\n    show = \"\";\n\n    constructor(params : any) {\n        super(params);\n        this.parentSceneId = params.parentSceneId;\n    }\n\n    // Parent scene id\n    public setParentSceneId(parentSceneId : string) {\n        this.parentSceneId = parentSceneId;\n    }\n\n    public setSay(say : string) {\n        this.say = say;\n    }\n\n    public setReprompt(reprompt : string) {\n        this.reprompt = reprompt;\n    }\n\n    public setThen(then : string) {\n        this.then = then;\n    }\n\n    public setShow(show : string) {\n        this.show = show;\n    }\n\n    public apply(originalContent : string, returnValues : any) : string {\n\n        if(!this.sceneId) {\n            this.sceneId = generateNextSceneId(originalContent, this.parentSceneId);            \n        }\n\n        returnValues.newSceneId = this.sceneId;\n\n        let newContent = originalContent;\n\n        newContent += \"\\n@\" + this.sceneId + \"\\n\";\n\n        if(this.say) {\n            newContent += \"\\t*say\\n\\t\\t\" + this.say + \"\\n\\n\";\n        } else {\n            newContent += \"\\t*say\\n\\t\\t\" + \"Put say text here\" + \"\\n\\n\";\n        }\n\n        if(this.reprompt) {\n            newContent += \"\\t*reprompt\\n\\t\\t\" + this.reprompt + \"\\n\\n\";\n        }\n\n        if(this.show) {\n            newContent += \"\\t*show\\n\\t\\t\" + this.show + \"\\n\\n\";\n        }\n\n        if(this.then) {\n            newContent += \"\\t*then\\n\\t\\t\" + this.then + \"\\n\\n\";\n        }\n        newContent += \"\\n\";\n\n        return newContent;\n    }\n}\n\nexport class DeleteNodeCommand extends UpdateCommand {\n\n    constructor(params : any) {\n        super(params);\n    }\n\n    public apply(originalContent : string, returnValues : any) : string {\n\n        // Use a \"\" applyFunction to delete this scene\n        let newContents = parseScenesForReplacement(originalContent, this.sceneId, {}, \n            () => {return \"\";});\n\n        return newContents;\n    }\n}\n\nexport class RemoveReferencesToNodeCommand extends UpdateCommand {\n\n    constructor(params : any) {\n        super(params);\n\n        this.applyFunc = this.applyFunc.bind(this);\n    }\n\n    applyFunc(originalContents : string, sceneId : string) {\n\n        let newContents = removeReferencesFromScene(originalContents, sceneId, this.sceneId);\n\n        return newContents;\n    }\n\n    public apply(originalContent : string, returnValues : any) : string {\n\n        // Remove any hear or goto lines that go to the given scene id, at least in this file that is being updated.\n\n        // TODO: Multi-file support, not V1.\n\n        let newContents = parseScenesForReplacement(originalContent, undefined, {}, this.applyFunc);\n\n\n        return newContents;\n    }\n}\n\nexport class UpdateSayCommand extends UpdateCommand {\n\n    sayList : string[] = [];\n\n    constructor(params : any) {\n        super(params);\n    }\n\n    public setSay(say : string) {\n        this.sayList = [say];\n    }\n\n    public setSayList(sayList : string[]) {\n        this.sayList = sayList;\n    }\n\n    public apply(originalContent : string, returnValues : any) : string {\n\n        let newContents = parseScenesForReplacement(originalContent, this.sceneId, {sceneId: this.sceneId, params: {say: this.sayList}});\n\n        return newContents;\n    }\n}\n\nexport class UpdateRecapCommand extends UpdateCommand {\n\n    recapList : string[] = [];\n\n    constructor(params : any) {\n        super(params);\n    }\n\n    public setRecap(recap : string) {\n        this.recapList = [recap];\n    }\n\n    public setRecapList(recapList : string[]) {\n        this.recapList = recapList;\n    }\n\n    public apply(originalContent : string, returnValues : any) : string {\n\n        let newContents = parseScenesForReplacement(originalContent, this.sceneId, {sceneId: this.sceneId, params: {recap: this.recapList}});\n\n        return newContents;\n    }\n}\n\nexport class UpdateRepromptCommand extends UpdateCommand {\n\n    repromptList : string[] = [];\n\n    constructor(params : any) {\n        super(params);\n    }\n\n    public setReprompt(reprompt : string) {\n        this.repromptList = [reprompt];\n    }\n\n    public setRepromptList(repromptList : string[]) {\n        this.repromptList = repromptList;\n    }\n\n    public apply(originalContent : string, returnValues : any) : string {\n\n        let newContents = parseScenesForReplacement(originalContent, this.sceneId, {sceneId: this.sceneId, params: {reprompt: this.repromptList}});\n\n        return newContents;\n    }\n}\n\nexport class RenameNodeCommand extends UpdateCommand {\n\n    originalSceneId : string = \"\";\n\n    constructor(params : any) {\n        super(params);\n\n        this.originalSceneId = params.originalSceneId;\n    }\n\n    public apply(originalContent : string, returnValues : any) : string {\n\n        // Just rename the scene id, don't change any other contents\n        let newContents = parseScenesForReplacement(originalContent, this.originalSceneId, {sceneId: this.sceneId, params: {}});\n\n        return newContents;\n    }\n}\n\nexport class UpdateReferencesToNodeCommand extends UpdateCommand {\n\n    originalSceneId : string = \"\";\n\n    constructor(params : any) {\n        super(params);\n\n        this.applyFunc = this.applyFunc.bind(this);\n        this.originalSceneId = params.originalSceneId;\n    }\n\n    public setOriginalSceneId(originalSceneId : string) {\n        this.originalSceneId = originalSceneId;\n    }\n\n    applyFunc(originalContents : string, sceneId : string) {\n\n        let newContents = updateReferencesFromScene(originalContents, sceneId, this.originalSceneId, this.sceneId);\n\n        return newContents;\n    }\n\n    public apply(originalContent : string, returnValues : any) : string {\n\n        // Update any hear or goto lines that go to the given scene id and send them to the new scene id.\n\n        // TODO: Multi-file support, not V1.\n\n        let newContents = parseScenesForReplacement(originalContent, undefined, {}, this.applyFunc);\n\n\n        return newContents;\n    }\n}\n\n// If no original hear set, then add a new hear. If no hear specified, then delete this hear.\nexport class UpdateHearCommand extends UpdateCommand {\n\n    original : HearActionMetadata = { hear: \"\", goto: \"\", action: \"\"};\n    hear : string = \"\";\n    goto : string = \"\";\n    action : string = \"\";\n\n    constructor(params : any) {\n        super(params);\n        this.original.hear = params.originalHear;\n        this.original.goto = params.originalGoto;\n        this.original.action = params.originalAction;\n        this.hear = params.hear;\n        this.goto = params.goto;\n        this.action = params.action;\n\n        this.applyFunc = this.applyFunc.bind(this);\n    }\n\n    applyFunc(originalContents : string, sceneId : string) {\n        let newContents = originalContents;\n\n        newContents = updateHear(newContents, sceneId, this.original, this.hear, this.goto, this.action);\n\n        return newContents;\n    }\n\n    public apply(originalContent : string, returnValues : any) : string {\n\n        let newContents = parseScenesForReplacement(originalContent, this.sceneId, {}, this.applyFunc);\n\n        return newContents;\n    }\n}\n\nexport class UpdateGotoCommand extends UpdateCommand {\n\n    originalGoto : string = \"\";\n    goto : string = \"\";\n    action : string = \"\";\n\n    constructor(params : any) {\n        super(params);\n        this.originalGoto = params.originalGoto;\n        this.goto = params.goto;\n        this.action = params.action;\n\n        this.applyFunc = this.applyFunc.bind(this);\n    }\n\n    applyFunc(originalContents : string, sceneId : string) {\n        let newContents = originalContents;\n\n        newContents = updateGoto(newContents, sceneId, this.originalGoto, this.goto, this.action);\n\n        return newContents;\n    }\n\n    public apply(originalContent : string, returnValues : any) : string {\n\n        let newContents = parseScenesForReplacement(originalContent, this.sceneId, {}, this.applyFunc);\n\n        return newContents;\n    }\n}\n\nfunction parseScenes(this: any, contents: ContentItem[], ignoreSyntaxError: boolean = false): ImportResult {\n    let errors: ImportErrorLine[] = [];\n\n    let sceneIDs: {[key:string]: string} = {};\n\n    for (let content of contents) {\n        let lineNumber = 0;\n        for (let line of content.text.split(\"\\n\")) {\n            lineNumber++;\n            let sceneNameGrabber: RegExp = /^\\s*\\@\\s*([^@]*)/gi;\n            let match = sceneNameGrabber.exec(line);\n            if (match != null && match.length > 1) {\n                let sceneID: string = match[1].trim().toLowerCase();\n    \n                if (sceneIDs[sceneID]) {\n                    const errorResultItem: ImportErrorLine = {\n                        lineNumber: lineNumber,\n                        errorName: \"Duplicate Scene ID\",\n                        errorMessage: `Scene ID '${sceneID}' has already been used in ${sceneIDs[sceneID]}.`,\n                        sourceID: content.id\n                    }\n                    errors.push(errorResultItem);\n                } else {\n                    sceneIDs[sceneID] = content.id || \"none\";\n                }\n            }\n\n            const bookmarkGrabber = /^[\\s]*?bookmark[\\s]+?([\\S\\s]+?)$/gi;\n            const bookmarkMatch = bookmarkGrabber.exec(line);\n            if (bookmarkMatch != null && bookmarkMatch.length > 1) {\n                let bookmarkName: string = bookmarkMatch[1].trim();\n    \n                sceneIDs[bookmarkName] = content.id || \"none\";\n            }\n        }\n    }\n    \n    let result: Scene[] = [];\n\n    for (let content of contents) {\n        let text:string = content.text.replace(/\\r\\n/g, \" \\n\").replace(/\\r/g, \"\\n\");\n\n        let sceneParseRegex: RegExp = /(?:(?:\\n[ \\t]*?)|^)\\@[\\s]*([^\\n]*?)\\n([\\s\\S]+?)(?=\\n[\\s]*\\@|$)/gi;\n        let sceneMatch: any = sceneParseRegex.exec(text);\n\n        while (sceneMatch != null) {\n            let sceneID: string = sceneMatch[1].replace(/^[ \\t]*?\\/\\/[\\s\\S]*?$/gm, \"\").trim();\n            let sceneContent: string = sceneMatch[2].replace(/^[ \\t]*?\\/\\/[\\s\\S]*?$/gm, \"\");\n        \n            try {\n                let variations: SceneVariation[] = parseContent.call(this, sceneID, sceneContent, sceneIDs, ignoreSyntaxError);\n                let locationIndex: number = sceneMatch.index;\n\n                while(text.charAt(locationIndex) != \"@\") {\n                    locationIndex ++;\n                }\n\n                const currentScene: Scene = {\n                    contents: variations,\n                    id: sceneID,\n                    customProperties: {\n                        sourceLocation: locationIndex\n                    }\n                }\n        \n                if (content.id && currentScene.customProperties) {\n                    currentScene.customProperties.sourceID = content.id;\n                }\n\n                result.push(currentScene);    \n    \n            } catch (err) {\n                const currentScene: Scene = {\n                    contents: [],\n                    id: sceneID\n                }\n                result.push(currentScene);    \n\n                let sceneContentLine: number = 1;\n                for (let i = 0; i <= sceneMatch.index; i++) {\n                    if (text[i] == \"\\n\") {\n                        sceneContentLine ++;\n                    }\n                }\n    \n                for (let errorItem of err) {\n\n                    let errorResultItem: any = {\n                        lineNumber: errorItem.line + sceneContentLine,\n                        errorName: \"Syntax Error\",\n                        errorMessage: errorItem.reason,\n                    }\n\n                    if (content.id) {\n                        errorResultItem.sourceID = content.id;\n                    }\n\n                    errors.push(errorResultItem);\n                }\n            }\n    \n            sceneMatch = sceneParseRegex.exec(text);\n        }\n    }\n\n    return {\n        importedScenes: result,\n        errors: errors\n    };\n}\n\nfunction parseContent(this: any, originSceneID: string, contentText: string, availableSceneIDs: {[key:string]: string}, ignoreSyntaxError: boolean): SceneVariation[] {\n    const CONTENT_PARSE_REGEX: RegExp = /([ \\t]*\\*[ \\t]*)([^\\n]*?)\\n([\\s\\S]+?)(?=\\n[\\s]*\\*|$)/g;\n\n    let contentMatch: any = CONTENT_PARSE_REGEX.exec(contentText);\n    let prompts: string = \"\";\n    let recapPrompts: string = \"\";\n    let reprompts: string = \"\";\n    let visualInstruction: any = undefined;\n    let sceneDirections: Instruction[] = [];\n\n    while (contentMatch != null) {\n        let scenePropertyName: string = contentMatch[2];\n        let contentValue: string = contentMatch[3];\n    \n        switch(scenePropertyName.trim()) {\n        case \"say\": {\n            prompts += contentValue.trim();\n            break;\n        }\n        case \"reprompt\": {\n            reprompts += contentValue.trim();\n            break;\n        }\n        case \"recap\": {\n            recapPrompts += contentValue.trim();                \n            break;\n        }\n        case \"show\": {\n            let visualOptions: VisualOptions = {template: this.defaultRenderTemplate};\n            for (let showItem of contentValue.trim().split(\"\\n\")) {\n                let keyValueRegex: RegExp = /^([^:]+?):[\\s]*['\"]?([\\s\\S]*?)['\"]?[\\s]*?$/g\n                let keyValuPair: any = keyValueRegex.exec(showItem);\n                if (keyValuPair != null && keyValuPair.length == 3) {\n                    visualOptions[keyValuPair[1].trim()] = keyValuPair[2].trim();\n                } else {\n                    // Else look for commands to execute\n                    const command = showItem;\n                    if(command) {\n                        const trimmedCommand = command.trim();\n\n                        if(trimmedCommand) {\n                            if(!visualOptions.commands) {\n                                visualOptions.commands = [];\n                            }\n                            visualOptions.commands.push(trimmedCommand);\n                        }\n                    }\n                }\n            }\n\n            visualInstruction = new InstructionBuilder().setVisuals(visualOptions).build();    \n            break;\n        }\n        case \"then\":\n        case \"do\" : {\n            try {\n                let parsedDirections: Instruction[] = parseInstructions.call(this, contentValue.replace(/\\r/g, '').replace(/[\\u200B-\\u200D\\uFEFF]/g, \" \"), availableSceneIDs, ignoreSyntaxError);\n                sceneDirections = sceneDirections.concat(parsedDirections);\n            } catch (err) {\n                let errors: any[] = [];\n                let propertyErrorLine: number = 1;\n\n                for (let i = 0; i <= contentMatch.index; i++) {\n                    if (contentText[i] == \"\\n\") {\n                        propertyErrorLine ++;\n                    }\n                }\n\n                for (let errorItem of err) {\n                    errors.push({\n                        line: errorItem.line + propertyErrorLine,\n                        content: errorItem.content,\n                        reason: errorItem.reason\n                    });\n                }\n\n                throw errors;\n            }\n            break;\n        }\n        }\n\n        contentMatch = CONTENT_PARSE_REGEX.exec(contentText);\n    }\n\n    if (sceneDirections.length === 0 &&  ![\"global\", \"global prepend\", \"global postpend\", \"global append\", \"resume\", \"pause\"].includes(originSceneID.trim().toLowerCase())) {\n        sceneDirections = sceneDirections.concat(parseInstructions.call(this, \">> end\", availableSceneIDs, ignoreSyntaxError));\n    }\n\n    if(visualInstruction) {\n        sceneDirections = visualInstruction.concat(sceneDirections || []);\n    }\n\n    let sceneVariations: SceneVariation[] = [];\n\n    let finalSceneInstructions: InstructionBuilder = new InstructionBuilder();\n\n    if (reprompts && reprompts.trim().length > 0) {\n        finalSceneInstructions.setReprompt(reprompts.trim());\n    }\n\n    if (recapPrompts && recapPrompts.trim().length > 0) {\n        finalSceneInstructions.setRecap(recapPrompts.trim());\n    }\n    let variation: SceneVariation = {\n        narration: prompts,\n        sceneDirections: finalSceneInstructions.build()\n            .concat(sceneDirections)\n    }\n\n    sceneVariations.push(variation);\n\n    return sceneVariations;\n}   \n\nfunction parseInstructions(this: any, sceneDirectionBody: string, availableSceneIDs: {[key:string]: string}, ignoreSyntaxError: boolean): Instruction[] {\n    let directionBuilder: InstructionBuilder = new InstructionBuilder();\n    let lineNumber: number = 0;\n    let errorLines: any[] = [];\n\n    const bracketStack: number[] = [];\n\n    for (let line of sceneDirectionBody.replace(/\\r/g, '').split('\\n')) {\n        lineNumber++;\n        let trimmedline: string = line.trim();\n\n        if (trimmedline.length <= 0 || trimmedline.startsWith(\"//\")) {\n            continue;\n        }\n\n        try {\n            interpretDirectionLine(trimmedline, directionBuilder, availableSceneIDs, ignoreSyntaxError, bracketStack, lineNumber);\n        } catch (err) {\n            errorLines.push({\n                line: lineNumber,\n                content: err.content,\n                reason: err.reason\n            });\n        }\n\n    };\n\n    if (bracketStack.length > 0) {\n        for (let openBracketLine of bracketStack) {\n            errorLines.push({\n                line: openBracketLine,\n                content: \"\",\n                reason: \"Missing '}'\"\n            });\n        }\n    }\n\n    if (errorLines.length > 0) {\n        throw errorLines;\n    } else {\n        return directionBuilder.build();\n    }\n}\n\nfunction interpretDirectionLine (directionLine: string, directionBuilder: InstructionBuilder, availableSceneIDs: {[key:string]: string}, ignoreSyntaxError: boolean, bracketStack: number[], lineNumber: number) {\n    let line: string = directionLine.trim();\n    let isSyntaxError: boolean = false;\n    let sytaxErrorRegex: RegExp | undefined = undefined;\n    let errorMessage: string = \"\";\n\n    let commandStringMatch: any = /^[ \\t]*?([\\S]+?)( |$)/g.exec(line);\n    let arrowStringMatch: any = /^[ \\t]*?(->)([ \\t]*?|$)/g.exec(line);\n    let savengoMatch: any = /^[ \\t]*?(<->)([ \\t]*?|$)/g.exec(line);\n    let terminatorMatch: any = /^[ \\t]*?>>[ \\t]*?([\\S]+?)( |$)/g.exec(line);\n    \n    if (arrowStringMatch != null) {\n        commandStringMatch = arrowStringMatch;\n    } else if (savengoMatch != null) {\n        commandStringMatch = savengoMatch;\n    } else if (terminatorMatch != null) {\n        commandStringMatch = terminatorMatch;\n    }\n\n    if (line.trim().length == 0) {\n    } else if (commandStringMatch == null) {\n        isSyntaxError = true;\n        errorMessage = `Unrecognized instruction format: ${line}`;\n    } else {\n        switch(commandStringMatch[1].trim().toLowerCase()) {\n        case \"hear\": {\n            let heardSyntax: RegExp = /hear[ \\t]+([\\s\\S]+?)(?=,[\\s]*$|\\.[\\s]*$|[\\s]*\\{$|[\\s]*$)/g;\n            let match = heardSyntax.exec(line);\n    \n            if (!line.match(/\\{[ \\t]*?$/)) {\n                isSyntaxError = true;\n                errorMessage = `Missing '{': hear block must start with 'hear [utterances] {'`;\n                \n                break;\n            } else if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = heardSyntax;\n                errorMessage = \"missing utterances for 'hear'\";\n            } else {\n                let scrubbedUtterances: string = \"\";\n                for (let utterance of match[1].split(\",\")) {\n                    if (utterance.trim().length == 0) {\n                        continue;\n                    }\n\n                    if (scrubbedUtterances.length > 0) {\n                        scrubbedUtterances += \",\";\n                    }\n    \n                    scrubbedUtterances += utterance.trim();\n                }\n        \n                directionBuilder.startChoice(scrubbedUtterances.split(\",\"));\n            }\n            break;\n        }\n        case \"if\": {\n            let conditionComponents: string = line.substr(2)\n                .replace(/\\bis less than or equal to\\b/gi, \"<=\")\n                .replace(/\\bis smaller than or equal to\\b/gi, \"<=\")\n        \n                .replace(/\\bis greater than or equal to\\b/gi, \">=\")\n                .replace(/\\bis larger than or equal to\\b/gi, \">=\")\n                .replace(/\\bis bigger than or equal to\\b/gi, \">=\")\n            \n                .replace(/\\bis larger than\\b/gi, \">\")\n                .replace(/\\bis greater than\\b/gi, \">\")\n                .replace(/\\bis bigger than\\b/gi, \">\")\n                .replace(/\\bis less than\\b/gi, \"<\")\n                .replace(/\\bis smaller than\\b/gi, \"<\")\n        \n                .replace(/\\band\\b/g, \"&&\")\n                .replace(/\\bor\\b/g, \"||\")\n                .replace(/\\bis\\b/g, \"==\")\n                .replace(/\\bnot\\b/g, \"!\")\n                .replace(/,$/g,\"\")\n                .replace(/[\\s]+/g, \" \");\n\n            if (!conditionComponents.match(/{[\\s]*?$/)) {\n                isSyntaxError = true;\n                errorMessage = `Missing '{': if block must start with 'if [utterances] {'`;\n\n                break;\n            }\n\n            conditionComponents = conditionComponents.replace(/{[\\s]*?$/g, \"\")\n            let conditionString: string = \"\";\n            \n            let findVariableRegex: RegExp = /(?:<|>|\\|\\||!=|>=|==|===|<=|&&|^)(?:[\\(\\)!\\s]*)(?:([\\d]+(?:.[\\d]+)?)|([a-zA-Z0-9\\_\\-\\.\\s]+?)|('[a-zA-Z0-9\\_\\-\\.\\s]+?')|\"([a-zA-Z0-9\\_\\-\\.\\s]+?)\")(?:[\\(\\)\\s]*)(?=<|>|\\|\\||>=|==|===|!=|<=|&&|,[\\s]*$|\\.[\\s]*$|$)/g;\n            \n            let conditionStringVerify: string = conditionComponents.trim().replace(findVariableRegex, \"\");\n    \n            if (conditionComponents.trim().length === 0) {\n                isSyntaxError = true;\n                errorMessage = `Your 'if' condition is empty.`;\n            } else if (conditionStringVerify.trim().length > 0) {\n                isSyntaxError = true;\n                errorMessage = `There is a problem with your condition. Erroring word(s): ${conditionStringVerify.trim()}`;\n            } else {\n                conditionString = conditionComponents.trim().replace(findVariableRegex, function(match: string, p1, p2, p3, p4): string {\n                    if (p2 && p2 != \"true\" && p2 != \"false\") {\n                        return match.replace(p2, `{${p2}}`);\n                    } else if (p4) {\n                        return `'${p4}'`;\n                    } else {\n                        return match;\n                    }\n                });\n            \n                directionBuilder.startCondition(conditionString);\n            } \n            break;       \n        }\n        case \"->\": {\n            let gotoSyntax: RegExp = /^[ \\t]*?->[ \\t]*'?([\\S\\s]+?)'?(?:[ \\t]+?\\*([\\S]+?))?(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/gim;\n            let match: string[] | null = gotoSyntax.exec(line);\n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = gotoSyntax;\n                errorMessage = `Expected \"-> [scene name]\", but the scene name was missing.`;\n            } else {\n                let targetName: string = match[1].trim().toLowerCase();\n                if(targetName != 'bookmark' && targetName.match(/{.*?}/g) == null && !availableSceneIDs[targetName] && !availableSceneIDs[match[1].trim()]) {\n                    isSyntaxError = true;\n                    sytaxErrorRegex = gotoSyntax;\n                    errorMessage = `Cannot find the scene name=[${match[1].trim()}] to go to.`;\n                } else {\n                    let gotoProperty: string = !match[2] || match[2].trim().toLowerCase() == \"say\" ?\n                    \"narration\": match[2].trim().toLowerCase();\n    \n                    directionBuilder.goTo(match[1].trim(), gotoProperty);\n                }\n            }\n            break;\n        }\n        case \"<->\": {\n            let saveNGoSyntax: RegExp = /^[ \\t]*?<->[ \\t]*([\\S\\s]+?)(?:[ \\t]+?\\*([\\S]+?))?(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/gim;\n            let match: string[] | null = saveNGoSyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = saveNGoSyntax;\n                errorMessage = `Expected \"<-> [scene name]\", but the scene name was missing.`;\n            } else {\n                let targetName: string = match[1].trim().toLocaleLowerCase();\n                if(targetName != 'bookmark' && targetName.match(/{.*?}/g) == null && !availableSceneIDs[targetName]) {\n                    isSyntaxError = true;\n                    sytaxErrorRegex = saveNGoSyntax;\n                    errorMessage = `Cannot find the scene name=[${match[1].trim()}] to go to.`;\n                } else {\n                    let gotoProperty: string = !match[2] || match[2].trim().toLowerCase() == \"say\" ?\n                    \"narration\": match[2].trim().toLowerCase();\n    \n                    directionBuilder.saveAndGoTo(match[1].trim(), gotoProperty);\n                }\n            }\n            break;\n        }\n        case \"return\": {\n            let returnRegex: RegExp = /^[ \\t]*?>>[ \\t]*?return[ \\t]*?$/gim;\n            let match: string[] | null = returnRegex.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = returnRegex;\n                errorMessage = `Expected \">> return\"`;\n            } else {\n                directionBuilder.return();\n            }\n            break;\n        }\n        case \"restart\": {\n            let restartSyntax: RegExp = /^[ \\t]*?>>[ \\t]*?restart(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/gim;\n            let match: string[] | null = restartSyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = restartSyntax;\n                errorMessage = `Expected \">> restart\"`;\n            } else {\n                directionBuilder.restart();\n            }\n            break;\n        }\n        case \"resume\": {\n            let resumeSyntax: RegExp = /^[ \\t]*?>>[ \\t]*?resume(?:[\\s]+?\\*([\\S]+?))?(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/gim;\n            let match: string[] | null = resumeSyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = resumeSyntax;\n                errorMessage = `Expected \">> resume [optional:*scene property]\"`;\n            } else {\n    \n                let gotoProperty: string = !match[1] || match[1].trim().toLowerCase() == \"say\" ?\n                    \"narration\": match[1].trim().toLowerCase();\n    \n                directionBuilder.goTo(\"{resume}\", gotoProperty);\n            }\n            break;\n        }\n        case \"repeat\": {\n            let repeatSyntax: RegExp = /^[ \\t]*?>>[ \\t]*?repeat(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/gim;\n            let match: string[] | null = repeatSyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = repeatSyntax;\n                errorMessage = `Expected \">> repeat\"`;\n            } else {\n                directionBuilder.repeat();\n            }\n            break;\n        }\n        case \"reprompt\": {\n            let repeatSyntax: RegExp = /^[ \\t]*?>>[ \\t]*?reprompt(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/gim;\n            let match: string[] | null = repeatSyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = repeatSyntax;\n                errorMessage = `Expected \">> reprompt\"`;\n            } else {\n                directionBuilder.repeatReprompt();\n            }\n            break;\n        }\n        case \"back\": {\n            let backSyntax: RegExp = /^[ \\t]*?>>[ \\t]*?back(?:[ \\t]*?([\\d]+?))?(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/gim;\n            let match: string[] | null = backSyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = backSyntax;\n                errorMessage = `Expected \">> BACK [number to go back (default is 1)]\"`;\n            } else {\n                let backNumber: number = !match[1] ? 1: parseInt(match[1].trim());\n                directionBuilder.goBack(backNumber);\n            }\n            break;\n        }\n        case \"pause\": {\n            directionBuilder.pause();\n            break;\n        }\n        case \"end\": {\n            directionBuilder.markEnding();\n            break;\n        }\n        case \"bgm\": {\n            let bgmSyntax: RegExp = /bgm[ \\t]+'?([\\S\\s]+?)'?(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/gm;\n            let match: string[] | null = bgmSyntax.exec(line);\n    \n            if (!match) {   \n                isSyntaxError = true;\n                sytaxErrorRegex = bgmSyntax;\n                errorMessage = `Expected \"bgm [file url]\", but the file url was missing.`;\n            } else {\n                directionBuilder.setBackgroundMusic(match[1].trim());\n            }\n            break;\n        }\n        case \"clear\": {\n            let clearSyntax: RegExp = /clear[ \\t]+?([\\S]+?)(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/gm;\n            let match: string[] | null = clearSyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = clearSyntax;\n                errorMessage = `Expected \"clear [variable]\"`;\n    \n            } else {\n                directionBuilder.clearVariable(match[1].trim());\n            }\n            break;\n        }\n        case \"stack\": {\n            let stackSyntax: RegExp = /stack[ \\t]+(?:'([\\S\\s]+?)'|('')|([\\d]+?)|([\\S\\s]+?))[\\s]+?on[\\s]+([\\S\\s]+?)(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/gm;\n            let match: string[] | null = stackSyntax.exec(line);\n        \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = stackSyntax;\n                errorMessage = `Expected \"stack [string|number|variable] on [variable]\".`;\n            } else {\n                if (match[1]) {\n                    directionBuilder.addItem(match[4].trim(), match[1].replace(/\\\\/g, \"\").trim());\n                } else if (match[2]) {\n                    directionBuilder.addItem(match[4].trim(), \"\");\n                } else if (match[3]) {\n                    directionBuilder.addItem(match[4].trim(), match[3].trim());\n                } else {\n                    directionBuilder.addItem(match[4].trim(), `{${match[4].trim()}}`);\n                }\n            }\n            break;\n        }\n        case \"pop\": {\n            let popSyntax: RegExp = /pop[ \\t]+([\\S\\s]+?)(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/gm;\n            let match: string[] | null = popSyntax.exec(line);\n    \n            if (!match || match[1].trim().length == 0) {\n                isSyntaxError = true;\n                sytaxErrorRegex = popSyntax;\n                errorMessage = `Expected \"pop [variable]\".`;\n            } else {\n                directionBuilder.removeLastItem(match[1].trim());\n            }\n            break;\n        }\n        case \"dequeue\": {\n            let dequeueSyntax: RegExp = /dequeue[ \\t]+([\\s\\S]+?)(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/gm;\n            let match: string[] | null = dequeueSyntax.exec(line);\n    \n            if (!match || match[1].trim().length == 0) {\n                isSyntaxError = true;\n                sytaxErrorRegex = dequeueSyntax;\n                errorMessage = `Expected \"dequeue [variable]\".`;\n            } else {\n                directionBuilder.removeFirstItem(match[1].trim());\n            }\n            break;\n        }\n        case \"put\": {\n            let putSyntax: RegExp = /put[ \\t]+(?:'([\\S\\s]+?)'|('')|([\\d]+?)|([\\S\\s]+?))[ \\t]+?into[ \\t]+([\\S\\s]+?)(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/g;\n            let match: string[] | null = putSyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = putSyntax;\n                errorMessage = `Expected \"put [string|number|variable] into [variable]\".`;\n    \n            } else {\n                if (match[1]) {\n                    directionBuilder.addToInventory(match[4].trim(), match[1].replace(/\\\\/g, \"\").trim());\n                } else if (match[2]) {\n                    directionBuilder.addToInventory(match[4].trim(), \"\");\n                } else if (match[3]) {\n                    directionBuilder.addToInventory(match[4].trim(), match[3].trim());\n                } else {\n                    directionBuilder.addToInventory(match[4].trim(), `{${match[4].trim()}}`);\n                }\n                }\n        }\n        case \"remove\": {\n            let removeSyntax: RegExp = /remove[ \\t]+(?:'([\\S\\s]+?)'|('')|([\\d]+?)|([\\S\\s]+?))[\\s]+?from[\\s]+([\\S\\s]+?)(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/g;\n            let match: string[] | null = removeSyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = removeSyntax;\n                errorMessage = `Expected \"remove [string|number|variable] from [variable]\".`;\n            } else {\n                if (match[1]) {\n                    directionBuilder.removeItem(match[4].trim(), match[1].replace(/\\\\/g, \"\").trim());\n                } else if (match[2]) {\n                    directionBuilder.removeItem(match[4].trim(), \"\");\n                } else if (match[3]) {\n                    directionBuilder.removeItem(match[4].trim(), match[3].trim());\n                } else {\n                    directionBuilder.removeItem(match[4].trim(), `{${match[3].trim()}}`);\n                }\n            }\n            break;\n        }\n        case \"flag\": {\n            let flagSyntax: RegExp = /flag[ \\t]+([\\s\\S]+?)(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/g;\n            let match: string[] | null = flagSyntax.exec(line);\n    \n            if (!match || match[1].trim().length == 0) {\n                isSyntaxError = true;\n                sytaxErrorRegex = flagSyntax;\n                errorMessage = `Expected \"flag [variable]\".`;\n            } else {\n                directionBuilder.flag(match[1].trim());\n            }\n            break;\n        }\n        case \"unflag\": {\n            let unflagSyntax: RegExp = /unflag[ \\t]+([\\s\\S]+?)(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/g;\n            let match: string[] | null = unflagSyntax.exec(line);\n    \n            if (!match || match[1].trim().length == 0) {\n                isSyntaxError = true;\n                sytaxErrorRegex = unflagSyntax;\n                errorMessage = `Expected \"unflag [variable]\".`;\n            } else {\n                directionBuilder.unflag(match[1].trim());\n            }\n            break;\n        } \n        case \"slot\": {\n            let setSyntax: RegExp = /slot[ \\t]+([\\S\\s]+?)[ \\t]+?(?:(?:as)|(?:to))[ \\t]+(?:'([\\S\\s]+?)'|('')|([\\S\\s]+?))(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/gm;\n            let match: string[] | null = setSyntax.exec(line);\n            if (!match || match[1].trim().length == 0 || (!match[2] && !match[3] && !match[4] && match[5].trim().length == 0)) {\n                isSyntaxError = true;\n                sytaxErrorRegex = setSyntax;\n                errorMessage = `Expected \"set [variable] as [string|number|variable]\".`;\n            } else {\n                if (match[4]) {\n                    directionBuilder.setSlot(match[1].trim(), `{${match[4].trim()}}`);\n                } else if (match[3]) {\n                    directionBuilder.setSlot(match[1].trim(), \"\");\n                } else {\n                    directionBuilder.setSlot(match[1].trim(), match[2].replace(/\\\\/g, \"\").trim());\n                }\n            }\n            break;\n        }\n        case \"set\": {\n            let setSyntax: RegExp = /set[ \\t]+([\\S\\s]+?)[ \\t]+(?:(?:as)|(?:to))[ \\t]+(?:'([\\S\\s]+?)'|('')|([\\d]+?)|([\\S\\s]+?))(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/gm;\n            let match: string[] | null = setSyntax.exec(line);\n\n            if (!match || match[1].trim().length == 0 || (!match[2] && !match[3] && !match[4] && match[5].trim().length == 0)) {\n                isSyntaxError = true;\n                sytaxErrorRegex = setSyntax;\n                errorMessage = `Expected \"set [variable] as [string|number|variable]\".`;\n            } else {\n                if (match[5]) {\n                    directionBuilder.setVariable(match[1].trim(), `{${match[5].trim()}}`);\n                } else if (match[4]) {\n                    directionBuilder.setVariable(match[1].trim(), match[4].trim());\n                } else if (match[3]) {\n                    directionBuilder.setVariable(match[1].trim(), \"\");\n                } else {\n                    directionBuilder.setVariable(match[1].trim(), match[2].replace(/\\\\/g, \"\").trim());\n                }\n            }\n            break;\n        }\n        case \"reduce\": {\n            let reduceSyntax: RegExp = /reduce[ \\t]+([\\S\\s]+?)[ \\t]+?by[ \\t]+(?:([\\d]+?)|([\\S\\s]+?))(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/g;\n            let match: string[] | null = reduceSyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = reduceSyntax;\n                errorMessage = `Expected \"reduce [variable] as [string|number|variable]\".`;\n            } else {\n                if (match[3]) {\n                    directionBuilder.reduceVariable(match[1].trim(), `{${match[3].trim()}}`);\n                } else {\n                    directionBuilder.reduceVariable(match[1].trim(), match[2].trim());\n                }\n            }\n            break;\n        }\n        case \"increase\": {\n            let increaseSyntax: RegExp = /increase[ \\t]+([\\s\\S]+?)[ \\t]+?by[ \\t]+(?:([\\d]+?)|([\\S\\s]+?))(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/g;\n            let match: string[] | null = increaseSyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = increaseSyntax;\n                errorMessage = `Expected \"increase [variable] by [number|variable]\".`;\n            } else {\n                if (match[3]) {\n                    directionBuilder.increaseVariable(match[1].trim(), `{${match[3].trim()}}`);\n                } else {\n                    directionBuilder.increaseVariable(match[1].trim(), match[2].trim())\n                }\n            }\n            break;\n        }\n        case \"decrease\": {\n            let decreaseSyntax: RegExp = /decrease[ \\t]+([\\s\\S]+?)[ \\t]+?by[ \\t]+(?:([\\d]+?)|([\\S\\s]+?))(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/g;\n            let match: string[] | null = decreaseSyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = decreaseSyntax;\n                errorMessage = `Expected \"decrease [variable] by [number|variable]\".`;\n            } else {\n                if (match[3]) {\n                directionBuilder.reduceVariable(match[1].trim(), `{${match[3].trim()}}`);\n                } else {\n                    directionBuilder.reduceVariable(match[1].trim(), match[2].trim());\n                }\n            }\n            break;\n        }\n        case \"multiply\": {\n            let multiplySyntax: RegExp = /multiply[ \\t]+([\\s\\S]+?)[ \\t]+?by[ \\t]+(?:([\\d]+?)|([\\S\\s]+?))(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/g;\n            let match: string[] | null = multiplySyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = multiplySyntax;\n                errorMessage = `Expected \"multiply [variable] by [number|variable]\".`;\n            } else {\n                if (match[3]) {\n                    directionBuilder.multiplyVariable(match[1].trim(), `{${match[3].trim()}}`);\n                } else {\n                    directionBuilder.multiplyVariable(match[1].trim(), match[2].trim())\n                }\n            }\n            break;\n        }\n        case \"divide\": {\n            let divideSyntax: RegExp = /divide[ \\t]+([\\s\\S]+?)[ \\t]+?by[ \\t]+(?:([\\d]+?)|([\\S\\s]+?))(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/g;\n            let match: string[] | null = divideSyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = divideSyntax;\n                errorMessage = `Expected \"divide [variable] by [number|variable]\".`;\n            } else {\n                if (match[3]) {\n                    directionBuilder.divideVariable(match[1].trim(), `{${match[3].trim()}}`);\n                } else {\n                    directionBuilder.divideVariable(match[1].trim(), match[2].trim())\n                }\n            }\n            break;\n        }\n        case \"mod\": {\n            let modSyntax: RegExp = /mod[ \\t]+(.+?)[ \\t]+?by[ \\t]+(?:([\\d]+?)|(.+?))(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/g;\n            let match: string[] | null = modSyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = modSyntax;\n                errorMessage = `Expected \"mod [variable] by [number|variable]\".`;\n            } else {\n                if (match[3]) {\n                    directionBuilder.modVariable(match[1].trim(), `{${match[3].trim()}}`);\n                } else {\n                    directionBuilder.modVariable(match[1].trim(), match[2].trim())\n                }\n            }\n            break;\n        }\n        case \"roll\": {\n            let rollSyntax: RegExp = /roll[ \\t]+([\\S\\s]+?)(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/gm;\n            let match: string[] | null = rollSyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = rollSyntax;\n                errorMessage = `Expected \"roll [dice roll notation].`;\n            } else {\n                directionBuilder.rollDice(match[1].trim());\n            }\n            break;\n        }\n        case \"time\": {\n            directionBuilder.getCurrentEpochTime();\n            break;\n        }\n        case \"bookmark\": {\n            let bookmarkSyntax: RegExp = /^[ \\t]*?bookmark(?:[ \\t]+([\\S\\s]+?)(?:->([\\S\\s]+?))?)?$/gm;\n            let match: any = bookmarkSyntax.exec(line);\n    \n            if (!match) {\n                isSyntaxError = true;\n                sytaxErrorRegex = bookmarkSyntax;\n            } else {\n                let bookmarkName: string = match[1] || 'bookmark';\n                let targetName: string = match[2];\n    \n                if (bookmarkName) {\n                    bookmarkName = bookmarkName.trim();\n                }\n                \n                if (targetName) {\n                    targetName = targetName.trim();\n                }\n    \n                directionBuilder.setBookmark(bookmarkName, targetName);\n            }\n            break;\n        }\n        default: {\n            if (line.length > 0 && !line.startsWith(\"//\") && !line.startsWith(\"}\") && !line.startsWith(\"{\") ) {\n                let customSyntax: RegExp = /^[ \\t]*?([\\S]+)(?:[ \\t]+([\\S\\s]+?))?(?=,[\\s]*$|\\.[\\s]*$|[\\s]*$)/gm;\n                let match: string[] | null = customSyntax.exec(line);\n        \n                if (!match) {\n                    isSyntaxError = true;\n                    sytaxErrorRegex = customSyntax;\n                } else {\n                    let customParam: any = {};\n        \n                    if (match[2] && match[2].trim().length > 0) {\n                        let customParamRegex: RegExp = /([\\S]+?)[\\t ]*?=[ \\t]*(?:'([\\S\\s]+?)'|('')|([\\S]+))/g;\n        \n                        let customParamMatch: any = customParamRegex.exec(match[2]);\n                        while (customParamMatch != null) {\n                            if (customParamMatch[3]) {\n                                customParam[customParamMatch[1].trim()] = \"\";\n                            } else if (customParamMatch[4]) {\n                                customParam[customParamMatch[1].trim()] = `{${customParamMatch[4]}}`;\n                            } else {\n                                customParam[customParamMatch[1].trim()] = customParamMatch[2].replace(/\\\\/g, \"\");\n                            }\n\n                            customParamMatch = customParamRegex.exec(match[2]);\n                        }\n                    }\n        \n                    directionBuilder.customDirection(match[1].trim(), customParam);\n                }\n            }\n        }\n        }\n    }\n    const lastOpenBracket = bracketStack.length > 0 ? bracketStack[bracketStack.length - 1]: -1;\n    const bracketRegex = /[\\{\\}]/g;\n    let bracketMatch = bracketRegex.exec(line);\n    while (bracketMatch != null) {\n        //console.log(`found bracket in ${lineNumber} with ${line} for match ${JSON.stringify(bracketMatch)}`);\n        //console.log(`last open line ${lastOpenBracket}`);\n        if (bracketMatch[0] === \"{\") {\n            bracketStack.push(lineNumber);\n        } else if (bracketMatch[0] === \"}\") {\n            if (bracketStack.length > 0) {\n                const splicingNumber = bracketStack.splice(-1, 1)[0];\n                //console.log(`closing out line ${splicingNumber}`)\n                if (splicingNumber === lastOpenBracket) {\n                    directionBuilder.closeChoice();\n                }\n            } else {\n                isSyntaxError = true;\n                errorMessage = \"Unexpected bracket closing: '}'\";\n            }\n        }\n\n        bracketMatch = bracketRegex.exec(line);\n    }\n    \n    if (isSyntaxError && !ignoreSyntaxError) {\n        throw {\n            reason: errorMessage,\n            content: line\n        }\n    }\n\n    return;\n}\n"]}