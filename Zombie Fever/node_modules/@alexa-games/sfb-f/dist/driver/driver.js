"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const storyMetadata_1 = require("../story/storyMetadata");
const storyAccessor_1 = require("../story/storyAccessor");
const DefaultFormatImportPlugin_1 = require("../importPlugins/DefaultFormatImportPlugin");
const ACEExtension_1 = require("../extensions/ACEExtension");
const storyStateHelper_1 = require("./storyStateHelper");
const crypto_1 = require("crypto");
const PlayStage_1 = require("./PlayStage");
const userInputHelper_1 = require("../importPlugins/userInputHelper");
const sfb_polly_1 = require("@alexa-games/sfb-polly");
const tokenReplacer_1 = require("../transformers/tokenReplacer");
const segmenter_1 = require("../transformers/segmenter");
const AudioItemUtil_1 = require("./AudioItemUtil");
const callStackUtil_1 = require("./callStackUtil");
const TOTAL_SCENES_PROCESS_SAFEGUARD = 1000;
const isWin = (process.platform === "win32");
class ACEDriver {
    constructor(storyMetadata, customImportPlugins, extensions, pollyConfiguration, locale = 'en-US', audioAccessor, pollyUtil) {
        this.isPollyAsDefault = false;
        this.importHandlersByType = {};
        this.customExtensions = [];
        this.resultOptions = [];
        this.playQueue = [];
        this.unhandledChoiceFlag = false;
        this.isPausing = false;
        this.isRepeating = false;
        this.defaultNarrator = {
            name: "Joanna",
            pitch: "",
            rate: "",
            volume: "1.0"
        };
        this.historySize = 10;
        this.locale = locale;
        if (pollyConfiguration) {
            this.pollyConfig = pollyConfiguration;
        }
        else if (isWin) {
            this.pollyConfig = { bucketName: "sfb-sample-bucket", combineAudioTags: true, dontUseCache: true, FFMPEGLocation: "..\\ffmpeg.exe", workingDir: "c:\\Tmp", enabledInPreview: false, enabled: false, s3DomainName: "s3.amazonaws.com" };
        }
        else {
            this.pollyConfig = { bucketName: "sfb-sample-bucket", combineAudioTags: true, dontUseCache: true, FFMPEGLocation: "./ffmpeg", workingDir: "/Tmp", enabledInPreview: false, enabled: false, s3DomainName: "s3.amazonaws.com" };
        }
        sfb_polly_1.PollyUtil.configurePolly(this.pollyConfig);
        this.audioAccessor = audioAccessor ||
            new sfb_polly_1.S3AudioAccessor({
                audioWorkingDir: this.pollyConfig.workingDir,
                s3DomainName: this.pollyConfig.s3DomainName || "s3.amazonaws.com",
                bucketName: this.pollyConfig.bucketName,
            });
        this.pollyUtil = pollyUtil || new sfb_polly_1.PollyUtil(this.audioAccessor);
        this.storyAccessor = new storyAccessor_1.StoryAccessor(storyMetadata);
        this.callStack = new callStackUtil_1.CallStackUtil(this.storyAccessor);
        this.storyState = {};
        this.audioItemUtil = new AudioItemUtil_1.AudioItemUtil();
        this.stage = new PlayStage_1.PlayStage(this.audioItemUtil);
        let importPlugins = [
            new DefaultFormatImportPlugin_1.DefaultFormatImportPlugin()
        ];
        if (customImportPlugins) {
            importPlugins = importPlugins.concat(customImportPlugins);
        }
        for (let importPlug of importPlugins) {
            this.importHandlersByType[importPlug.pluginName] = importPlug;
        }
        if (extensions) {
            this.customExtensions = this.customExtensions.concat(extensions);
        }
    }
    /**
     * invoke before calling resumeStory if the story history and progress needs to be reset by running the start sequence.
     * onStart implementation of all registered extensions are run.
     *
     * @param startingStoryState
     */
    async resetStory(startingStoryState) {
        this.storyState = JSON.parse(JSON.stringify(startingStoryState || this.storyState));
        storyStateHelper_1.StoryStateHelper.setCurrentSceneID(this.storyState, storyMetadata_1.BuiltInScenes.StartScene);
        storyStateHelper_1.StoryStateHelper.resetAvailableChoices(this.storyState);
        storyStateHelper_1.StoryStateHelper.resetChoiceHistory(this.storyState);
        return;
    }
    /**
     * Resume the story.
     * If story has been paused, run the resume cycle by playing the 'Resume' scene first.
     * Otherwise, Run normally from the bookmarked scene ID.
     *
     * @param userInput
     * @param startingStoryState
     */
    async resumeStory(_userInput, startingStoryState) {
        this.storyState = JSON.parse(JSON.stringify(startingStoryState || this.storyState));
        if (storyStateHelper_1.StoryStateHelper.isEndingReached(this.storyState)) {
            delete this.storyState.system_prevRecap;
            delete this.storyState.system_prevSpeech;
            storyStateHelper_1.StoryStateHelper.setEndingReached(this.storyState, false);
        }
        this.playQueue = [];
        this.unhandledChoiceFlag = false; // Reset to false
        this.isRepeating = false;
        // apply user input extension by DriverExtensions
        const inputHelper = new userInputHelper_1.UserInputHelper(_userInput);
        for (let extension of this.customExtensions) {
            if (!ACEExtension_1.isDriverExtension(extension)) {
                continue;
            }
            await extension.pre({
                driver: this,
                storyState: this.storyState,
                userInputHelper: inputHelper,
                locale: this.locale
            });
        }
        const userInput = inputHelper.getUserInput();
        if (!storyStateHelper_1.StoryStateHelper.isStoryPaused(this.storyState) && !this.isPausing) {
            await this.processChoice.call(this, userInput);
        }
        if (!this.isRepeating) {
            if (ACEDriver.debug)
                console.log("[DEBUG] Play queue length: " + this.playQueue.length);
            if (this.playQueue.length === 0) {
                let bookmarkedSceneID = storyStateHelper_1.StoryStateHelper.getCurrentSceneID(this.storyState);
                if (ACEDriver.debug)
                    console.log("[DEBUG] Current bookmark: " + bookmarkedSceneID);
                if (bookmarkedSceneID == null) {
                    if (ACEDriver.debug)
                        console.log("[DEBUG] Enqueue start scene");
                    this.playQueue.push({
                        sceneID: storyMetadata_1.BuiltInScenes.StartScene,
                        property: "narration"
                    });
                }
                else {
                    let resumeExists = false;
                    try {
                        let scene = this.storyAccessor.getSceneByID(storyMetadata_1.BuiltInScenes.ResumeScene);
                        if (scene) {
                            resumeExists = true;
                        }
                    }
                    catch (err) {
                        resumeExists = false;
                    }
                    if (storyStateHelper_1.StoryStateHelper.isStoryPaused(this.storyState) && resumeExists) {
                        if (ACEDriver.debug)
                            console.log("[DEBUG] Enqueue resume scene, and clear choices.");
                        storyStateHelper_1.StoryStateHelper.resetAvailableChoices(this.storyState);
                        if (storyStateHelper_1.StoryStateHelper.getCurrentSceneID(this.storyState) !== storyMetadata_1.BuiltInScenes.PauseScene) {
                            this.storyState.resume = storyStateHelper_1.StoryStateHelper.getCurrentSceneID(this.storyState);
                        }
                        this.playQueue.push({
                            sceneID: storyMetadata_1.BuiltInScenes.ResumeScene,
                            property: "narration"
                        });
                    }
                    else {
                        if (ACEDriver.debug)
                            console.log("[DEBUG] Enqueue saved scene: " + bookmarkedSceneID);
                        this.playQueue.push({
                            sceneID: bookmarkedSceneID,
                            property: "narration"
                        });
                    }
                    // Also set a flag to indicate that we hit an unhandled choice so the caller can do something different if they want to
                    this.unhandledChoiceFlag = true;
                }
            }
            storyStateHelper_1.StoryStateHelper.setStoryPaused(this.storyState, false);
            if (!this.storyState.system_originStack) {
                this.storyState.system_originStack = [];
            }
            this.storyState.system_originStack.push(this.playQueue[0]);
            if (this.storyState.system_originStack.length > this.historySize) {
                // too large, remove first item
                this.storyState.system_originStack.splice(0, 1);
            }
            let totalScenesProcessedCount = 0;
            while (this.playQueue.length > 0 && !this.isPausing) {
                let dequeuedSceneID = this.playQueue.splice(0, 1)[0];
                if (ACEDriver.debug)
                    console.log("[DEBUG] Setting the current scene to: " + dequeuedSceneID);
                this.stage.logVisitedScene(dequeuedSceneID.sceneID);
                storyStateHelper_1.StoryStateHelper.setCurrentSceneID(this.storyState, dequeuedSceneID.sceneID);
                let preProcessState = JSON.stringify(this.storyState);
                await this.processScene.call(this, undefined, dequeuedSceneID.property);
                if (ACEDriver.testing) {
                    let beforeStructure = JSON.parse(preProcessState);
                    console.log("\n");
                    check("", beforeStructure, this.storyState);
                }
                totalScenesProcessedCount++;
                if (totalScenesProcessedCount >= TOTAL_SCENES_PROCESS_SAFEGUARD) {
                    throw new Error("[ACE Driver - Infinite Loop] Looped " + TOTAL_SCENES_PROCESS_SAFEGUARD + " times, last scene ID was: " + dequeuedSceneID.sceneID + ". Please fix your infinite loop.");
                }
            }
            if (this.isPausing) {
                this.isPausing = false;
                await this.executePauseSequence(_userInput);
            }
        }
        this.storyState.system_prevSpeech = this.stage.getStageSpeechAudioSequence();
        this.storyState.system_prevReprompt = this.stage.getStageRepromptAudioSequence();
        this.storyState.system_prevRecap = this.stage.getStageRecapAudioSequence();
        // apply user input extension by DriverExtensions
        for (let extension of this.customExtensions) {
            if (!ACEExtension_1.isDriverExtension(extension)) {
                continue;
            }
            await extension.post({
                driver: this,
                storyState: this.storyState,
                userInputHelper: inputHelper,
                locale: this.locale
            });
        }
    }
    pauseStory() {
        this.isPausing = true;
    }
    /**
     * Run the pause sequence by playing the 'Pause' scene.
     *
     * @param startingStoryState
     */
    async executePauseSequence(_userInput, startingStoryState) {
        this.storyState = Object.assign({}, startingStoryState || this.storyState);
        let savingSceneID = storyStateHelper_1.StoryStateHelper.getCurrentSceneID(this.storyState);
        if (savingSceneID == storyMetadata_1.BuiltInScenes.ResumeScene) {
            savingSceneID = this.storyState.resume;
        }
        storyStateHelper_1.StoryStateHelper.setCurrentSceneID(this.storyState, storyMetadata_1.BuiltInScenes.PauseScene);
        let preProcessState = JSON.stringify(this.storyState);
        await this.processScene.call(this);
        if (ACEDriver.testing) {
            let beforeStructure = JSON.parse(preProcessState);
            console.log("\n");
            check("", beforeStructure, this.storyState);
        }
        // saving the previous scene for next resume.
        storyStateHelper_1.StoryStateHelper.setCurrentSceneID(this.storyState, savingSceneID === null ? storyMetadata_1.BuiltInScenes.StartScene : savingSceneID);
        storyStateHelper_1.StoryStateHelper.setStoryPaused(this.storyState, true);
        // apply user input extension by DriverExtensions
        const inputHelper = new userInputHelper_1.UserInputHelper(_userInput);
        for (let extension of this.customExtensions) {
            if (!ACEExtension_1.isDriverExtension(extension)) {
                continue;
            }
            await extension.post({
                driver: this,
                storyState: this.storyState,
                userInputHelper: inputHelper,
                locale: this.locale
            });
        }
        return;
    }
    /**
     * Configure the default polly narrator settings.
     */
    configureDefaultPollyNarrator(narrator) {
        console.info("[INFO] Default narrator set: " + JSON.stringify(narrator));
        this.defaultNarrator = narrator;
    }
    /**
     * Turning on the 'default polly' causes all narration texts (including the ones not surrounded by the 'voice' tag) to be read in polly voice.
     * The polly voice setting for this can be configured by calling configureDefaultPollyNarrator().
     */
    turnOnDefaultPolly() {
        this.isPollyAsDefault = true;
    }
    /**
     * Turning off the 'default polly' causes all narration texts (texts NOT surrounded by the 'voice' tag) to be processed as non-polly voice.
     */
    turnOffDefaultPolly() {
        this.isPollyAsDefault = false;
    }
    async getSpeechSSMLText() {
        let { ssml } = await this.buildAudioScenes(this.stage.getStageSpeechAudioSequence());
        return ssml;
    }
    async getSpeechSSMLTextPerScene() {
        const sceneAudioItems = this.stage.getStageSpeechAudioSequence(true);
        const scenesAndSsmlList = [];
        for (let item of sceneAudioItems) {
            let { ssml } = await this.buildAudioScenes([item]);
            let sceneAndSsml = { sceneID: item.sceneID, sceneAudioItem: item, ssml };
            scenesAndSsmlList.push(sceneAndSsml);
        }
        return scenesAndSsmlList;
    }
    getVisitedSceneIDsOnRun() {
        return this.stage.getVisitedSceneIDsOnRun();
    }
    async getSpeechSSMLAndPrettyText() {
        let { ssml, pretty, errorMessage } = await this.buildAudioScenes(this.stage.getStageSpeechAudioSequence());
        return { ssml, pretty, errorMessage };
    }
    async getRepromptSSMLText() {
        let { ssml } = await this.buildAudioScenes(this.stage.getStageRepromptAudioSequence());
        return ssml;
    }
    async getRepromptSSMLAndPrettyText() {
        let { ssml, pretty, errorMessage } = await this.buildAudioScenes(this.stage.getStageRepromptAudioSequence());
        return { ssml, pretty, errorMessage };
    }
    async getVisuals() {
        return this.stage.getStageVisualOptions();
    }
    async buildAudioScenes(sceneAudioItemList) {
        const mixedSceneAudio = await this.audioItemUtil.proccessSceneAudioItems(sceneAudioItemList, this.pollyConfig, this.audioAccessor);
        let ssml = "";
        let errorMessage;
        try {
            if (mixedSceneAudio.length > 0) {
                const audioTypeCount = this.audioItemUtil.getAudioCount(mixedSceneAudio);
                if (this.pollyConfig.enabled && ((audioTypeCount > 5 && this.pollyConfig.combineAudioTags) || this.pollyConfig.enabledInPreview)) {
                    const combinedAudioItems = await this.audioItemUtil.combineConsecutiveAudioItems(mixedSceneAudio, this.pollyConfig, this.audioAccessor, ACEDriver.SSML_AUDIO_LIMIT);
                    ssml = this.audioItemUtil.generateSSMLText([{
                            foreground: combinedAudioItems,
                            background: []
                        }], this.pollyConfig);
                }
                else {
                    ssml = this.audioItemUtil.generateSSMLText(mixedSceneAudio, this.pollyConfig);
                }
            }
        }
        catch (err) {
            errorMessage = "[ERROR] Could not generate mixed audio. Please verify that your resources path is correctly configured.";
            console.log(errorMessage, err);
        }
        const previewSSML = this.audioItemUtil.generateSSMLText(sceneAudioItemList, this.pollyConfig);
        if (!this.pollyConfig.dontUploadToS3) {
            await this.audioItemUtil.uploadGeneratedFiles(this.audioAccessor, this.pollyConfig.workingDir);
        }
        return { ssml: ssml, pretty: previewSSML, errorMessage };
    }
    /**
     * Get the current story state.
     */
    getCurrentStoryState() {
        return JSON.parse(JSON.stringify(this.storyState)); //deep copy
    }
    getResultOptions() {
        return this.resultOptions;
    }
    /**
     * See if the scene marked as ending, or scene leading to no new choice has been reached as a result of the current resume/run.
     */
    isEndingReached() {
        return storyStateHelper_1.StoryStateHelper.isEndingReached(this.storyState);
    }
    /**
     * See if a choice was unhandled and allow the caller to do something else if they need to.
     */
    isUnhandledChoice() {
        return this.unhandledChoiceFlag;
    }
    /**
     * Execute the selected choice indicated by the user input.
     */
    async processChoice(userInput) {
        return new Promise(async (resolve, reject) => {
            if (ACEDriver.debug)
                console.log("[DEBUG] Calling processChoice");
            const availableChoices = storyStateHelper_1.StoryStateHelper.getAvailableChoices(this.storyState);
            if (ACEDriver.debug)
                console.log("[DEBUG] Loading Available Choices: " + JSON.stringify(availableChoices, null, 4));
            const selectedChoice = storyStateHelper_1.StoryStateHelper.getChoiceByUserInput(this.storyState, userInput, this.locale);
            if (ACEDriver.debug)
                console.log(`[DEBUG] With UserInput=${JSON.stringify(userInput)}, Selected Choice=${JSON.stringify(selectedChoice, null, 4)}`);
            if (selectedChoice == null) {
                if ((!this.storyState.system_prevRecap || this.storyState.system_prevRecap.length == 0)
                    && (!this.storyState.system_prevSpeech || this.storyState.system_prevSpeech.length == 0)) {
                    this.isRepeating = false;
                }
                else {
                    if (this.storyState.system_prevRecap && this.storyState.system_prevRecap.length > 0) {
                        this.stage.appendStageSpeechAudioSequence(this.storyState.system_prevRecap);
                        this.stage.appendStageRepromptAudioSequence(this.storyState.system_prevRecap);
                    }
                    else if (this.storyState.system_prevSpeech && this.storyState.system_prevSpeech.length > 0) {
                        this.stage.appendStageSpeechAudioSequence(this.storyState.system_prevSpeech);
                        this.stage.appendStageRepromptAudioSequence(this.storyState.system_prevSpeech);
                    }
                    if (this.storyState.system_prevReprompt && this.storyState.system_prevReprompt.length > 0) {
                        this.stage.setStageRepromptAudioSequence(this.storyState.system_prevReprompt);
                    }
                    this.isRepeating = true;
                }
            }
            else {
                storyStateHelper_1.StoryStateHelper.setSelectedChoiceID(this.storyState, selectedChoice.id);
                const beforeState = JSON.parse(JSON.stringify(this.storyState));
                try {
                    if (selectedChoice.sceneDirections) {
                        // Keep for backwards compatibility.
                        let tempChoiceInstructionAddress = storyStateHelper_1.StoryStateHelper.getCurrentSceneID(this.storyState) + ":" + selectedChoice.id + ":" + -1;
                        this.storyState.system_instruction_mem = this.storyState.system_instruction_mem || [];
                        this.storyState.system_instruction_mem[tempChoiceInstructionAddress] = selectedChoice.sceneDirections;
                        await this.performInstructions.call(this, tempChoiceInstructionAddress);
                    }
                    else if (selectedChoice.instructionAddress) {
                        await this.performInstructions.call(this, selectedChoice.instructionAddress);
                    }
                }
                catch (err) {
                    reject(err);
                }
                if (!this.isRepeating) {
                    storyStateHelper_1.StoryStateHelper.resetAvailableChoices(this.storyState);
                    if (selectedChoice.saveToHistory) {
                        storyStateHelper_1.StoryStateHelper.addChoiceHistory(this.storyState, selectedChoice, getStateDiffs(beforeState, this.storyState), this.historySize);
                    }
                }
            }
            storyStateHelper_1.StoryStateHelper.clearSelectedChoiceID(this.storyState);
            resolve();
        });
    }
    /**
     * Process the current scene. Updating speech, reprompt, variables as indicated by the scene.
     */
    async processScene(sceneID, sceneProperty) {
        if (ACEDriver.debug)
            console.log("[INFO] Calling processScene.");
        let currentSceneID = storyStateHelper_1.StoryStateHelper.getCurrentSceneID(this.storyState);
        if (sceneID) {
            currentSceneID = sceneID;
        }
        if (ACEDriver.testing) {
            console.log("\n\nSCENE '" + currentSceneID + "'");
            console.log("........................");
        }
        let currentScene = undefined;
        if (currentSceneID != null) {
            currentScene = this.storyAccessor.getSceneByID(currentSceneID || "");
        }
        if (!currentScene) {
            if (ACEDriver.debug)
                throw new Error(`[WARN] Cannot find the Scene=[${currentSceneID}]`);
            else
                return;
        }
        this.stage.startNewScene(currentSceneID || "");
        storyStateHelper_1.StoryStateHelper.clearRecap(this.storyState);
        for (let variation of currentScene.contents) {
            // evaluate body's conditional
            let conditionPassed = true;
            if (variation.condition && !variation.condition.startsWith("otherwise")) {
                if (ACEDriver.debug)
                    console.log("[DEBUG] pre-substitution condition= " + JSON.stringify(variation.condition, null, 4));
                let substitution = replaceVariables(variation.condition, this.storyState, true);
                if (ACEDriver.debug)
                    console.log("[DEBUG] post-substitution condition= " + substitution);
                if (!evalInContext(substitution, this)) {
                    conditionPassed = false;
                }
            }
            if (!conditionPassed) {
                if (ACEDriver.testing && variation.condition)
                    console.log(`${padString("FAILED", 8)}\t>${variation.condition}`);
                continue;
            }
            if (ACEDriver.testing && variation.condition)
                console.log(`${padString("PASSED", 8)}\t>${variation.condition}`);
            /*
            * Narration
            */
            let sceneNarration = [];
            if (variation.narration) {
                let narrationText = replaceVariables(variation.narration, this.storyState, false)
                    .replace(/\n/g, " ")
                    .replace(/[\s]+/g, " ");
                let narrationVariations = narrationText.split("||");
                let selectedNarration = narrationVariations[Math.floor(Math.random() * narrationVariations.length)];
                sceneNarration = this.audioItemUtil.buildAudioItemsFromSSML(selectedNarration, this.isPollyAsDefault ? this.defaultNarrator : undefined);
            }
            /*
            * Scene Directions
            */
            if (variation.sceneDirections && variation.sceneDirections.length > 0) {
                const instructionSetAddress = this.callStack.getSceneAddress(currentSceneID || "", 0);
                await this.performInstructions(instructionSetAddress);
            }
            if (sceneProperty && sceneProperty.trim().toLowerCase() == "reprompt" && this.stage.getRepromptSceneAudio().foreground.length > 0) {
                sceneNarration = this.stage.getRepromptSceneAudio().foreground;
            }
            if (sceneProperty && sceneProperty.trim().toLowerCase() == "recap" && this.stage.getRecapSceneAudio().foreground.length > 0) {
                sceneNarration = this.stage.getRecapSceneAudio().foreground;
            }
            this.stage.appendSceneSpeechForeground(sceneNarration);
            break; // Only one of the scene variations are played.
        }
        this.stage.closeScene();
    }
    /**
     * Peform given list of scene directions in order.
     *
     * @param directions Scene Directions to peform.
     * @return returns the resulting scene direction where all the variables are replaced by the actual values.
     */
    async performInstructions(instructionAddress) {
        if (ACEDriver.debug)
            console.log(`[DEBUG] Calling performInstructions...`);
        let isTerminatingDirection = false;
        let visualAlreadyDefined = false;
        let directions = [];
        if (this.storyState.system_instruction_mem && this.storyState.system_instruction_mem[instructionAddress]) {
            // For backward compatibility, needs to stay
            directions = this.storyState.system_instruction_mem[instructionAddress];
        }
        else {
            directions = this.callStack.getInstructions(instructionAddress, this.storyState);
        }
        for (let lineNumber = 0; lineNumber < directions.length; lineNumber++) {
            let parameters = JSON.parse(JSON.stringify(directions[lineNumber].parameters));
            let type = directions[lineNumber].directionType;
            for (let paramName of Object.keys(parameters)) {
                if (typeof (parameters[paramName]) == 'string') {
                    const isCondition = paramName === "condition";
                    parameters[paramName] = replaceVariables(parameters[paramName], this.storyState, isCondition);
                }
            }
            switch (type) {
                case storyMetadata_1.InstructionType.CUSTOM: {
                    if (ACEDriver.testing)
                        console.log(`${padString("CUSTOM", 8)}\t> calling custom instruction with:\n${JSON.stringify(parameters, null, 4)}`);
                    for (let extension of this.customExtensions) {
                        if (ACEExtension_1.isInstructionExtension(extension)) {
                            const customInstructionName = parameters.customName;
                            if (extension[customInstructionName]) {
                                await extension[customInstructionName]({
                                    instructionName: parameters.customName,
                                    instructionParameters: parameters,
                                    playStage: this.stage,
                                    storyAccessor: this.storyAccessor,
                                    storyState: this.storyState
                                });
                            }
                        }
                        else {
                            continue;
                        }
                    }
                    break;
                }
                case storyMetadata_1.InstructionType.SLOT: {
                    const variableName = parameters.variableName;
                    const slotType = parameters.variableType;
                    storyStateHelper_1.StoryStateHelper.addExpectedCustomSlot(this.storyState, variableName);
                    if (ACEDriver.testing)
                        console.log(`${padString("SLOT", 8)}\t>'${variableName}' as ${slotType}`);
                    break;
                }
                case storyMetadata_1.InstructionType.BOOKMARK: {
                    let bookmarkName = parameters.variableName;
                    let targetName = parameters.variableValue;
                    if (!targetName) {
                        targetName = storyStateHelper_1.StoryStateHelper.getCurrentSceneID(this.storyState);
                    }
                    if (targetName == null) {
                        throw new Error("SFBDriver: target is not defined for the bookmark command.");
                    }
                    this.storyState[bookmarkName] = {
                        type: 'sceneID',
                        value: targetName
                    };
                    if (ACEDriver.testing)
                        console.log(`${padString("BOOKMARK", 8)}\t>'${bookmarkName}' as ${targetName}`);
                    break;
                }
                case storyMetadata_1.InstructionType.CHOICE: {
                    let choiceID = crypto_1.createHash('md5').update(JSON.stringify(parameters.utterances).trim().toLowerCase()).digest('hex');
                    let utterances = parameters.utterances;
                    if (parameters.utteranceIDs && parameters.utteranceIDs.length > 0) {
                        utterances = utterances.concat(parameters.utteranceIDs);
                    }
                    let choice = {
                        id: choiceID,
                        instructionAddress: this.callStack.getChoiceAddress(instructionAddress, lineNumber),
                        utterances: utterances,
                        saveToHistory: false //parameters.saveToHistory && parameters.saveToHistory.trim().toLowerCase() == 'true'? true: false
                    };
                    if (parameters.narration) {
                        choice.narration = parameters.narration;
                    }
                    storyStateHelper_1.StoryStateHelper.enqueueAvailableChoice(this.storyState, choice);
                    if (ACEDriver.testing)
                        console.log(`${padString("CHOICE", 8)}\t> Register ChoiceID=[${choiceID}] for expected input '${parameters.utterances}'`);
                    break;
                }
                case storyMetadata_1.InstructionType.CONDITION: {
                    let conditionPassed = true;
                    let conditionString = parameters.condition;
                    if (ACEDriver.debug)
                        console.log("[DEBUG] pre-substitution condition= " + JSON.stringify(conditionString, null, 4));
                    let substitution = replaceVariables(conditionString, this.storyState, true);
                    if (ACEDriver.debug)
                        console.log("[DEBUG] post-substitution condition= " + substitution);
                    if (!evalInContext(substitution, this)) {
                        conditionPassed = false;
                    }
                    if (!conditionPassed) {
                        if (ACEDriver.testing && conditionString)
                            console.log(`${padString("FAILED", 8)}\t>'${directions[lineNumber].parameters.condition}' evaluated as [${conditionString}]`);
                    }
                    else {
                        if (ACEDriver.testing && conditionString)
                            console.log(`${padString("PASSED", 8)}\t>'${directions[lineNumber].parameters.condition}' evaluated as [${conditionString}]`);
                        if (parameters.directions && parameters.directions.length > 0) {
                            const conditionInstructionAddress = this.callStack.getConditionAddress(instructionAddress, lineNumber);
                            await this.performInstructions.call(this, conditionInstructionAddress);
                            isTerminatingDirection = true;
                        }
                    }
                    break;
                }
                case storyMetadata_1.InstructionType.GO_TO: {
                    let destinationPage = parameters.target;
                    if (this.storyState[destinationPage] && this.storyState[destinationPage].type == 'sceneID') {
                        this.playQueue.push({
                            sceneID: this.storyState[destinationPage].value,
                            property: parameters.targetSceneProperty || "narration"
                        });
                    }
                    else {
                        this.playQueue.push({
                            sceneID: destinationPage.toLowerCase(),
                            property: parameters.targetSceneProperty || "narration"
                        });
                    }
                    isTerminatingDirection = true;
                    if (ACEDriver.testing)
                        console.log(`${padString("GO TO", 8)}\t>scene '${destinationPage}'`);
                    break;
                }
                case storyMetadata_1.InstructionType.SAVE_AND_GO: {
                    let destinationPage = parameters.target.toLowerCase();
                    const savingAddress = this.callStack.getReturnAddress(instructionAddress, lineNumber);
                    if (!this.storyState.system_call_stack) {
                        this.storyState.system_call_stack = [];
                    }
                    this.storyState.system_call_stack.push(savingAddress);
                    if (ACEDriver.testing)
                        console.log(`${padString("CALL", 8)}\t>scene '${destinationPage}'`);
                    this.playQueue.push({
                        sceneID: destinationPage,
                        property: parameters.targetSceneProperty || "narration"
                    });
                    isTerminatingDirection = true;
                    break;
                }
                case storyMetadata_1.InstructionType.RETURN: {
                    if (this.storyState.system_call_stack && this.storyState.system_call_stack.length > 0) {
                        const returnAddress = this.storyState.system_call_stack.splice(-1, 1)[0];
                        if (ACEDriver.testing)
                            console.log(`${padString("RETURN", 8)}\t> Returning to address ${returnAddress}.'`);
                        const popSceneID = this.callStack.getSourceScene(returnAddress);
                        storyStateHelper_1.StoryStateHelper.setCurrentSceneID(this.storyState, popSceneID);
                        await this.performInstructions.call(this, returnAddress);
                    }
                    else {
                        if (ACEDriver.testing)
                            console.log(`${padString("RETURN", 8)}\t> There is instructions to return to.'`);
                    }
                    isTerminatingDirection = true;
                    break;
                }
                case storyMetadata_1.InstructionType.RESTART: {
                    await this.resetStory();
                    this.playQueue.push({
                        sceneID: storyMetadata_1.BuiltInScenes.StartScene,
                        property: parameters.targetSceneProperty || "narration"
                    });
                    if (ACEDriver.testing)
                        console.log(`${padString("RESTART", 8)}\t> Refresh and restart the story.`);
                    isTerminatingDirection = true;
                    break;
                }
                case storyMetadata_1.InstructionType.REPEAT: {
                    if (this.storyState.system_prevSpeech && this.storyState.system_prevSpeech.length > 0) {
                        this.stage.appendStageSpeechAudioSequence(this.storyState.system_prevSpeech);
                        this.stage.appendStageRepromptAudioSequence(this.storyState.system_prevReprompt);
                        if (ACEDriver.testing)
                            console.log(`${padString("REPEAT", 8)}\t> Repeating previously heard speech:\n${JSON.stringify(this.storyState.system_prevSpeech, null, 4)}\nreprompt:\n${JSON.stringify(this.storyState.system_prevReprompt, null, 4)}`);
                    }
                    else {
                        if (ACEDriver.testing)
                            console.log(`${padString("REPEAT", 8)}\t> Nothing to repeat.'`);
                    }
                    this.isRepeating = true;
                    isTerminatingDirection = true;
                    break;
                }
                case storyMetadata_1.InstructionType.REPEAT_REPROMPT: {
                    if (this.storyState.system_prevReprompt && this.storyState.system_prevReprompt.length > 0) {
                        this.stage.setStageSpeechAudioSequence(this.stage.getStageRepromptAudioSequence().concat(this.storyState.system_prevReprompt));
                        this.stage.appendStageRepromptAudioSequence(this.storyState.system_prevReprompt);
                        if (ACEDriver.testing)
                            console.log(`${padString("RE-REPROMPT", 8)}\t> Repeating previously heard reprompt:\n${JSON.stringify(this.storyState.system_prevReprompt, null, 4)}`);
                    }
                    else {
                        if (ACEDriver.testing)
                            console.log(`${padString("RE-REPROMPT", 8)}\t> Nothing to reprompt.'`);
                    }
                    this.isRepeating = true;
                    isTerminatingDirection = true;
                    break;
                }
                case storyMetadata_1.InstructionType.BACK: {
                    let countBack = parameters.count + 1;
                    if (!this.storyState.system_originStack || this.storyState.system_originStack.length == 0) {
                        if (ACEDriver.testing)
                            console.log(`${padString("BACK", 8)}\t>There is no scene to go back to.`);
                    }
                    else {
                        let transitionStack = JSON.parse(JSON.stringify(this.storyState.system_originStack));
                        let destinationScene = undefined;
                        while (countBack-- > 0 && transitionStack.length > 0) {
                            destinationScene = transitionStack.splice(-1, 1)[0];
                        }
                        this.playQueue.push(destinationScene);
                        this.storyState.system_originStack = transitionStack;
                        if (ACEDriver.testing)
                            console.log(`${padString("BACK", 8)}\t> back count=${parameters.count} to scene '${JSON.stringify(destinationScene)}'`);
                    }
                    isTerminatingDirection = true;
                    break;
                }
                case storyMetadata_1.InstructionType.RECAP: {
                    let recapMessage = replaceVariables(parameters.message, this.storyState, false)
                        .replace(/\n/g, " ")
                        .replace(/[\s]+/g, " ")
                        .split("||");
                    let selectedRecap = recapMessage[Math.floor(Math.random() * recapMessage.length)];
                    if (selectedRecap.trim().length > 0) {
                        this.stage.appendSceneRecapForeground(this.audioItemUtil.buildAudioItemsFromSSML(selectedRecap.replace(/\n/g, ' ').replace(/[\s]+/g, ' '), this.isPollyAsDefault ? this.defaultNarrator : undefined));
                        if (ACEDriver.testing)
                            console.log(`${padString("RECAP", 8)}\t>'${selectedRecap}'`);
                    }
                    else {
                        if (ACEDriver.testing)
                            console.log(`${padString("RECAP", 8)}\t>'Nothing to set as recap message.'`);
                    }
                    break;
                }
                case storyMetadata_1.InstructionType.END: {
                    storyStateHelper_1.StoryStateHelper.setEndingReached(this.storyState, true);
                    await this.resetStory();
                    this.isRepeating = true;
                    if (ACEDriver.testing)
                        console.log(`END`);
                    isTerminatingDirection = true;
                    break;
                }
                case storyMetadata_1.InstructionType.PAUSE: {
                    this.isPausing = true;
                    if (ACEDriver.testing)
                        console.log(`PAUSE`);
                    isTerminatingDirection = true;
                    break;
                }
                case storyMetadata_1.InstructionType.BGM: {
                    let bgmURL = parameters.audioURL;
                    this.stage.appendSceneSpeechBackground(this.audioItemUtil.buildAudioItemsFromSSML(`<audio src='${bgmURL}' delay='${parameters.delayMs || ""}' volume='${parameters.volume || ""}' blend='${parameters.blend}'/>`, this.isPollyAsDefault ? this.defaultNarrator : undefined));
                    if (ACEDriver.testing)
                        console.log(`${padString("BGM", 8)}\t>${bgmURL}`);
                    break;
                }
                case storyMetadata_1.InstructionType.CLEAR: {
                    let attributeName = parameters.variableName;
                    if (attributeName.trim() == "*") {
                        attributeName = "";
                        for (let key of Object.keys(this.storyState)) {
                            if (!key.startsWith("system_")) {
                                attributeName += `${key} ; `;
                                delete this.storyState[key];
                            }
                        }
                    }
                    else {
                        delete this.storyState[attributeName];
                    }
                    if (ACEDriver.testing)
                        console.log(`${padString("CLEAR", 8)}\t>'${attributeName}'`);
                    break;
                }
                case storyMetadata_1.InstructionType.ADD_TO_INVENTORY: {
                    let item = parameters.itemName;
                    let listName = parameters.variableName;
                    if (!this.storyState[listName]) {
                        this.storyState[listName] = {};
                    }
                    if (!this.storyState[listName][item]) {
                        this.storyState[listName][item] = 0;
                    }
                    this.storyState[listName][item]++;
                    if (ACEDriver.testing)
                        console.log(`${padString("ADD INVENTORY", 8)}\t>'${item}' to '${listName}'`);
                    break;
                }
                case storyMetadata_1.InstructionType.ADD_ITEM: {
                    let item = parameters.itemName;
                    let listName = parameters.variableName;
                    let sizeLimit = parameters.size || "-1";
                    if (!this.storyState[listName]) {
                        this.storyState[listName] = [];
                    }
                    this.storyState[listName].push(item);
                    let size = parseInt(sizeLimit, 10);
                    if (size > 0 && this.storyState[listName].length > size) {
                        this.storyState[listName].splice(0, this.storyState[listName].length - size);
                    }
                    if (ACEDriver.testing)
                        console.log(`${padString("ADD ITEM", 8)}\t>'${item}' to '${listName}'`);
                    break;
                }
                case storyMetadata_1.InstructionType.GET_TIME: {
                    let currentTime = new Date().getTime();
                    this.storyState.system_return = currentTime;
                    if (ACEDriver.testing)
                        console.log(`${padString("GET TIME", 8)}\t>${currentTime}`);
                }
                case storyMetadata_1.InstructionType.REMOVE_ITEM: {
                    let item = parameters.itemName;
                    let listName = parameters.variableName;
                    if (this.storyState[listName] && typeof this.storyState[listName].length == 'number') {
                        let deletingIndex = -1;
                        for (let i = 0; i < this.storyState[listName].length; i++) {
                            if (this.storyState[listName][i] == item) {
                                deletingIndex = i;
                                break;
                            }
                        }
                        if (deletingIndex >= 0) {
                            let removeResult = this.storyState[listName].splice(deletingIndex, 1)[0];
                            this.storyState.system_return = removeResult;
                        }
                    }
                    else if (this.storyState[listName] && typeof this.storyState[listName].length == 'undefined') {
                        if (typeof this.storyState[listName][item] == 'number' && this.storyState[listName][item] > 0) {
                            this.storyState[listName][item]--;
                        }
                        else if (typeof this.storyState[listName][item] != 'number') {
                            delete this.storyState[listName][item];
                        }
                    }
                    if (ACEDriver.testing)
                        console.log(`${padString("DEL ITEM", 8)}\t>'${item}' from '${listName}'`);
                    break;
                }
                case storyMetadata_1.InstructionType.REMOVE_FIRST: {
                    let listName = parameters.variableName;
                    if (this.storyState[listName]) {
                        let removeResult = this.storyState[listName].splice(0, 1)[0];
                        this.storyState.system_return = removeResult;
                    }
                    if (ACEDriver.testing)
                        console.log(`${padString("DEL ITEM", 8)}\t>FIRST from '${listName}'`);
                    break;
                }
                case storyMetadata_1.InstructionType.REMOVE_LAST: {
                    let listName = parameters.variableName;
                    if (this.storyState[listName]) {
                        let removeResult = this.storyState[listName].splice(this.storyState[listName].length - 1, 1);
                        this.storyState.system_return = removeResult;
                    }
                    if (ACEDriver.testing)
                        console.log(`${padString("DEL ITEM", 8)}\t>LAST from '${listName}'`);
                    break;
                }
                case storyMetadata_1.InstructionType.FLAG: {
                    let variableName = parameters.variableName;
                    this.storyState[variableName] = true;
                    if (ACEDriver.testing)
                        console.log(`${padString("FLAG", 8)}\t>'${variableName}'`);
                    break;
                }
                case storyMetadata_1.InstructionType.UNFLAG: {
                    let variableName = parameters.variableName;
                    this.storyState[variableName] = false;
                    if (ACEDriver.testing)
                        console.log(`${padString("UNFLAG", 8)}\t>'${variableName}'`);
                    break;
                }
                case storyMetadata_1.InstructionType.SET: {
                    let variableName = parameters.variableName;
                    let value = parameters.variableValue == "undefined" ? 0 : parseFloat(parameters.variableValue);
                    if (parameters.variableValue.length === 0) {
                        value = "";
                    }
                    else if (isNaN(parameters.variableValue)) {
                        value = parameters.variableValue;
                        if (value == 'true') {
                            value = true;
                        }
                        else if (value == 'false') {
                            value = false;
                        }
                    }
                    if (this.storyState[variableName] == undefined) {
                        this.storyState[variableName] = 0;
                    }
                    this.storyState[variableName] = value;
                    if (ACEDriver.testing)
                        console.log(`${padString("SET", 8)}\t>'${variableName}' as ${value}`);
                    break;
                }
                case storyMetadata_1.InstructionType.REDUCE: {
                    let variableName = parameters.variableName;
                    let value = parseFloat(parameters.variableValue);
                    if (isNaN(parameters.variableValue)) {
                        value = 0;
                    }
                    if (isNaN(this.storyState[variableName])) {
                        this.storyState[variableName] = 0;
                    }
                    this.storyState[variableName] = Math.round((parseFloat(this.storyState[variableName]) - value) * 100) / 100;
                    if (ACEDriver.testing)
                        console.log(`${padString("REDUCE", 8)}\t>'${variableName}' by ${value} = ${this.storyState[variableName]}`);
                    break;
                }
                case storyMetadata_1.InstructionType.INCREASE: {
                    let variableName = parameters.variableName;
                    let value = parseFloat(parameters.variableValue);
                    if (isNaN(parameters.variableValue)) {
                        value = 0;
                    }
                    if (isNaN(this.storyState[variableName])) {
                        this.storyState[variableName] = 0;
                    }
                    this.storyState[variableName] = Math.round((parseFloat(this.storyState[variableName]) + value) * 100) / 100;
                    if (ACEDriver.testing)
                        console.log(`${padString("INCREASE", 8)}\t>'${variableName}' by ${value} = ${this.storyState[variableName]}`);
                    break;
                }
                case storyMetadata_1.InstructionType.MULTIPLY: {
                    let variableName = parameters.variableName;
                    let value = parseFloat(parameters.variableValue);
                    if (isNaN(parameters.variableValue)) {
                        value = 0;
                    }
                    if (isNaN(this.storyState[variableName])) {
                        this.storyState[variableName] = 0;
                    }
                    this.storyState[variableName] = Math.round((parseFloat(this.storyState[variableName]) * value) * 100) / 100;
                    if (ACEDriver.testing)
                        console.log(`${padString("MULTIPLY", 8)}\t>'${variableName}' by ${value} = ${this.storyState[variableName]}`);
                    break;
                }
                case storyMetadata_1.InstructionType.DIVIDE: {
                    let variableName = parameters.variableName;
                    let value = parseFloat(parameters.variableValue);
                    if (isNaN(parameters.variableValue)) {
                        value = 0;
                    }
                    if (isNaN(this.storyState[variableName])) {
                        this.storyState[variableName] = 0;
                    }
                    this.storyState[variableName] = Math.round((parseFloat(this.storyState[variableName]) / value) * 100) / 100;
                    if (ACEDriver.testing)
                        console.log(`${padString("DIVIDE", 8)}\t>'${variableName}' by ${value} = ${this.storyState[variableName]}`);
                    break;
                }
                case storyMetadata_1.InstructionType.MODULUS: {
                    let variableName = parameters.variableName;
                    let value = parseFloat(parameters.variableValue);
                    if (isNaN(parameters.variableValue)) {
                        value = 0;
                    }
                    if (isNaN(this.storyState[variableName])) {
                        this.storyState[variableName] = 0;
                    }
                    this.storyState[variableName] = Math.round((parseFloat(this.storyState[variableName]) % value) * 100) / 100;
                    if (ACEDriver.testing)
                        console.log(`${padString("MODULUS", 8)}\t>'${variableName}' by ${value} = ${this.storyState[variableName]}`);
                    break;
                }
                case storyMetadata_1.InstructionType.ROLL: {
                    let rollEval = parameters.diceString;
                    this.evaluateDiceRoll(rollEval);
                    if (ACEDriver.testing)
                        console.log(`${padString("ROLL", 8)}\t>'${rollEval}'`);
                    break;
                }
                case storyMetadata_1.InstructionType.REPROMPT: {
                    let repromptMessages = replaceVariables(parameters.message, this.storyState, false)
                        .replace(/\n/g, " ")
                        .replace(/[\s]+/g, " ")
                        .split("||");
                    let selectedReprompt = repromptMessages[Math.floor(Math.random() * repromptMessages.length)];
                    this.stage.appendSceneRepromptForeground(this.audioItemUtil.buildAudioItemsFromSSML(selectedReprompt.replace(/\n/g, ' ').replace(/[\s]+/g, ' '), this.isPollyAsDefault ? this.defaultNarrator : undefined));
                    if (ACEDriver.testing)
                        console.log(`${padString("REPROMPT", 8)}\t>'${selectedReprompt}'`);
                    break;
                }
                case storyMetadata_1.InstructionType.VISUALS: {
                    if (visualAlreadyDefined) {
                        let currentVisuals = this.stage.getStageVisualOptions() || [];
                        currentVisuals[currentVisuals.length - 1] = parameters;
                        this.stage.setStageVisualOptions(currentVisuals);
                    }
                    else {
                        visualAlreadyDefined = true;
                        this.stage.appendStageVisuals(parameters);
                    }
                    break;
                }
                default: {
                    throw new Error("[STORY - SYNTAX ERROR] the story effect is not recognized.\nline number=["
                        + lineNumber + "]\nline content=["
                        + JSON.stringify(directions[lineNumber], null, 4) + "]\n"
                        + "pageID=[" + storyStateHelper_1.StoryStateHelper.getCurrentSceneID(this.storyState) + "]");
                }
            }
            if (isTerminatingDirection || lineNumber == directions.length - 1) {
                const stackExists = this.callStack.callStackExists(this.storyState);
                const addressInStack = this.callStack.addressInStack(this.storyState, instructionAddress);
                if (stackExists && addressInStack && this.storyState.system_instruction_mem && this.storyState.system_instruction_mem[instructionAddress]) {
                    delete this.storyState.system_instruction_mem[instructionAddress];
                }
                break;
            }
        }
        return isTerminatingDirection;
    }
    /**
     * Compute a dice roll given a standard dice string.
     *
     * @param diceString
     */
    evaluateDiceRoll(diceString) {
        let diceRegex = /([\d])d([\d]*)+[k]?([\d]*)/gi;
        let diceMatch = diceRegex.exec(diceString);
        let rollResults = [];
        while (diceMatch != null) {
            let rollResult = 0;
            let diceCount = parseInt(diceMatch[1], 10);
            let faceCount = parseInt(diceMatch[2], 10);
            let selectCount = parseInt(diceMatch[3], 10);
            let rolls = [];
            for (let i = 0; i < diceCount; i++) {
                if (ACEDriver.probabilityOff) {
                    rolls.push((faceCount + 1) / 2);
                }
                else {
                    rolls.push(Math.floor(Math.random() * faceCount) + 1);
                }
            }
            let sumCount = rolls.length;
            if (selectCount) {
                rolls.sort().reverse(); //descending sort
                sumCount = selectCount;
            }
            for (let i = 0; i < sumCount; i++) {
                rollResult += rolls[i];
            }
            rollResults.push(rollResult);
            diceMatch = diceRegex.exec(diceString);
        }
        let diceMatchReplace = diceString.replace(diceRegex, () => {
            return String(rollResults.splice(0, 1)[0]);
        });
        let rollFinalEval = eval(diceMatchReplace);
        if (ACEDriver.debug)
            console.log("[DEBUG] Roll result for the entire dice configuration=[" + diceMatchReplace + "], result=[" + rollFinalEval + "]");
        this.storyState.rollResult = rollFinalEval;
    }
}
exports.ACEDriver = ACEDriver;
ACEDriver.SSML_AUDIO_LIMIT = 5;
ACEDriver.debug = false;
ACEDriver.testing = false;
/**
 * flag this variable to alway run the average value for dice rolls.
 */
ACEDriver.probabilityOff = false;
function replaceVariables(line, eventParams, isCondition) {
    const tokenReplacer = new tokenReplacer_1.TokenReplacer(segmenter_1.SegmenterBuilder.getVariableSegmenter(), eventParams);
    return tokenReplacer.replaceTokens(line, isCondition);
}
// Evalute the given string given the limited context given
function evalInContext(js, context) {
    //# Return the results of the in-line anonymous function we .call with the passed context
    return function () { return eval(js.replace(/\bundefined\b/g, "false")); }.call(context);
}
function check(pre, before, after) {
    let padSize = process.env.ABC_DEBUG_PAD_SIZE || 20;
    if ((before === undefined && after !== undefined) || (before !== undefined && after === undefined)) {
        console.log(`[${padString(pre, padSize)}\t|\t${padString(JSON.stringify(before), padSize)}\t>>>\t${padString(JSON.stringify(after), padSize)}]`);
        return;
    }
    if (after == undefined || after == null) {
        return;
    }
    for (let key of Object.keys(after)) {
        if (typeof after[key] === "object") {
            check(pre + "." + key, before[key], after[key]);
        }
        else {
            if (before[key] !== after[key]) {
                if (pre.length > 0) {
                    console.log(`[${padString(pre + "." + key, padSize)}\t|\t${padString(before[key], padSize)}\t>>>\t${padString(after[key], padSize)}]`);
                }
                else {
                    console.log(`[${padString(key, padSize)}\t|\t${padString(before[key], padSize)}\t>>>\t${padString(after[key], padSize)}]`);
                }
            }
        }
    }
    return;
}
function getStateDiffs(before, after) {
    let stateDiffs = [];
    // check removed items
    for (let key of Object.keys(before)) {
        if (before[key] && after[key] === undefined) {
            stateDiffs.push({
                itemName: key,
                beforeValue: JSON.parse(JSON.stringify(before[key])),
                afterValue: undefined
            });
        }
    }
    for (let key of Object.keys(after)) {
        if (JSON.stringify(after[key]) != JSON.stringify(before[key])) {
            stateDiffs.push({
                itemName: key,
                beforeValue: before[key] ? JSON.parse(JSON.stringify(before[key])) : undefined,
                afterValue: JSON.parse(JSON.stringify(after[key]))
            });
        }
    }
    return stateDiffs;
}
function padString(incomingText, length) {
    let text = String(incomingText);
    let result = text;
    if (text.length < length) {
        for (let i = 0; i <= length - text.length; i++) {
            result += " ";
        }
    }
    else {
        result = "~" + result.substring(text.length - length);
    }
    return result;
}
//# sourceMappingURL=driver.js.map