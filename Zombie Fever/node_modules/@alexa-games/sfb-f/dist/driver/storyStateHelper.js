"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sfb_util_1 = require("@alexa-games/sfb-util");
const BuiltInIntents_1 = require("../bakeUtilities/BuiltInIntents");
class StoryStateHelper {
    static hasStateChanged(beforeState, afterState) {
        return JSON.stringify(beforeState) !== JSON.stringify(afterState);
    }
    /**
     * Set the next scene ID to read as the target scene ID for next ACEDriver run with this Story State.
     *
     * @param sceneID target scene ID to jump to.
     * @param storyState Story state data will be modified as a result of this call
     */
    static jumpToScene(sceneID, storyState) {
        storyState.system_bookmark = sceneID;
        StoryStateHelper.resetAvailableChoices(storyState);
        return;
    }
    /**
     * Get the current scene ID.
     * @param storyState
     */
    static getCurrentSceneID(storyState) {
        if (storyState.system_bookmark) {
            return storyState.system_bookmark;
        }
        return null;
    }
    /**
     * Set the current scene ID to the given value {newSceneID}. Other story state variables are untouched.
     * @param storyState
     */
    static setCurrentSceneID(storyState, newSceneID) {
        storyState.system_bookmark = newSceneID;
    }
    /**
     * Gets the choice history of the current story running.
     *
     * @param storyState
     */
    static getChoiceHistory(storyState) {
        if (storyState.system_choiceHistory) {
            return JSON.parse(JSON.stringify(storyState.system_choiceHistory));
        }
        return [];
    }
    /**
     * Add the newly selected choice to choice history.
     *
     * @param storyState
     */
    static addChoiceHistory(storyState, choiceMade, stateDiff, historySize = 15) {
        if (!storyState.system_choiceHistory) {
            storyState.system_choiceHistory = [];
        }
        let currentSceneID = StoryStateHelper.getCurrentSceneID(storyState);
        if (currentSceneID == null) {
            throw new Error("Cannot make choice from a 'null' scene.");
        }
        let choiceHistoryItem = {
            sourceSceneID: currentSceneID,
            choiceID: choiceMade.id,
            stateDiff: stateDiff
        };
        storyState.system_choiceHistory.push(choiceHistoryItem);
        if (storyState.system_choiceHistory.length > historySize) {
            storyState.system_choiceHistory.splice(0, storyState.system_choiceHistory.length - historySize);
        }
    }
    static resetChoiceHistory(storyState) {
        delete storyState.system_choiceHistory;
    }
    static setChoiceHistory(storyState, choiceHistroy) {
        storyState.system_choiceHistory = choiceHistroy;
    }
    static enqueueAvailableChoice(storyState, choice) {
        if (!storyState.system_branch) {
            storyState.system_branch = {};
            storyState.system_utteranceChoiceMap = {};
        }
        ;
        for (let utterance of choice.utterances) {
            storyState.system_utteranceChoiceMap[utterance] = choice.id;
        }
        storyState.system_branch[choice.id] = choice;
    }
    static getAvailableChoices(storyState) {
        let availableChoices = [];
        if (storyState.system_branch) {
            for (let choiceId of Object.keys(storyState.system_branch)) {
                availableChoices.push(storyState.system_branch[choiceId]);
            }
        }
        return availableChoices;
    }
    static isCustomSlotExpected(storyState, slotName) {
        return storyState.system_expectedSlots && storyState.system_expectedSlots.includes(slotName);
    }
    static addExpectedCustomSlot(storyState, slotName) {
        if (!storyState.system_expectedSlots) {
            storyState.system_expectedSlots = [];
        }
        if (!storyState.system_expectedSlots.includes(slotName)) {
            storyState.system_expectedSlots.push(slotName);
        }
    }
    static clearExpectedCustomSlots(storyState) {
        delete storyState.system_expectedSlots;
    }
    static getChoiceByUserInput(storyState, userInput, _locale) {
        //console.log("Processing userinput: " + JSON.stringify(userInput, null, 4));
        let locale = _locale;
        if (!BuiltInIntents_1.BUILT_IN_INTENT_UTTERANCES[locale] && BuiltInIntents_1.BUILT_IN_INTENT_UTTERANCES[locale.split("-")[0]]) {
            locale = locale.split("-")[0];
        }
        if (storyState.system_branch) {
            let utterance2Choice = {};
            for (let choiceId of Object.keys(storyState.system_branch)) {
                let testingChoice = storyState.system_branch[choiceId];
                for (let utterance of testingChoice.utterances) {
                    if (!storyState.system_utteranceChoiceMap || storyState.system_utteranceChoiceMap[utterance] === choiceId) {
                        utterance2Choice[utterance] = testingChoice;
                    }
                }
            }
            let fuzziedMatch;
            if (userInput.slots && userInput.slots.length > 0) {
                let slotWords = "";
                let slotWordsExact = "";
                for (let slot of userInput.slots) {
                    slotWords += `${slot.name}} `;
                    slotWordsExact += `{${slot.name}} `;
                }
                fuzziedMatch = sfb_util_1.pickBestResponse(slotWords, Object.keys(utterance2Choice)) ||
                    sfb_util_1.pickBestResponse(slotWordsExact, Object.keys(utterance2Choice));
            }
            if (!fuzziedMatch && userInput.value && userInput.value.length > 0) {
                fuzziedMatch = sfb_util_1.pickBestResponse(userInput.value, Object.keys(utterance2Choice));
            }
            if (!fuzziedMatch && userInput.intent && userInput.intent.length > 0) {
                fuzziedMatch = sfb_util_1.pickBestResponse(userInput.intent, Object.keys(utterance2Choice));
            }
            if (!fuzziedMatch && utterance2Choice["*"]) {
                fuzziedMatch = {
                    response: "*"
                };
            }
            if (fuzziedMatch) {
                let matchingUtterance = fuzziedMatch.response;
                let slotRegex = /{([\s\S]+?)(?: as ([\s\S]+?))?}/g;
                const selectedChoice = utterance2Choice[matchingUtterance];
                const siblingUtterances = JSON.stringify(selectedChoice.utterances);
                let slotMatch = slotRegex.exec(siblingUtterances);
                // variable assignment from the utterances
                while (slotMatch != null) {
                    let slotSaveName = slotMatch[2] || slotMatch[1];
                    let abcSlot;
                    if (userInput.slots) {
                        abcSlot = userInput.slots.filter((slot) => {
                            return slot.name == slotSaveName;
                        })[0];
                    }
                    if (abcSlot && StoryStateHelper.isCustomSlotExpected(storyState, slotSaveName)) {
                        storyState[slotSaveName] = abcSlot.value;
                    }
                    else {
                        delete storyState[slotSaveName];
                    }
                    slotMatch = slotRegex.exec(siblingUtterances);
                }
                return selectedChoice;
            }
        }
        return null;
    }
    static resetAvailableChoices(storyState) {
        delete storyState.system_branch;
        delete storyState.system_utteranceChoiceMap;
        delete storyState.system_expectedSlots;
    }
    /**
     * Given the current state of the story, see if the given user input is expected.
     */
    static isInputExpected(storyState, userInput, locale) {
        const selectedChoice = StoryStateHelper.getChoiceByUserInput(storyState, userInput, locale);
        return selectedChoice !== null && !selectedChoice.utterances.includes("*");
    }
    static getSceneIDForRecap(storyState) {
        if (storyState.system_recapSceneID) {
            return storyState.system_recapSceneID;
        }
        return null;
    }
    static setSceneIDForRecap(storyState, recapSceneID) {
        storyState.system_recapSceneID = recapSceneID;
    }
    static clearRecap(storyState) {
        delete storyState.system_recapSceneID;
    }
    static setStoryPaused(storyState, isPaused) {
        storyState.system_isStoryPaused = isPaused;
    }
    static isStoryPaused(storyState) {
        return storyState.system_isStoryPaused;
    }
    static isEndingReached(storyState) {
        return storyState.system_isEndingReached;
    }
    static setEndingReached(storyState, isEndingReached) {
        storyState.system_isEndingReached = isEndingReached;
    }
    static setSelectedChoiceID(storyState, choiceID) {
        storyState.system_selectedChoiceID = choiceID;
    }
    static clearSelectedChoiceID(storyState) {
        delete storyState.system_selectedChoiceID;
    }
    static getSelectedChoiceID(storyState) {
        return storyState.system_selectedChoiceID;
    }
}
exports.StoryStateHelper = StoryStateHelper;
//# sourceMappingURL=storyStateHelper.js.map