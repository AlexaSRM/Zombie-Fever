"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const driverEntity_1 = require("../driver/driverEntity");
const sfb_polly_1 = require("@alexa-games/sfb-polly");
const driver_1 = require("./driver");
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
class AudioItemUtil {
    constructor() {
        this.generatedFiles = {};
    }
    /**
     * Combines consecutive polly audio items in a sequence with same settings into one item.
     *
     * @param _sceneAudio audio item sequence to perform condensing on
     * @param keepScenesSeperate if true polly items the merge is performed per scene; otherwise combine all valid consecutive polly items across all scenes.
     */
    condensePollyItem(_sceneAudio, keepScenesSeperate) {
        let sceneAudio = JSON.parse(JSON.stringify(_sceneAudio));
        let optimizedStageSpeechSequence = [];
        // combine back-to-back polly items sharing same voice property into one.
        let tempItem = undefined;
        let buildingItem = undefined;
        let tempPushed = false;
        let currentlyProcessingSceneID = undefined;
        for (let sceneItem of sceneAudio) {
            const processingNewSceneId = (currentlyProcessingSceneID !== undefined) &&
                (currentlyProcessingSceneID !== sceneItem.sceneID);
            currentlyProcessingSceneID = sceneItem.sceneID;
            if (sceneItem.background.length > 0 || (keepScenesSeperate && processingNewSceneId)) {
                if (tempItem) {
                    if (buildingItem) {
                        tempItem.foreground.push(buildingItem);
                        buildingItem = undefined;
                    }
                    tempPushed = true;
                    optimizedStageSpeechSequence.push(tempItem);
                    tempItem = undefined;
                }
                optimizedStageSpeechSequence.push(sceneItem);
                continue;
            }
            for (let foregroundItem of sceneItem.foreground) {
                if (!tempItem) {
                    tempPushed = false;
                    tempItem = {
                        sceneID: sceneItem.sceneID,
                        foreground: [],
                        background: []
                    };
                }
                if (foregroundItem.type === driverEntity_1.AlexaAudioType.POLLY) {
                    if (buildingItem) {
                        if (this.isEqualSetting(foregroundItem, buildingItem)) {
                            buildingItem.content += ` ${foregroundItem.content}`;
                        }
                        else {
                            tempItem.foreground.push(buildingItem);
                            buildingItem = foregroundItem;
                        }
                    }
                    else {
                        buildingItem = foregroundItem;
                    }
                }
                else {
                    if (buildingItem) {
                        tempItem.foreground.push(buildingItem);
                    }
                    tempItem.foreground.push(foregroundItem);
                    buildingItem = undefined;
                }
            }
        }
        if (buildingItem && tempItem) {
            tempItem.foreground.push(buildingItem);
        }
        if (!tempPushed && tempItem) {
            optimizedStageSpeechSequence.push(tempItem);
        }
        return optimizedStageSpeechSequence;
    }
    /**
     * Given two AudioItems, determines if the mix/modify setting for the audio item is identifcal.
     */
    isEqualSetting(subjectAudio, comparingAudio) {
        const isSameType = subjectAudio.type === comparingAudio.type;
        const hasSameOptions = JSON.stringify(subjectAudio.options) === JSON.stringify(comparingAudio.options);
        return isSameType && hasSameOptions;
    }
    /**
     * Process the given scene audio items, and generate / mix resulting audio files.
     * Returns resulting scene audio items.
     *
     * @param sceneAudioItemList
     */
    async proccessSceneAudioItems(sceneAudioItemList, pollyConfig, audioAccessor) {
        const result = [];
        for (let sceneAudio of sceneAudioItemList) {
            const sceneAudioPromise = new Promise(async (resolve, reject) => {
                try {
                    const processes = [];
                    for (let foregroundAudio of sceneAudio.foreground) {
                        processes.push(this.processAudioItem(foregroundAudio, pollyConfig, audioAccessor));
                    }
                    const processedForeground = (await Promise.all(processes));
                    let primaryBackgroundAudioItem = undefined;
                    for (let backgroundAudio of sceneAudio.background) {
                        if (backgroundAudio.type === driverEntity_1.AlexaAudioType.AUDIO) {
                            // TODO: Loop through and make a whole audio builder out of all the background items
                            // TODO: Right now it only supports one background audio item
                            primaryBackgroundAudioItem = backgroundAudio;
                        }
                    }
                    let fullSceneAudio = processedForeground;
                    if (primaryBackgroundAudioItem && pollyConfig.enabled) {
                        if (!driver_1.ACEDriver.testing || pollyConfig.enabledInPreview) {
                            if (processedForeground.length > 0) {
                                const foregroundAudio = await this.mixdownAudioItems(processedForeground, pollyConfig, audioAccessor, sfb_polly_1.MixMode.CONCATENATE);
                                const util = new sfb_polly_1.PollyUtil(audioAccessor);
                                const foregroundName = path.basename(foregroundAudio.content);
                                const foregroundPath = path.resolve(pollyConfig.workingDir, foregroundName);
                                if (!fs.existsSync(foregroundPath)) {
                                    await audioAccessor.downloadAudio(foregroundAudio.content, pollyConfig.workingDir);
                                }
                                const backgroundDelay = primaryBackgroundAudioItem.delay;
                                if (backgroundDelay < 0) {
                                    foregroundAudio.delay += Math.abs(backgroundDelay);
                                    primaryBackgroundAudioItem.delay = 0;
                                }
                                const foregroundDurationInMillis = await util.calculateMP3Duration(foregroundPath) + foregroundAudio.delay;
                                const combinedAudio = await this.mixdownAudioItems([
                                    foregroundAudio,
                                    primaryBackgroundAudioItem
                                ], pollyConfig, audioAccessor, sfb_polly_1.MixMode.LAYER, foregroundDurationInMillis);
                                fullSceneAudio = [combinedAudio];
                            }
                        }
                    }
                    resolve({
                        foreground: fullSceneAudio,
                        background: [],
                        sceneID: sceneAudio.sceneID
                    });
                }
                catch (err) {
                    reject(err);
                }
            });
            result.push(sceneAudioPromise);
        }
        return await Promise.all(result);
    }
    /**
     * Appropriately process and generated a modified audio if needed.
     * Returns the modified AudioItem.
     *
     * @param audioItem audio item to process
     * @param pollyConfig
     * @param audioAccessor
     * @returns [[AudioItem]] of the resulting modified audio.
     */
    async processAudioItem(audioItem, pollyConfig, audioAccessor) {
        if (!driver_1.ACEDriver.testing || pollyConfig.enabledInPreview) {
            if (audioItem.type === driverEntity_1.AlexaAudioType.AUDIO) {
                // If values are defaults, then don't change the audio file at all and keep it at it's original quality
                if (!pollyConfig.enabled || (audioItem.delay == 0 && audioItem.volume == 1.0)) {
                    return audioItem;
                }
                else {
                    const mixedAudio = await this.mixdownAudioItems([audioItem], pollyConfig, audioAccessor, sfb_polly_1.MixMode.LAYER);
                    return mixedAudio;
                }
            }
            else if (audioItem.type === driverEntity_1.AlexaAudioType.POLLY) {
                if (audioItem.options) {
                    if (pollyConfig.enabled) {
                        const mixedAudio = await this.mixdownAudioItems([audioItem], pollyConfig, audioAccessor, sfb_polly_1.MixMode.LAYER);
                        return mixedAudio;
                    }
                }
            }
            else {
                if (driver_1.ACEDriver.testing && pollyConfig.enabledInPreview) {
                    const previewPollyVoice = pollyConfig.previewPollyVoice || 'Joanna';
                    const simulatorDefaultSSML = `<voice name='${previewPollyVoice}'>${audioItem.content}</voice>`;
                    const textAudioItem = this.buildAudioItemsFromSSML(simulatorDefaultSSML);
                    const mixedAudioItem = await this.mixdownAudioItems(textAudioItem, pollyConfig, audioAccessor, sfb_polly_1.MixMode.LAYER);
                    return mixedAudioItem;
                }
            }
        }
        return audioItem;
    }
    /**
     * Get total count of AudioItems of type [[AlexaAudioType.AUDIO]] in the given SceneAudioItem list.
     */
    getAudioCount(sceneAudioList) {
        const audioCount = sceneAudioList.map((scene) => {
            if (scene.foreground.length > 0) {
                return scene.foreground
                    .map((item) => { return item.type === driverEntity_1.AlexaAudioType.AUDIO ? 1 : 0; })
                    .reduce((prev, curr, i, arr) => {
                    return prev + curr;
                });
            }
            else {
                return 0;
            }
        })
            .reduce((prev, curr, i, arr) => { return prev + curr; });
        return audioCount;
    }
    /**
     * Combine consecutive audio items to achieve the number of audio items of type [[AlexaAudioType.AUDIO]] to the given target.
     *
     * @param upperItemLimit maximum number of audio files
     * @param pollyConfig [[@alexa-games/sfb-polly/DriverPollyConfig]] SFB polly configuration key value map.
     * @param audioAccessor [[@alexa-games/sfb-polly/AudioFileAccessor]] audio file accessor used for downloading, and uploading audio files.
     * @param targetAudioCount number of audio items of type [[AlexaAudioType.AUDIO]] to target for the result.
     * @returns list of resulting audio items.
     */
    async combineConsecutiveAudioItems(sceneAudioItemList, pollyConfig, audioAccessor, targetAudioCount) {
        const result = [];
        const totalAudioCount = this.getAudioCount(sceneAudioItemList);
        const reductionTarget = totalAudioCount - targetAudioCount;
        let reducedCount = 0;
        let mixGroup = [];
        for (let scene of sceneAudioItemList) {
            for (let audioItem of scene.foreground) {
                if (audioItem.type === driverEntity_1.AlexaAudioType.AUDIO && reducedCount < reductionTarget) {
                    mixGroup.push(audioItem);
                    if (mixGroup.length > 1) {
                        reducedCount++;
                    }
                    continue;
                }
                if (mixGroup.length > 1) {
                    const copyGroup = JSON.parse(JSON.stringify(mixGroup));
                    const concatPromise = new Promise(async (resolve) => {
                        const concatenatedAudio = await this.mixdownAudioItems(copyGroup, pollyConfig, audioAccessor, sfb_polly_1.MixMode.CONCATENATE);
                        resolve(concatenatedAudio);
                    });
                    mixGroup = [];
                    result.push(concatPromise);
                }
                result.push(new Promise((resolve) => { resolve(audioItem); }));
            }
        }
        if (mixGroup.length > 0) {
            const copyGroup = JSON.parse(JSON.stringify(mixGroup));
            const concatPromise = new Promise(async (resolve, reject) => {
                try {
                    const concatenatedAudio = await this.mixdownAudioItems(copyGroup, pollyConfig, audioAccessor, sfb_polly_1.MixMode.CONCATENATE);
                    resolve(concatenatedAudio);
                }
                catch (err) {
                    reject(err);
                }
            });
            result.push(concatPromise);
        }
        return await Promise.all(result);
    }
    /**
     * Mixdown collection of audio items into a single audio, then return a resulting AudioItem for the resulting audio file.
     *
     * @param audioItems audio items to process/readjust/edit
     * @param pollyConfig polly configuration defining how [[AlexaAudioType.POLLY]] should be handled
     * @param audioAccessor accessor for downloading, uploading, generating url for denoted audio files.
     * @returns Mixedown AudioItem
     */
    async mixdownAudioItems(audioItems, pollyConfig, audioAccessor, mixMode, trimSpotInMillis = 0) {
        const audioBuilder = new sfb_polly_1.AudioMixer(pollyConfig.FFMPEGLocation, pollyConfig.workingDir, audioAccessor);
        for (let audio of audioItems) {
            const filename = path.basename(audio.content);
            if (audio.type == driverEntity_1.AlexaAudioType.AUDIO) {
                audioBuilder.addAudio({
                    sequenceType: sfb_polly_1.SequenceType.SFX,
                    filename: filename,
                    url: audio.content,
                    delayMs: audio.delay,
                    volume: audio.volume,
                    fadeInDuration: audio.options && audio.options.fadeIn ? parseInt(audio.options.fadeIn) / 1000 : 0,
                    fadeOutDuration: audio.options && audio.options.fadeOut ? parseInt(audio.options.fadeOut) / 1000 : 0,
                    fadeOutTime: audio.options && audio.options.fadeOut ? (trimSpotInMillis - parseInt(audio.options.fadeOut)) / 1000 : 0,
                });
            }
            else if (audio.type == driverEntity_1.AlexaAudioType.POLLY) {
                if (!audio.options) {
                    throw new Error("SFBDriver: Polly is missing required properties 'voice'");
                }
                if (audio.content && audio.content.trim().length > 0) {
                    const pollyAudioPath = await audioBuilder.addPollyItem({
                        name: audio.options.voice,
                        text: audio.content,
                        delayMs: audio.delay,
                        volume: "1.0",
                        rate: audio.options.rate,
                        pitch: audio.options.pitch,
                        engine: audio.options.engine
                    });
                    this.generatedFiles[pollyAudioPath] = true;
                }
            }
        }
        const mixSetting = {
            trim: sfb_polly_1.TrimOption.FIRST,
            mode: mixMode
        };
        if (audioItems[0].options && audioItems[0].options.blend === driverEntity_1.AudioBlendOption.LONGEST) {
            mixSetting.trim = sfb_polly_1.TrimOption.LONGEST;
        }
        const mixedAudioPath = await audioBuilder.mix(mixSetting);
        const mixedAudioURL = await audioAccessor.getAudioURL(path.basename(mixedAudioPath));
        this.generatedFiles[mixedAudioPath] = true;
        return {
            delay: 0,
            type: driverEntity_1.AlexaAudioType.AUDIO,
            content: pollyConfig.dontUploadToS3 ? mixedAudioPath : mixedAudioURL,
            volume: 1.0
        };
    }
    /**
     * Given a string of ssml (supported with voice, audio tags), create an array of Audio Items.
     * @param ssml string of ssml text
     */
    buildAudioItemsFromSSML(ssml, defaultNarrator) {
        let dialogue = ssml.trim();
        let partitioningRegex = /(<audio[ \t]+?src=["'][^><]+?["'][ \t]*?\/>)|(<voice[ \t]+?.+?<\/voice>)|([\s\S]+?)(?=(?:<audio[ \t]+?src=["'][^><]+?["'][ \t]*?\/>)|(?:<voice[ \t]+?.+?<\/voice>)|$)/g;
        let partitionMatch = partitioningRegex.exec(dialogue);
        let audioItems = [];
        while (partitionMatch != null) {
            if (partitionMatch[1] && partitionMatch[1].trim().length > 0) {
                let audioTagParse = /\b(src|volume|delay|blend)=[\"']([\S]+?)[\"']/g;
                let audioTagText = partitionMatch[1];
                let audioTagMatch = audioTagParse.exec(audioTagText);
                let volume = 1.0;
                let delay = 0;
                let content = "";
                let blendOption = driverEntity_1.AudioBlendOption.TRIM;
                while (audioTagMatch != null) {
                    if (!audioTagMatch[2] || audioTagMatch[2].trim().length <= 0) {
                        // skip for no attribute value
                    }
                    else if (audioTagMatch[1].trim() == "src") {
                        content = audioTagMatch[2];
                    }
                    else if (audioTagMatch[1].trim() == "volume") {
                        volume = parseFloat(audioTagMatch[2]);
                    }
                    else if (audioTagMatch[1].trim() == "delay") {
                        delay = parseInt(audioTagMatch[2]);
                    }
                    else if (audioTagMatch[1].trim() == "blend") {
                        blendOption = audioTagMatch[2];
                    }
                    audioTagMatch = audioTagParse.exec(audioTagText);
                }
                audioItems.push({
                    type: driverEntity_1.AlexaAudioType.AUDIO,
                    content: content,
                    volume: volume,
                    delay: delay,
                    options: {
                        blend: blendOption
                    }
                });
            }
            else if (partitionMatch[2] && partitionMatch[2].trim().length > 0) {
                const pollyTagText = partitionMatch[2];
                const contentMatch = /<voice([\s\S]+?)>([\s\S]*?)<\/voice>/g.exec(pollyTagText);
                const voiceHeader = contentMatch[1];
                const content = contentMatch[2];
                let pollyTagParse = /(name|volume|delay|pitch|rate|engine)=[\"']([\S]+?)[\"']/g;
                let pollyTagMatch = pollyTagParse.exec(voiceHeader);
                let name = "";
                let volume = 1.0;
                let delay = 0;
                let rate = "";
                let pitch = "";
                let engine = "";
                while (pollyTagMatch != null) {
                    if (!pollyTagMatch[2] || pollyTagMatch[2].trim().length <= 0) {
                        // skip for no attribute value
                    }
                    else if (pollyTagMatch[1].trim() == "name") {
                        name = pollyTagMatch[2];
                    }
                    else if (pollyTagMatch[1].trim() == "volume") {
                        volume = parseFloat(pollyTagMatch[2]);
                    }
                    else if (pollyTagMatch[1].trim() == "delay") {
                        delay = parseInt(pollyTagMatch[2]);
                    }
                    else if (pollyTagMatch[1].trim() == "pitch") {
                        pitch = pollyTagMatch[2];
                    }
                    else if (pollyTagMatch[1].trim() == "rate") {
                        rate = pollyTagMatch[2];
                    }
                    else if (pollyTagMatch[1].trim() == "engine") {
                        engine = pollyTagMatch[2];
                    }
                    pollyTagMatch = pollyTagParse.exec(voiceHeader);
                }
                audioItems.push({
                    type: driverEntity_1.AlexaAudioType.POLLY,
                    content: content,
                    volume: volume,
                    delay: delay,
                    options: {
                        pitch: pitch,
                        rate: rate,
                        voice: name,
                        engine: engine
                    }
                });
            }
            else if (defaultNarrator) {
                if (partitionMatch[3].trim().length > 0) {
                    audioItems.push({
                        type: driverEntity_1.AlexaAudioType.POLLY,
                        content: partitionMatch[3],
                        volume: parseFloat(defaultNarrator.volume),
                        delay: 0,
                        options: {
                            pitch: defaultNarrator.pitch,
                            rate: defaultNarrator.rate,
                            voice: defaultNarrator.name,
                            engine: defaultNarrator.engine || ""
                        }
                    });
                }
            }
            else {
                if (partitionMatch[3].trim().length > 0) {
                    audioItems.push({
                        type: driverEntity_1.AlexaAudioType.TEXT,
                        content: partitionMatch[3],
                        volume: 1.0,
                        delay: 0
                    });
                }
            }
            partitionMatch = partitioningRegex.exec(dialogue);
        }
        return audioItems;
    }
    generateSSMLText(sceneAudioItemList, pollyConfig) {
        let finalSSML = "";
        for (let audioItem of sceneAudioItemList) {
            for (let foregroundAudio of audioItem.foreground) {
                let ssml = "";
                // Build the foreground audio up into a single ssml tag
                if (!driver_1.ACEDriver.testing || pollyConfig.enabledInPreview) {
                    if (foregroundAudio.type === driverEntity_1.AlexaAudioType.AUDIO) {
                        ssml = `<audio src='${foregroundAudio.content}' />`;
                    }
                    else if (foregroundAudio.type === driverEntity_1.AlexaAudioType.POLLY) {
                        if (foregroundAudio.options) {
                            const voiceOpenTag = `<voice name='${foregroundAudio.options.voice}'>`;
                            const voiceCloseTag = `</voice>`;
                            const hasPitchChange = !!(foregroundAudio.options.pitch && foregroundAudio.options.pitch.length > 0 && foregroundAudio.options.pitch !== "+0%" && foregroundAudio.options.pitch !== "-0%");
                            const hasRateChange = !!(foregroundAudio.options.rate && foregroundAudio.options.rate.length > 0 && foregroundAudio.options.rate !== "100%");
                            const hasVolumeChange = !!(foregroundAudio.options.volume && foregroundAudio.options.volume.length > 0 && foregroundAudio.options.volume.trim() !== "1.0");
                            let prosodyOpenTag = "";
                            let prosodyCloseTag = "";
                            if (hasPitchChange || hasRateChange || hasVolumeChange) {
                                let prosodyOptions = "";
                                if (hasPitchChange) {
                                    prosodyOptions += `pitch='${foregroundAudio.options.pitch}'`;
                                }
                                if (hasRateChange) {
                                    prosodyOptions += ` rate='${foregroundAudio.options.rate}'`;
                                }
                                if (hasVolumeChange) {
                                    prosodyOptions += ` volume='${foregroundAudio.options.volume}'`;
                                }
                                prosodyOpenTag += `<prosody ${prosodyOptions}>`;
                                prosodyCloseTag = `</prosody>`;
                            }
                            ssml = `${voiceOpenTag}${prosodyOpenTag}${foregroundAudio.content}${prosodyCloseTag}${voiceCloseTag}`;
                        }
                        else {
                            ssml = ` ${foregroundAudio.content}`;
                        }
                    }
                    else {
                        ssml = ` ${foregroundAudio.content}`;
                    }
                }
                else {
                    // We are testing, so just return something that will not be valid ssml
                    if (foregroundAudio.type === driverEntity_1.AlexaAudioType.AUDIO) {
                        ssml = `<audio src='${foregroundAudio.content}'/>`;
                    }
                    else if (foregroundAudio.type === driverEntity_1.AlexaAudioType.POLLY) {
                        if (foregroundAudio.options) {
                            ssml = `<voice name='${foregroundAudio.options.voice}'>${foregroundAudio.content}</voice>`;
                        }
                        else {
                            ssml = `(POLLY:name=ERROR_NO_POLLY_NAME_SET text=${foregroundAudio.content} delayMs=${foregroundAudio.delay} volume=${foregroundAudio.volume})`;
                        }
                    }
                    else {
                        ssml = ` ${foregroundAudio.content}`;
                    }
                }
                finalSSML += ssml;
            }
        }
        return finalSSML;
    }
    /**
     * Upload all files generated by this instance of AudioMixer to a cache/storage using the uploadAudio() of its [[AudioFileAccessor]].
     */
    async uploadGeneratedFiles(audioAccessor, workingDir) {
        if (Object.keys(this.generatedFiles).length > 0) {
            const uploadTasks = Object.keys(this.generatedFiles)
                .filter((filePath) => fs.existsSync(filePath))
                .map((filePath) => {
                return audioAccessor.uploadAudio(path.basename(filePath), workingDir);
            });
            await Promise.all(uploadTasks);
        }
    }
}
exports.AudioItemUtil = AudioItemUtil;
//# sourceMappingURL=AudioItemUtil.js.map