import { Choice, UserInput, ChoiceHistoryItem, StateDiffItem } from './driverEntity';
export declare class StoryStateHelper {
    static hasStateChanged(beforeState: {
        [key: string]: any;
    }, afterState: {
        [key: string]: any;
    }): boolean;
    /**
     * Set the next scene ID to read as the target scene ID for next ACEDriver run with this Story State.
     *
     * @param sceneID target scene ID to jump to.
     * @param storyState Story state data will be modified as a result of this call
     */
    static jumpToScene(sceneID: string, storyState: {
        [key: string]: any;
    }): void;
    /**
     * Get the current scene ID.
     * @param storyState
     */
    static getCurrentSceneID(storyState: {
        [key: string]: any;
    }): string | null;
    /**
     * Set the current scene ID to the given value {newSceneID}. Other story state variables are untouched.
     * @param storyState
     */
    static setCurrentSceneID(storyState: {
        [key: string]: any;
    }, newSceneID: string): void;
    /**
     * Gets the choice history of the current story running.
     *
     * @param storyState
     */
    static getChoiceHistory(storyState: {
        [key: string]: any;
    }): ChoiceHistoryItem[];
    /**
     * Add the newly selected choice to choice history.
     *
     * @param storyState
     */
    static addChoiceHistory(storyState: {
        [key: string]: any;
    }, choiceMade: Choice, stateDiff: StateDiffItem[], historySize?: number): void;
    static resetChoiceHistory(storyState: {
        [key: string]: any;
    }): void;
    static setChoiceHistory(storyState: {
        [key: string]: any;
    }, choiceHistroy: ChoiceHistoryItem[]): void;
    static enqueueAvailableChoice(storyState: {
        [key: string]: any;
    }, choice: Choice): void;
    static getAvailableChoices(storyState: {
        [key: string]: any;
    }): Choice[];
    static isCustomSlotExpected(storyState: {
        [key: string]: any;
    }, slotName: string): any;
    static addExpectedCustomSlot(storyState: {
        [key: string]: any;
    }, slotName: string): void;
    static clearExpectedCustomSlots(storyState: {
        [key: string]: any;
    }): void;
    static getChoiceByUserInput(storyState: {
        [key: string]: any;
    }, userInput: UserInput, _locale: string): Choice | null;
    static resetAvailableChoices(storyState: {
        [key: string]: any;
    }): void;
    /**
     * Given the current state of the story, see if the given user input is expected.
     */
    static isInputExpected(storyState: {
        [key: string]: any;
    }, userInput: UserInput, locale: string): boolean;
    static getSceneIDForRecap(storyState: {
        [key: string]: any;
    }): string | null;
    static setSceneIDForRecap(storyState: {
        [key: string]: any;
    }, recapSceneID: string): void;
    static clearRecap(storyState: {
        [key: string]: any;
    }): void;
    static setStoryPaused(storyState: {
        [key: string]: any;
    }, isPaused: boolean): void;
    static isStoryPaused(storyState: {
        [key: string]: any;
    }): any;
    static isEndingReached(storyState: {
        [key: string]: any;
    }): boolean;
    static setEndingReached(storyState: {
        [key: string]: any;
    }, isEndingReached: boolean): void;
    static setSelectedChoiceID(storyState: {
        [key: string]: any;
    }, choiceID: string): void;
    static clearSelectedChoiceID(storyState: {
        [key: string]: any;
    }): void;
    static getSelectedChoiceID(storyState: {
        [key: string]: any;
    }): any;
}
