{"version":3,"file":"storyStateHelper.js","sourceRoot":"","sources":["../../driver/storyStateHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import { pickBestResponse } from '@alexa-games/sfb-util';\n\nimport { Choice, UserInput, ChoiceHistoryItem, StateDiffItem, Slot } from './driverEntity';\n\nimport { BUILT_IN_INTENT_UTTERANCES } from '../bakeUtilities/BuiltInIntents';\n\nexport class StoryStateHelper {\n    public static hasStateChanged(beforeState: {[key: string]: any}, afterState: {[key: string]: any}): boolean {\n        return JSON.stringify(beforeState) !== JSON.stringify(afterState);\n    }\n\n    /**\n     * Set the next scene ID to read as the target scene ID for next ACEDriver run with this Story State.\n     * \n     * @param sceneID target scene ID to jump to.\n     * @param storyState Story state data will be modified as a result of this call\n     */\n    public static jumpToScene(sceneID: string, storyState: {[key: string]: any}): void {\n        storyState.system_bookmark = sceneID;\n        StoryStateHelper.resetAvailableChoices(storyState);\n        return;\n    }\n\n    /**\n     * Get the current scene ID.\n     * @param storyState \n     */\n    public static getCurrentSceneID(storyState: {[key: string]: any}): string | null{\n        if (storyState.system_bookmark) {\n            return storyState.system_bookmark;\n        }\n        \n        return null;\n    }\n\n    /**\n     * Set the current scene ID to the given value {newSceneID}. Other story state variables are untouched.\n     * @param storyState \n     */\n    public static setCurrentSceneID(storyState: {[key: string]: any}, newSceneID: string): void {\n        storyState.system_bookmark = newSceneID;\n    }\n\n    /**\n     * Gets the choice history of the current story running.\n     *\n     * @param storyState \n     */\n    public static getChoiceHistory(storyState: {[key: string]: any}): ChoiceHistoryItem[] {\n        if (storyState.system_choiceHistory) {\n            return JSON.parse(JSON.stringify(storyState.system_choiceHistory));\n        }\n        return [];\n    }\n\n    /**\n     * Add the newly selected choice to choice history.\n     *\n     * @param storyState \n     */\n    public static addChoiceHistory(storyState: {[key: string]: any}, choiceMade: Choice, stateDiff: StateDiffItem[], historySize: number = 15): void {\n        if (!storyState.system_choiceHistory) {\n            storyState.system_choiceHistory = [];\n        }\n\n        let currentSceneID: string | null = StoryStateHelper.getCurrentSceneID(storyState);\n\n        if (currentSceneID == null) {\n            throw new Error(\"Cannot make choice from a 'null' scene.\")\n        }\n\n        let choiceHistoryItem : ChoiceHistoryItem = {\n            sourceSceneID: currentSceneID,\n            choiceID: choiceMade.id,\n            stateDiff: stateDiff\n        }\n\n        storyState.system_choiceHistory.push(choiceHistoryItem);\n        \n        if(storyState.system_choiceHistory.length > historySize) {\n            storyState.system_choiceHistory.splice(0 ,storyState.system_choiceHistory.length - historySize);\n        }\n    }\n\n    public static resetChoiceHistory(storyState: {[key: string]: any}): void {\n        delete storyState.system_choiceHistory;\n    }\n\n    public static setChoiceHistory(storyState: {[key: string]: any}, choiceHistroy: ChoiceHistoryItem[]): void {\n        storyState.system_choiceHistory = choiceHistroy;\n    }\n\n    public static enqueueAvailableChoice(storyState: {[key: string]: any}, choice: Choice): void {\n        if (!storyState.system_branch) {\n            storyState.system_branch = {\n            }\n            storyState.system_utteranceChoiceMap = {\n\n            }\n        };\n\n        for (let utterance of choice.utterances) {\n            storyState.system_utteranceChoiceMap[utterance] = choice.id;\n        }\n\n        storyState.system_branch[choice.id] = choice;\n    }\n\n    public static getAvailableChoices(storyState: {[key: string]: any}): Choice[] { \n        let availableChoices: Choice[] = [];\n        if (storyState.system_branch) {\n            for (let choiceId of Object.keys(storyState.system_branch)) {\n                availableChoices.push(storyState.system_branch[choiceId]);\n            }\n        }\n        \n        return availableChoices;\n    }\n\n    public static isCustomSlotExpected(storyState: {[key: string]: any}, slotName: string) {\n        return storyState.system_expectedSlots && storyState.system_expectedSlots.includes(slotName);\n    }\n\n    public static addExpectedCustomSlot(storyState: {[key: string]: any}, slotName: string) {\n        if (!storyState.system_expectedSlots) {\n            storyState.system_expectedSlots = [];\n        }\n\n        if (!storyState.system_expectedSlots.includes(slotName)) {\n            storyState.system_expectedSlots.push(slotName);\n        }\n    }\n\n    public static clearExpectedCustomSlots(storyState: {[key: string]: any}) {\n        delete storyState.system_expectedSlots;\n    }\n\n    public static getChoiceByUserInput(storyState: {[key: string]: any}, userInput: UserInput, _locale: string): Choice | null {\n        //console.log(\"Processing userinput: \" + JSON.stringify(userInput, null, 4));\n        let locale: string = _locale;\n        if (!BUILT_IN_INTENT_UTTERANCES[locale] && BUILT_IN_INTENT_UTTERANCES[locale.split(\"-\")[0]]) {\n            locale = locale.split(\"-\")[0];\n        }\n\n        if (storyState.system_branch) {\n            let utterance2Choice: {[key:string]: Choice} = {};\n\n            for (let choiceId of Object.keys(storyState.system_branch)) {\n                \n                let testingChoice: Choice = storyState.system_branch[choiceId];\n\n                for (let utterance of testingChoice.utterances) {\n                    if (!storyState.system_utteranceChoiceMap || storyState.system_utteranceChoiceMap[utterance] === choiceId) {\n                        utterance2Choice[utterance] = testingChoice;\n                    }\n                }\n            }\n\n            let fuzziedMatch: any;\n    \n            if (userInput.slots && userInput.slots.length > 0) {\n                let slotWords: string = \"\";\n                let slotWordsExact: string = \"\";\n\n                for (let slot of userInput.slots) {\n                    slotWords += `${slot.name}} `;\n                    slotWordsExact += `{${slot.name}} `;\n                }\n                \n                fuzziedMatch = pickBestResponse(slotWords, Object.keys(utterance2Choice)) ||\n                    pickBestResponse(slotWordsExact, Object.keys(utterance2Choice));\n                    \n            }\n\n            if (!fuzziedMatch && userInput.value && userInput.value.length > 0) {\n                fuzziedMatch = pickBestResponse(userInput.value, Object.keys(utterance2Choice));\n            }\n\n            if (!fuzziedMatch && userInput.intent && userInput.intent.length > 0) {\n                fuzziedMatch = pickBestResponse(userInput.intent, Object.keys(utterance2Choice));\n            }\n\n            if (!fuzziedMatch && utterance2Choice[\"*\"]) {\n                fuzziedMatch = {\n                    response: \"*\"\n                }\n            }\n\n            if (fuzziedMatch) {\n                let matchingUtterance: string = fuzziedMatch.response;\n                let slotRegex: RegExp = /{([\\s\\S]+?)(?: as ([\\s\\S]+?))?}/g;\n                \n                const selectedChoice = utterance2Choice[matchingUtterance];\n                const siblingUtterances = JSON.stringify(selectedChoice.utterances);\n                let slotMatch: any = slotRegex.exec(siblingUtterances);\n                // variable assignment from the utterances\n                while (slotMatch != null) {\n                    let slotSaveName: string = slotMatch[2] || slotMatch[1];\n\n                    let abcSlot: Slot | undefined;\n\n                    if (userInput.slots) {\n                        abcSlot = userInput.slots.filter((slot: Slot) => {\n                            return slot.name == slotSaveName;\n                        })[0];\n                    }\n\n                    if (abcSlot && StoryStateHelper.isCustomSlotExpected(storyState, slotSaveName)) {\n                        storyState[slotSaveName] = abcSlot.value;\n                    } else {\n                        delete storyState[slotSaveName];\n                    }\n\n                    slotMatch = slotRegex.exec(siblingUtterances);\n                }\n\n                return selectedChoice;\n            }\n        }\n\n        return null;\n    }\n\n    public static resetAvailableChoices(storyState: {[key: string]: any}): void {\n        delete storyState.system_branch;\n        delete storyState.system_utteranceChoiceMap;\n        delete storyState.system_expectedSlots;\n    }\n\n    /**\n     * Given the current state of the story, see if the given user input is expected.\n     */\n    public static isInputExpected(storyState: {[key: string]: any}, userInput: UserInput, locale: string): boolean {\n        const selectedChoice = StoryStateHelper.getChoiceByUserInput(storyState, userInput, locale);\n\n        return selectedChoice !== null && !selectedChoice.utterances.includes(\"*\");\n    }\n\n    public static getSceneIDForRecap(storyState: {[key: string]: any}): string | null {\n        if (storyState.system_recapSceneID) {\n            return storyState.system_recapSceneID;\n        }\n\n        return null;\n    }\n\n    public static setSceneIDForRecap(storyState: {[key: string]: any}, recapSceneID: string) {\n        storyState.system_recapSceneID = recapSceneID;\n    }\n\n    public static clearRecap(storyState:  {[key: string]: any}) {\n        delete storyState.system_recapSceneID;\n    }\n\n    public static setStoryPaused(storyState: {[key: string]: any}, isPaused: boolean) {\n        storyState.system_isStoryPaused = isPaused;\n    }\n\n    public static isStoryPaused(storyState: {[key: string]: any}) {\n        return storyState.system_isStoryPaused;\n    }\n\n    public static isEndingReached(storyState: {[key: string]: any}): boolean {\n        return storyState.system_isEndingReached;\n    }\n\n    public static setEndingReached(storyState: {[key: string]: any}, isEndingReached: boolean) {\n        storyState.system_isEndingReached = isEndingReached;\n    }\n\n    public static setSelectedChoiceID(storyState: {[key: string]: any}, choiceID: string) {\n        storyState.system_selectedChoiceID = choiceID;\n    }\n    \n    public static clearSelectedChoiceID(storyState: {[key: string]: any}): void {\n        delete storyState.system_selectedChoiceID;\n    }\n    \n    public static getSelectedChoiceID(storyState: {[key: string]: any}) {\n        return storyState.system_selectedChoiceID;\n    }\n}"]}