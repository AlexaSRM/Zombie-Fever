{"version":3,"file":"segmenter.js","sourceRoot":"","sources":["../../transformers/segmenter.ts"],"names":[],"mappings":"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","sourcesContent":["\n\nexport enum SegmentType {\n    /**\n     * Stuff in between other types of segments\n     */\n    PlainText,\n\n    /**\n     * Replaced with the value of a variable\n     */\n    Variable,\n\n    /**\n     * Replaced with the value of a snippet\n     */\n    Snippet,\n\n    /**\n     * An SSML/XML style element \n     */\n    Element,\n\n    /**\n     * Segment has a open bracket, but no closing bracket.\n     */\n    Error\n}\n\nexport interface Segment {\n    /**\n     * Value of the segment. \n     */\n    value: string;\n\n    /**\n     * Segment type\n     */\n    type: SegmentType;\n\n    /**\n     * Original segment value. This will be the same as value for plain text and Element, but will include brackets\n     * for Variable and Snippet.\n     */\n    original: string;\n}\n\nexport interface SegmenterConfig {\n    /**\n     * Bracket pair that define a segment. For example: {}, or [], or <>\n     */\n    brackets: string;\n\n    /**\n     * Type of segment defined by the specified bracket pair\n     */\n    type: SegmentType;\n\n    /**\n     * Whether to keep the brackets on the resulting value. True will preserve the\n     * brackets, false will remove them.\n     */\n    preserve: boolean;\n}\n\nexport class Segmenter {\n\n    private readonly openBrackets: string;\n    private readonly closeBrackets: string;\n\n    constructor(private readonly config: SegmenterConfig[]) {\n        this.openBrackets = config.map((c) => c.brackets[0]).join('');\n        this.closeBrackets = config.map((c) => c.brackets[1]).join('');\n    }\n\n    /**\n     * Returns an array of segments categorized by type.\n     * @param value String to segment\n     */\n    public parse(value: string): Segment[] {\n        const result: Segment[] = [];\n    \n        if (!value) {\n            return result; \n        }\n    \n        let currType = SegmentType.PlainText;\n        let currBracket = '';\n        let start = 0;\n    \n        let bracketCount = 0;\n\n        for (let i = 0; i < value.length; i++) {\n            let ch = value[i];\n            if (bracketCount > 0) {\n                // Check for close bracket and check that it pairs up with the open bracket found earlier\n                const closeBracketIndex = this.closeBrackets.indexOf(ch);\n                if (closeBracketIndex >= 0 && currBracket === this.openBrackets[closeBracketIndex]) {\n                    bracketCount--;\n                    if (bracketCount === 0) {\n                        result.push(this.makeSegment(value, start, i + 1, currType));\n                        start = i + 1;\n                        currBracket = '';\n\n                        // Switch back to plain text.\n                        currType = SegmentType.PlainText;\n                    }\n                } else if (currBracket === ch) {\n                    bracketCount++;\n                }\n            } else {\n                const newType = this.getSegmentTypeFromCharacter(ch);\n                if (newType !== SegmentType.PlainText) {\n                    // Found open bracket, note it down.\n                    currBracket = ch;\n                    bracketCount++;\n\n                    if (start < i) {\n                        result.push(this.makeSegment(value, start, i, currType));\n                        start = i;\n                    }\n\n                    currType = newType;\n                }\n            } \n        }\n    \n        if (start < value.length) {\n            // Anything left at the end of the string is recorded as and error since a close\n            // bracket must be missing.\n            if (currType !== SegmentType.PlainText) {\n                currType = SegmentType.Error;\n            }\n\n            result.push(this.makeSegment(value, start, value.length, currType));\n        }\n\n        return result;\n    }\n\n    private getSegmentTypeFromCharacter(ch: string): SegmentType {\n        const index = this.openBrackets.indexOf(ch);\n        if (index < 0) {\n            return SegmentType.PlainText;\n        }\n        return this.config[index].type;\n    }\n\n    private makeSegment(wholeString: string, start: number, end: number, type: SegmentType): Segment {\n        const original = wholeString.substring(start, end);\n        let value = original;\n\n        const seg = this.config.find((c) => { return c.type === type });\n\n        if (seg && !seg.preserve) {\n            // Trim the brackets\n            if (original.length >= 2) {\n                value = original.substring(1, original.length - 1);\n            }\n        }\n\n        return {\n            type,\n            value,\n            original\n        }\n    }\n}\n\nexport class SegmenterBuilder {\n    public static getVariableSegmenter() {\n        return new Segmenter([\n            {\n                brackets: '{}',\n                preserve: false,\n                type: SegmentType.Variable\n            }\n        ]);\n    }\n\n    public static getAllSegmenter() {\n        return new Segmenter([\n            {\n                brackets: '{}',\n                preserve: false,\n                type: SegmentType.Variable\n            },\n            {\n                brackets: '[]',\n                preserve: false,\n                type: SegmentType.Snippet\n            },\n            {\n                brackets: '<>',\n                preserve: true,\n                type: SegmentType.Element\n            }\n        ]);\n    }\n}"]}