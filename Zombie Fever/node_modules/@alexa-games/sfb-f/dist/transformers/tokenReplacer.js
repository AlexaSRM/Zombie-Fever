"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const segmenter_1 = require("./segmenter");
class TokenReplacer {
    constructor(segmenter, data) {
        this.segmenter = segmenter;
        this.data = data;
    }
    /**
     * Replaces tokens in the supplied line with values from class instance data structure.
     * @param line Line to substitute special segments.
     * @param isCondition True will cause non-numbers for single part tokens to be returned quoted.
     */
    replaceTokens(line, isCondition = true, depth = 0) {
        let result = '';
        const resolveCache = {};
        const segments = this.segmenter.parse(line);
        for (let segment of segments) {
            switch (segment.type) {
                case segmenter_1.SegmentType.PlainText:
                case segmenter_1.SegmentType.Error:
                case segmenter_1.SegmentType.Snippet:
                    result += segment.original;
                    break;
                case segmenter_1.SegmentType.Variable:
                    result += this.resolveVariable(resolveCache, segment.value, isCondition, depth);
                    break;
            }
        }
        return result.toString();
    }
    resolveVariable(resolveCache, key, isCondition, depth) {
        let value = resolveCache[key];
        if (value) {
            return value;
        }
        value = this.resolveVariableBase(key, isCondition, depth);
        resolveCache[key] = value;
        return value;
    }
    resolveVariableBase(key, isCondition, depth) {
        // Remove single quotes from throughout the key.
        key = key.replace(/'/g, '');
        if (depth < 10 && key.indexOf('{') >= 0) {
            key = this.replaceTokens(key, false, depth + 1);
        }
        const splitKey = key.split('.');
        let value = this.data;
        for (let i = 0; i < splitKey.length; i++) {
            value = value[splitKey[i]];
            if (value === undefined) {
                if (i === 0) {
                    // Current convention maps undefined single-token and first token
                    // variables values to 'false'. TODO: Ask Ezra about this
                    value = false;
                }
                break;
            }
        }
        if (splitKey.length === 1 && isCondition && value && isNaN(value)) {
            // If our single-token variable value is not a number, and is a condition, then
            // return it in single quotes. Inline code (in the story file) cannot create
            // complex data types, so not treating dotted notation specially when used in 
            // a condition since that is by definition inline
            value = `'${value.replace(/'/g, "\\'")}'`;
        }
        if (value === undefined || value === null) {
            return 'undefined';
        }
        return value.toString();
    }
}
exports.TokenReplacer = TokenReplacer;
//# sourceMappingURL=tokenReplacer.js.map