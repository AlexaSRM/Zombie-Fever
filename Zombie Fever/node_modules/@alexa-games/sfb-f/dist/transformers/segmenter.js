"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var SegmentType;
(function (SegmentType) {
    /**
     * Stuff in between other types of segments
     */
    SegmentType[SegmentType["PlainText"] = 0] = "PlainText";
    /**
     * Replaced with the value of a variable
     */
    SegmentType[SegmentType["Variable"] = 1] = "Variable";
    /**
     * Replaced with the value of a snippet
     */
    SegmentType[SegmentType["Snippet"] = 2] = "Snippet";
    /**
     * An SSML/XML style element
     */
    SegmentType[SegmentType["Element"] = 3] = "Element";
    /**
     * Segment has a open bracket, but no closing bracket.
     */
    SegmentType[SegmentType["Error"] = 4] = "Error";
})(SegmentType = exports.SegmentType || (exports.SegmentType = {}));
class Segmenter {
    constructor(config) {
        this.config = config;
        this.openBrackets = config.map((c) => c.brackets[0]).join('');
        this.closeBrackets = config.map((c) => c.brackets[1]).join('');
    }
    /**
     * Returns an array of segments categorized by type.
     * @param value String to segment
     */
    parse(value) {
        const result = [];
        if (!value) {
            return result;
        }
        let currType = SegmentType.PlainText;
        let currBracket = '';
        let start = 0;
        let bracketCount = 0;
        for (let i = 0; i < value.length; i++) {
            let ch = value[i];
            if (bracketCount > 0) {
                // Check for close bracket and check that it pairs up with the open bracket found earlier
                const closeBracketIndex = this.closeBrackets.indexOf(ch);
                if (closeBracketIndex >= 0 && currBracket === this.openBrackets[closeBracketIndex]) {
                    bracketCount--;
                    if (bracketCount === 0) {
                        result.push(this.makeSegment(value, start, i + 1, currType));
                        start = i + 1;
                        currBracket = '';
                        // Switch back to plain text.
                        currType = SegmentType.PlainText;
                    }
                }
                else if (currBracket === ch) {
                    bracketCount++;
                }
            }
            else {
                const newType = this.getSegmentTypeFromCharacter(ch);
                if (newType !== SegmentType.PlainText) {
                    // Found open bracket, note it down.
                    currBracket = ch;
                    bracketCount++;
                    if (start < i) {
                        result.push(this.makeSegment(value, start, i, currType));
                        start = i;
                    }
                    currType = newType;
                }
            }
        }
        if (start < value.length) {
            // Anything left at the end of the string is recorded as and error since a close
            // bracket must be missing.
            if (currType !== SegmentType.PlainText) {
                currType = SegmentType.Error;
            }
            result.push(this.makeSegment(value, start, value.length, currType));
        }
        return result;
    }
    getSegmentTypeFromCharacter(ch) {
        const index = this.openBrackets.indexOf(ch);
        if (index < 0) {
            return SegmentType.PlainText;
        }
        return this.config[index].type;
    }
    makeSegment(wholeString, start, end, type) {
        const original = wholeString.substring(start, end);
        let value = original;
        const seg = this.config.find((c) => { return c.type === type; });
        if (seg && !seg.preserve) {
            // Trim the brackets
            if (original.length >= 2) {
                value = original.substring(1, original.length - 1);
            }
        }
        return {
            type,
            value,
            original
        };
    }
}
exports.Segmenter = Segmenter;
class SegmenterBuilder {
    static getVariableSegmenter() {
        return new Segmenter([
            {
                brackets: '{}',
                preserve: false,
                type: SegmentType.Variable
            }
        ]);
    }
    static getAllSegmenter() {
        return new Segmenter([
            {
                brackets: '{}',
                preserve: false,
                type: SegmentType.Variable
            },
            {
                brackets: '[]',
                preserve: false,
                type: SegmentType.Snippet
            },
            {
                brackets: '<>',
                preserve: true,
                type: SegmentType.Element
            }
        ]);
    }
}
exports.SegmenterBuilder = SegmenterBuilder;
//# sourceMappingURL=segmenter.js.map