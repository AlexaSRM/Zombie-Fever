"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const storyMetadata_1 = require("../../story/storyMetadata");
const crypto_1 = require("crypto");
/**
 * Creates a string ID for each chunk of localizable strings, and replaces them.
 */
class LocalizationExtension {
    constructor(locale, languageString, overwrite = false, srcLocale = "en-US") {
        this.locale = locale;
        this.languageString = languageString;
        this.overwrite = overwrite;
        this.srcLocale = srcLocale;
    }
    async extendSourceContent(sourceHelper) {
    }
    async extendImportedContent(metadataHelper) {
        const originScenes = metadataHelper.getAllScenes();
        let srcLocaleStrings = {};
        let resultingStrings = {};
        for (let scene of originScenes) {
            for (let content of scene.contents) {
                // check narration strings
                if (content.narration && content.narration.trim().length > 0) {
                    const narration = content.narration.trim();
                    const stringId = `${scene.id}.narration`;
                    this.updateLanguageString(stringId, narration, srcLocaleStrings, resultingStrings);
                    // replace with localized string
                    content.narration = resultingStrings[stringId];
                }
                // check for utterance strings
                if (content.sceneDirections && content.sceneDirections.length > 0) {
                    for (let direction of content.sceneDirections) {
                        if (direction.directionType === storyMetadata_1.InstructionType.CHOICE) {
                            const utterances = direction.parameters.utterances;
                            const replacingUtterances = [];
                            for (let utterance of utterances) {
                                const stringId = `utterance-${utterance}`;
                                this.updateLanguageString(stringId, utterance, srcLocaleStrings, resultingStrings);
                                // replace with localized string
                                replacingUtterances.push(resultingStrings[stringId]);
                            }
                            direction.parameters.utterances = replacingUtterances;
                        }
                        if (direction.directionType === storyMetadata_1.InstructionType.REPROMPT || direction.directionType === storyMetadata_1.InstructionType.RECAP) {
                            const message = direction.parameters.message.trim();
                            const stringId = `${scene.id}.${direction.directionType}`;
                            this.updateLanguageString(stringId, message, srcLocaleStrings, resultingStrings);
                            // replace with localized string
                            direction.parameters.message = resultingStrings[stringId];
                        }
                    }
                }
            }
        }
        if (!this.languageString[this.locale]) {
            this.languageString[this.locale] = {
                translation: {}
            };
        }
        this.languageString[this.locale].translation = resultingStrings;
        metadataHelper.setAllScenes(originScenes);
    }
    getLocalizedStringsObject() {
        return this.languageString;
    }
    updateLanguageString(stringId, stringValue, sourceLanguages, currentLanguages) {
        const stringHash = crypto_1.createHash('md5').update(stringValue.replace(/[\s]+/g, " ")).digest('hex');
        const existingSourceString = this.languageString[this.srcLocale] && this.languageString[this.srcLocale].translation ?
            this.languageString[this.srcLocale].translation[stringId]
            : undefined;
        const languageStringHash = existingSourceString ? crypto_1.createHash('md5').update(existingSourceString.replace(/[\s]+/g, " ")).digest('hex') : undefined;
        if (languageStringHash && languageStringHash !== stringHash) {
            // Source content changed since last languageString freeze.
            if (this.overwrite) {
                sourceLanguages[stringId] = stringValue;
            }
            else {
                sourceLanguages[stringId] = existingSourceString;
            }
        }
        else if (!languageStringHash) {
            // New string id for Source content added
            sourceLanguages[stringId] = stringValue;
        }
        else {
            sourceLanguages[stringId] = existingSourceString;
        }
        if (this.locale != this.srcLocale && this.languageString[this.locale] && this.languageString[this.locale].translation[stringId]) {
            // non-source locale strings should not be updated since we don't know if the translation has already occured on the file.
            currentLanguages[stringId] = this.languageString[this.locale].translation[stringId];
        }
        if (!currentLanguages[stringId]) {
            currentLanguages[stringId] = sourceLanguages[stringId];
        }
    }
}
exports.LocalizationExtension = LocalizationExtension;
//# sourceMappingURL=LocalizationExtension.js.map