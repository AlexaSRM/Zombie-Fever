"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = __importDefault(require("commander"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const specialPaths_1 = require("../../lib/specialPaths");
const sfb_skill_1 = require("@alexa-games/sfb-skill");
const pseudo_localization_1 = require("pseudo-localization");
const sfb_f_1 = require("@alexa-games/sfb-f");
const fileUtils_1 = require("../../lib/fileUtils");
const sfb_util_1 = require("@alexa-games/sfb-util");
sfb_util_1.crashOnUnhandledRejections();
commander_1.default
    .usage('[options] <story path>')
    .option('-t, --target-locale <locale>', "Locale to receive pseudo localized strings.")
    .option('-s, --source-locale <locale>', "Locale to provide original strings. Default en-US.", 'en-US');
commander_1.default
    .parse(process.argv);
if (process.argv.length === 2 || commander_1.default.args.length < 1) {
    commander_1.default.help();
    process.exitCode = 1;
}
else {
    run(commander_1.default.args[0], commander_1.default)
        .then(() => { })
        .catch((e) => {
        console.error(e);
        process.exitCode = 1;
    });
}
async function run(story, options) {
    if (!options.targetLocale) {
        console.error('Please specify a target local using the -t option.');
        process.exitCode = 1;
        return;
    }
    await translateLanguageStringsToPseudo(story, options.sourceLocale, options.targetLocale);
    await createPseudoResources(story, options.sourceLocale, options.targetLocale);
    await updateProjectConfig(story, options.sourceLocale, options.targetLocale);
}
async function translateLanguageStringsToPseudo(story, locale, targetLocale) {
    console.log(`story=${story}`);
    console.log(`targetLocale=${targetLocale}`);
    console.log(`locale=${locale}`);
    const dirs = new specialPaths_1.SpecialPaths(story);
    const languageString = sfb_skill_1.ResourceStringsLoaders.loadLanguageStrings(dirs.contentPath);
    if (!languageString) {
        throw new Error('No language strings found ');
    }
    const sourceStrings = languageString[locale];
    const pseudoStrings = pseudoTranslate(sourceStrings.translation);
    languageString[targetLocale] = { translation: pseudoStrings };
    const languageStringsFile = path_1.default.join(dirs.contentPath, 'languageStrings.json');
    fs_1.default.writeFileSync(languageStringsFile, JSON.stringify(languageString, null, 4));
    console.log(`Updated ${languageStringsFile}`);
}
async function createPseudoResources(story, locale, targetLocale) {
    const dirs = new specialPaths_1.SpecialPaths(story);
    await fileUtils_1.FileUtils.recursiveCopy(path_1.default.join(dirs.getResourcePath(locale), '*'), dirs.getResourcePath(targetLocale));
    const config = await sfb_skill_1.ConfigAccessor.loadConfigFile(dirs.abcConfig, dirs.contentPath);
    const snippets = sfb_skill_1.ResourceStringsLoaders.loadSnippets(config, locale);
    if (!snippets) {
        throw new Error('No snippets found.');
    }
    const pseudoSnippets = pseudoTranslate(snippets);
    const snippetMapFilePath = config.getSnippetMapFilePath(targetLocale);
    fs_1.default.writeFileSync(snippetMapFilePath, JSON.stringify(pseudoSnippets, null, 4));
    console.log(`Created ${targetLocale} resources.`);
}
async function updateProjectConfig(story, locale, targetLocale) {
    const dirs = new specialPaths_1.SpecialPaths(story);
    const configData = fileUtils_1.FileUtils.loadJson(dirs.abcConfig);
    const config = new sfb_skill_1.ConfigAccessor(configData, dirs.contentPath);
    let configChanged = false;
    if (!config.publishLocales) {
    }
    const index = config.publishLocales.findIndex((item) => { return item.toLowerCase() === targetLocale.toLowerCase(); });
    if (index < 0) {
        config.publishLocales.push(targetLocale);
        configChanged = true;
    }
    const InvocationNameKey = 'skill-invocation-name';
    const localizedInvocationName = config.getValue(InvocationNameKey, undefined, targetLocale);
    const sourceInvocationName = config.getValue(InvocationNameKey, undefined, locale);
    if (!localizedInvocationName || localizedInvocationName === sourceInvocationName) {
        config.setValue(InvocationNameKey, pseudo_localization_1.localize(sourceInvocationName), undefined, targetLocale);
        configChanged = true;
    }
    if (configChanged) {
        fs_1.default.writeFileSync(dirs.abcConfig, JSON.stringify(configData, null, 4), { encoding: 'utf8' });
    }
}
function pseudoTranslate(source) {
    const result = {};
    for (let key in source) {
        let value = source[key];
        value = value ? localizeOutputString(value) : value;
        result[key] = value;
    }
    return result;
}
function localizeOutputString(value) {
    let result = '';
    const segmenter = sfb_f_1.SegmenterBuilder.getAllSegmenter();
    for (let token of segmenter.parse(value)) {
        if (token.type === sfb_f_1.SegmentType.PlainText) {
            result += pseudo_localization_1.localize(token.original);
        }
        else {
            result += token.original;
        }
    }
    return result;
}
//# sourceMappingURL=pseudo.js.map