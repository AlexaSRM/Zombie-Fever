"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utilities_1 = require("./utilities");
const filePath_1 = require("./filePath");
const util_1 = require("util");
const fs_1 = __importDefault(require("fs"));
const sfb_util_1 = require("@alexa-games/sfb-util");
const pathModule = require('path');
const chmodAsync = util_1.promisify(fs_1.default.chmod);
const readFileAsync = util_1.promisify(fs_1.default.readFile);
const writeFileAsync = util_1.promisify(fs_1.default.writeFile);
const copyFileAsync = util_1.promisify(fs_1.default.copyFile);
const statAsync = util_1.promisify(fs_1.default.stat);
const renameAsync = util_1.promisify(fs_1.default.rename);
class FileUtils {
    static async replaceInFile(file, searchFor, replaceWith) {
        const data = await readFileAsync(file, 'utf8');
        const result = data.replace(searchFor, replaceWith);
        await writeFileAsync(file, result, 'utf8');
    }
    static async deleteDir(dirPath, stdOutput) {
        dirPath = FileUtils.fixpath(dirPath);
        if (fs_1.default.existsSync(dirPath)) {
            if (utilities_1.Utilities.isWin32) {
                await utilities_1.Utilities.runCommandAsync('rmdir', ['/s', '/q', `"${dirPath}"`], stdOutput, { shell: true });
            }
            else {
                await utilities_1.Utilities.runCommandAsync('rm', ['-rf', `"${dirPath}"`], stdOutput, { shell: true });
            }
        }
    }
    static deleteFile(filePath) {
        filePath = FileUtils.fixpath(filePath);
        if (fs_1.default.existsSync(filePath)) {
            fs_1.default.unlinkSync(filePath);
        }
    }
    static async renameFileIfExists(oldPath, newPath) {
        if (fs_1.default.existsSync(oldPath)) {
            await renameAsync(oldPath, newPath);
        }
    }
    static makeDir(dirPath) {
        dirPath = FileUtils.fixpath(dirPath);
        const path = new filePath_1.FilePath(dirPath);
        let started = false;
        for (let i = 1; i <= path.length; i++) {
            const partialPath = path.getPartialPath(i);
            if (started || !fs_1.default.existsSync(partialPath)) {
                started = true;
                fs_1.default.mkdirSync(partialPath);
            }
        }
    }
    static fixpath(path) {
        return pathModule.resolve(path);
    }
    static isValidFileName(name) {
        return name === pathModule.basename(name);
    }
    static getRelativePath(basePath, fullPath) {
        const basePathr = FileUtils.fixpath(basePath);
        const fullPathr = FileUtils.fixpath(fullPath);
        let relativePath = fullPathr;
        if (basePathr.length + 1 < fullPathr.length) {
            const targetBasePath = fullPathr.substring(0, basePathr.length);
            if (targetBasePath === basePathr) {
                relativePath = fullPathr.substring(basePathr.length + 1);
            }
        }
        return relativePath;
    }
    static async recursiveCopy(src, dst, options) {
        const srcPath = src.replace(/\\/g, '/').split('/');
        let sourceTargetName = srcPath[srcPath.length - 1];
        if (sourceTargetName.length == 0) {
            sourceTargetName = '*';
        }
        const sourceTargetRegex = new RegExp(`^${sourceTargetName.replace("*", "[\\s\\S]*")}$`, 'g');
        let parentPath = '';
        if (srcPath && srcPath.length > 0 && srcPath[0].trim().length === 0) {
            parentPath = "/";
        }
        if (srcPath.length > 1) {
            parentPath += srcPath.slice(0, srcPath.length - 1).reduce((prev, current, index) => {
                if (prev) {
                    return prev + "/" + current;
                }
                else {
                    if (!utilities_1.Utilities.isWin32 && current.trim().length == 0) {
                        return "/";
                    }
                    else {
                        return current;
                    }
                }
            });
        }
        const files = fs_1.default.readdirSync(parentPath);
        if (!files) {
            return;
        }
        FileUtils.makeDir(dst);
        const copyPromises = [];
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            if (file.match(sourceTargetRegex)) {
                const sourceFilePath = pathModule.join(parentPath, file);
                const destFilePath = pathModule.join(dst, file);
                const sourceStat = fs_1.default.statSync(sourceFilePath);
                if (sourceStat.isDirectory()) {
                    copyPromises.push(FileUtils.recursiveCopy(pathModule.join(sourceFilePath, '*'), destFilePath, options));
                }
                else if (!fs_1.default.existsSync(destFilePath) ||
                    sourceStat.mtimeMs > fs_1.default.statSync(destFilePath).mtimeMs) {
                    copyPromises.push(FileUtils.copyFile(sourceFilePath, destFilePath, options));
                }
            }
        }
        await Promise.all(copyPromises);
    }
    static async copyFile(src, dst, options) {
        await copyFileAsync(src, dst);
        if (options && options.makeDestinationWritable) {
            const stat = await statAsync(dst);
            await chmodAsync(dst, stat.mode | 0o600);
        }
    }
    static writeGitIgnore(path) {
        fs_1.default.writeFileSync(pathModule.join(path, '.gitignore'), `dist
.deploy
node_modules
`);
    }
    static async filterFile(fileName, eliminate) {
        const data = await sfb_util_1.readUtf8FileExcludingBom(fileName);
        let result = '';
        for (let line of data.split('\n')) {
            if (!line.match(eliminate)) {
                result += line + '\n';
            }
        }
        await writeFileAsync(fileName, result, 'utf8');
    }
    static loadJson(filePath) {
        const data = sfb_util_1.readUtf8FileExcludingBomSync(filePath);
        return JSON.parse(data);
    }
}
exports.FileUtils = FileUtils;
//# sourceMappingURL=fileUtils.js.map