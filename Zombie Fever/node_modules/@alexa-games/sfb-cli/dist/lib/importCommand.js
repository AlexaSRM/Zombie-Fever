"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const sfb_f_1 = require("@alexa-games/sfb-f");
const sfb_util_1 = require("@alexa-games/sfb-util");
const specialPaths_1 = require("./specialPaths");
const sfb_skill_1 = require("@alexa-games/sfb-skill");
const utilities_1 = require("./utilities");
const fileUtils_1 = require("./fileUtils");
const manifestUtils_1 = require("./manifestUtils");
const semver_1 = __importDefault(require("semver"));
class ImportCommand {
    constructor(storyPath, enforceLatest, logger, stdOutput) {
        this.storyPath = storyPath;
        this.enforceLatest = enforceLatest;
        this.logger = logger;
        this.stdOutput = stdOutput;
    }
    async run() {
        this.logger.status('Importing content...');
        if (!fs.existsSync(this.storyPath)) {
            throw new Error(`${this.storyPath}: The specified story path does not exist.`);
        }
        const dirs = new specialPaths_1.SpecialPaths(this.storyPath);
        const config = await sfb_skill_1.ConfigAccessor.loadConfigFile(dirs.abcConfig, dirs.builtResourcesPath);
        await this.versionChecks(dirs);
        await this.copyAbcConfig(dirs);
        await this.compileCode(dirs, config.getValue("sfbLocalTesting", undefined, "en-US"));
        for (const locale of config.publishLocales) {
            await this.importResourceFiles(locale, dirs, config.validResourceFileExtensions);
            await this.importAdditionalDirectories(locale, dirs, config.additionalResourceDirectories);
            try {
                await this.importStory(locale, dirs, config);
            }
            catch (err) {
                if (!ImportCommand.isImportError(err)) {
                    throw err;
                }
                const count = this.reportErrors(err);
                throw new Error(`Found ${count} import errors.`);
            }
        }
        await this.copyGeneratedResources(dirs);
        this.logger.success('Content imported.');
    }
    async versionChecks(dirs) {
        const toolingMetadata = manifestUtils_1.ManifestUtils.readRawPackageNameVersion();
        await this.checkOnlineForNewerTooling(toolingMetadata);
        const storyCodeManifestPath = path.join(dirs.codePath, specialPaths_1.PACKAGE_MANIFEST_FILE);
        const storyCodeManifest = fileUtils_1.FileUtils.loadJson(storyCodeManifestPath);
        manifestUtils_1.ManifestUtils.checkDeploymentPackageVersionWithTooling(storyCodeManifest, toolingMetadata, this.logger);
    }
    async checkOnlineForNewerTooling(toolingMetadata) {
        let publishedVersion = '0.0.0';
        try {
            publishedVersion = await manifestUtils_1.ManifestUtils.getLatestsMajorVersionFromNpm(toolingMetadata, this.stdOutput);
            if (!publishedVersion || publishedVersion === '') {
                this.logger.warning(`SFB version check skipped. Unable to determine the latest version of ${toolingMetadata.name}.`);
                return;
            }
        }
        catch (e) {
            this.logger.warning(`SFB version check skipped. Error communicating with NPM.`);
            this.logger.warning(e);
            return;
        }
        if (semver_1.default.lt(toolingMetadata.version, publishedVersion)) {
            const message = `Current version Skill Flow Builder ${toolingMetadata.version} is behind latest available ${publishedVersion}.`;
            if (this.enforceLatest) {
                throw new Error(message);
            }
            this.logger.warning(message);
        }
    }
    async compileCode(dirs, isLocalTest) {
        this.logger.status('Compiling TypeScript code...');
        if (isLocalTest) {
            await utilities_1.Utilities.runCommandInDirectoryAsync(utilities_1.Utilities.npxBin, [utilities_1.Utilities.yarnBin, 'install'], dirs.codePath, this.stdOutput, { shell: true });
            await utilities_1.Utilities.runCommandInDirectoryAsync(utilities_1.Utilities.yarnBin, ['compile'], dirs.codePath, this.stdOutput, { shell: true });
        }
        else {
            await utilities_1.Utilities.runCommandInDirectoryAsync(utilities_1.Utilities.npmBin, ['install'], dirs.codePath, this.stdOutput, { shell: true });
            await utilities_1.Utilities.runCommandInDirectoryAsync(utilities_1.Utilities.npmBin, ['run', 'compile'], dirs.codePath, this.stdOutput, { shell: true });
        }
        this.logger.success('Compile step completed.');
    }
    async copyAbcConfig(dirs) {
        const configFileDeployPath = path.join(dirs.buildOutputPath, 'abcConfig');
        fileUtils_1.FileUtils.makeDir(configFileDeployPath);
        await fileUtils_1.FileUtils.copyFile(dirs.abcConfig, path.join(configFileDeployPath, specialPaths_1.ABC_CONFIG_FILE));
    }
    reportErrors(err) {
        if (err instanceof Array) {
            for (let i = 0; i < err.length; i++) {
                this.reportErrors(err[i]);
            }
            return err.length;
        }
        else {
            const message = `${err.errorName}: ${err.errorMessage}`;
            if (err.sourceID) {
                this.logger.failure(`${err.sourceID}:${err.lineNumber} - ${message}`);
            }
            else {
                this.logger.failure(`Line ${err.lineNumber} - ${message}`);
            }
            return 1;
        }
    }
    static isImportError(err) {
        if (err instanceof Array) {
            if (err.length > 0) {
                return ImportCommand.isImportErrorObject(err[0]);
            }
        }
        return ImportCommand.isImportErrorObject(err);
    }
    static isImportErrorObject(err) {
        return err && 'lineNumber' in err && 'errorName' in err && 'errorMessage' in err;
    }
    async copyGeneratedResources(dirs) {
        const contentPath = dirs.contentPath;
        const languageStringsFile = path.join(dirs.builtResourcesPath, 'languageStrings.json');
        await fileUtils_1.FileUtils.recursiveCopy(languageStringsFile, contentPath);
    }
    async importStory(locale, dirs, config) {
        this.logger.status(`Importing locale ${locale}...`);
        const contentPath = dirs.contentPath;
        const resourcePath = dirs.getResourcePath(locale);
        const localeBuiltResourcesPath = dirs.getLocaleBuiltResourcesPath(locale);
        const bakedFilePath = path.join(localeBuiltResourcesPath, config.getValue("abc-baked-filename", undefined, locale));
        const recordingScriptFilePath = path.join(localeBuiltResourcesPath, config.getValue("abc-recording-script-filename", undefined, locale));
        const storyTitle = config.getValue("story-title", undefined, locale);
        const storyId = config.getValue("story-id", undefined, locale);
        const invocationName = config.getValue("skill-invocation-name", undefined, locale).toLowerCase();
        const customSlotTypeFilePath = path.join(resourcePath, config.getValue("custom-slottype-filename", undefined, locale));
        const manifestFilePath = path.join(contentPath, "MANIFEST.json");
        let storyManifest = {};
        if (fs.existsSync(manifestFilePath)) {
            storyManifest = fileUtils_1.FileUtils.loadJson(manifestFilePath);
        }
        else {
            throw new Error(`${manifestFilePath} does not exist.`);
        }
        const combinedContent = await this.getCombinedStoryContentFromManifest(storyManifest, contentPath);
        const DEFAULT_IMPORT_PLUGIN_NAME = "default";
        let extensionLoader = new sfb_skill_1.CoreExtensionLoader(locale, config, {
            contentSource: dirs.contentPath
        });
        const extensionLoaderModule = require(dirs.extensionLoaderPath);
        const customExtensions = new extensionLoaderModule.ExtensionLoader({
            locale: locale,
            configAccessor: config
        });
        let customStoryExtensions = customExtensions.getExtensions().concat(extensionLoader.getImportExtensions());
        let customImportPlugins = [];
        let importer = new sfb_f_1.ACEImporter(customImportPlugins, undefined, customStoryExtensions);
        let customSlots = {};
        if (!fs.existsSync(customSlotTypeFilePath)) {
            this.logger.warning(`[Import WARN] Custom Slot config '${customSlotTypeFilePath}' cannot be found.`);
        }
        else {
            customSlots = fileUtils_1.FileUtils.loadJson(customSlotTypeFilePath);
        }
        try {
            let importedStory = await importer.importABCStory(DEFAULT_IMPORT_PLUGIN_NAME, "", storyTitle, storyId, true, {
                customSlots: customSlots,
                contents: combinedContent,
                version: storyManifest.version || 1,
                locale: locale
            });
            importedStory.alexaVoiceModel.languageModel.invocationName = invocationName;
            fileUtils_1.FileUtils.makeDir(localeBuiltResourcesPath);
            let recordingScript = extensionLoader.voiceOverExtension.getRecordingScript();
            if (recordingScript && recordingScript.length > 0) {
                fs.writeFileSync(recordingScriptFilePath, recordingScript);
            }
            let languageString = extensionLoader.localizationExtension.getLocalizedStringsObject();
            if (languageString && Object.keys(languageString).length > 0) {
                const languageStringsFile = path.join(dirs.builtResourcesPath, 'languageStrings.json');
                const languageStringsSourceFile = path.join(dirs.contentPath, 'languageStrings.json');
                fs.writeFileSync(languageStringsFile, JSON.stringify(languageString, null, 4));
                fs.writeFileSync(languageStringsSourceFile, JSON.stringify(languageString, null, 4));
            }
            fs.writeFileSync(bakedFilePath, JSON.stringify(importedStory, null, 4));
            fs.writeFileSync(`${localeBuiltResourcesPath}/${locale}.json`, JSON.stringify({
                "interactionModel": importedStory['alexaVoiceModel']
            }, null, 4));
            this.logger.status(`Importing of ${locale} completed.`);
        }
        catch (err) {
            if (err.errorItems) {
                throw err.errorItems;
            }
            else {
                throw err;
            }
        }
    }
    getCombinedStoryContentFromManifest(manifest, srcDirectoryPath) {
        const stories = manifest.include;
        const pathToRegex = {};
        for (const storyRegex of stories) {
            const extractFileRegex = /([\S]+\/)?([^\/]+?)$/g;
            const matchedPath = extractFileRegex.exec(storyRegex);
            if (matchedPath != null) {
                const postDir = matchedPath[1] ? `/${matchedPath[1]}` : "";
                if (!pathToRegex[`${srcDirectoryPath}${postDir}`]) {
                    pathToRegex[`${srcDirectoryPath}${postDir}`] = "";
                }
                else {
                    pathToRegex[`${srcDirectoryPath}${postDir}`] += "|";
                }
                pathToRegex[`${srcDirectoryPath}${postDir}`] += `(?:^${matchedPath[2].replace(/\./g, "\\.").replace(/\*/g, ".*")}$)`;
            }
        }
        const combinedStoryContent = [];
        for (const searchDirectory of Object.keys(pathToRegex)) {
            const files = fs.readdirSync(searchDirectory);
            if (!files) {
                throw new Error(`[Import ERROR] Cannot find story content files: ${JSON.stringify(stories, null, 4)}`);
            }
            for (var i = 0; i < files.length; i++) {
                const file = files[i];
                if (file.match(pathToRegex[searchDirectory])) {
                    combinedStoryContent.push({
                        id: path.join(path.relative(srcDirectoryPath, searchDirectory), file),
                        text: sfb_util_1.readUtf8FileExcludingBomSync(path.join(searchDirectory, file))
                    });
                }
            }
        }
        return combinedStoryContent;
    }
    async importAdditionalDirectories(locale, dirs, directories) {
        const resourceFolder = dirs.getResourcePath(locale);
        const localeBuildOutputPath = dirs.getLocaleBuiltResourcesPath(locale);
        for (let dir of directories) {
            await fileUtils_1.FileUtils.recursiveCopy(path.join(resourceFolder, dir), localeBuildOutputPath);
        }
    }
    async importResourceFiles(locale, dirs, extensions) {
        const resourceFolder = dirs.getResourcePath(locale);
        const localeBuildOutputPath = dirs.getLocaleBuiltResourcesPath(locale);
        for (let ext of extensions) {
            await fileUtils_1.FileUtils.recursiveCopy(`${resourceFolder}/*.${ext}`, localeBuildOutputPath);
        }
    }
}
exports.ImportCommand = ImportCommand;
//# sourceMappingURL=importCommand.js.map