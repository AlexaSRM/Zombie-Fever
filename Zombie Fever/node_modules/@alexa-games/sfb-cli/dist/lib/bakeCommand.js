"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require('fs');
const path = require('path');
const fileUtils_1 = require("./fileUtils");
const specialPaths_1 = require("./specialPaths");
const sfb_skill_1 = require("@alexa-games/sfb-skill");
class BakeCommand {
    constructor(storyPath, logger) {
        this.storyPath = storyPath;
        this.logger = logger;
    }
    async run() {
        const dirs = new specialPaths_1.SpecialPaths(this.storyPath);
        const config = await sfb_skill_1.ConfigAccessor.loadConfigFile(dirs.abcConfig, dirs.builtResourcesPath);
        this.logger.status('Copying baked output to the baked folder for your reference...');
        for (let locale of config.publishLocales) {
            await this.copyContent(locale, dirs, config);
        }
        this.logger.status('Checking for apl-template files to bake...');
        for (let locale of config.publishLocales) {
            const aplTemplatesFilePath = config.getAplTemplatesFilePath(locale);
            await this.bakeAPLFiles(aplTemplatesFilePath, aplTemplatesFilePath);
        }
        this.logger.success('Baked output copied.');
    }
    async copyContent(locale, dirs, config) {
        const localeBuildOutputPath = dirs.getLocaleBuiltResourcesPath(locale);
        const voiceOverFileName = config.getValue("abc-recording-script-filename", undefined, locale);
        const bakedStoryName = config.getValue("abc-baked-filename", undefined, locale);
        await fileUtils_1.FileUtils.recursiveCopy(`${localeBuildOutputPath}/${bakedStoryName}`, `${dirs.bakedPath}/${locale}`);
        if (fs.existsSync(`${localeBuildOutputPath}/${voiceOverFileName}`)) {
            await fileUtils_1.FileUtils.recursiveCopy(`${localeBuildOutputPath}/${voiceOverFileName}`, `${dirs.bakedPath}/${locale}`);
        }
    }
    async bakeAPLFiles(aplTemplatesFilePath, outputAPLFilePath) {
        if (aplTemplatesFilePath) {
            const dirNamePath = path.dirname(aplTemplatesFilePath);
            if (dirNamePath) {
                const aplDirName = path.resolve(path.join(dirNamePath, "apl-templates"));
                if (fs.existsSync(aplDirName)) {
                    const fileList = readdirRecursiveSync(aplDirName);
                    if (fileList.length > 0) {
                        let sourceAPLJSON = {};
                        if (fs.existsSync(aplTemplatesFilePath)) {
                            try {
                                sourceAPLJSON = JSON.parse(fs.readFileSync(aplTemplatesFilePath));
                            }
                            catch (e) {
                                this.logger.warning(e);
                                throw new Error(`Unable to JSON parse APL file ${aplTemplatesFilePath}`);
                            }
                        }
                        for (const filename of fileList) {
                            const aplFile = path.join(aplDirName, filename);
                            try {
                                const fileAPLJson = JSON.parse(fs.readFileSync(aplFile));
                                let keyName = path.join(path.dirname(filename), path.basename(filename, ".json"));
                                keyName = keyName.replace("\\", ".").replace("/", ".");
                                sourceAPLJSON[keyName] = fileAPLJson;
                            }
                            catch (e) {
                                this.logger.warning(e);
                                throw new Error(`Unable to JSON parse APL file ${aplFile}`);
                            }
                        }
                        fs.writeFileSync(outputAPLFilePath, JSON.stringify(sourceAPLJSON, undefined, 2));
                    }
                }
            }
        }
    }
}
exports.BakeCommand = BakeCommand;
function readdirRecursiveSync(folderPath) {
    const returnedFileList = [];
    readdirRecursiveSyncHelper(folderPath, path.resolve(folderPath), returnedFileList);
    return returnedFileList;
}
function readdirRecursiveSyncHelper(originalFolderPath, folderPath, returnedFileList) {
    const files = fs.readdirSync(folderPath);
    files.forEach((filename) => {
        const stats = fs.statSync(path.resolve(folderPath, filename));
        if (stats.isDirectory()) {
            readdirRecursiveSyncHelper(originalFolderPath, path.resolve(folderPath, filename), returnedFileList);
        }
        else {
            const relativePath = path.relative(originalFolderPath, path.resolve(folderPath, filename));
            returnedFileList.push(relativePath);
        }
    });
}
//# sourceMappingURL=bakeCommand.js.map