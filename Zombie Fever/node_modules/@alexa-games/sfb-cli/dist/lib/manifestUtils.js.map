{"version":3,"file":"manifestUtils.js","sourceRoot":"","sources":["../../lib/manifestUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from './logger';\nimport { StringDecoder } from 'string_decoder';\nimport semver from 'semver';\nimport pathModule from 'path';\nimport { FileUtils } from './fileUtils';\nimport { Utilities } from './utilities';\nimport { StdOutput } from './stdOutput';\nimport { RuntimeDependencyVersion } from './runtimeDependencyVersion';\n\nexport interface PackageMetadata {\n    name: string;\n    version: string;\n}\n\nexport class ManifestUtils {\n\n    /**\n     * Pulls the package version from the currently running script. Will not throw an exception\n     * but will return 'unknown' if there are any errors.\n     * @param logger Logger for recording errors.\n     */\n    public static readPackageVersion(logger: Logger): string {\n        try {\n            return ManifestUtils.readRawPackageVersion();\n        } catch (e) {\n            logger.error(e);\n            return 'unknown';\n        }\n    }\n\n    /**\n     * Returns the package version of the currently running script. May throw if there are any \n     * errors.\n     */\n    public static readRawPackageVersion(): string {\n        const data = ManifestUtils.readRawPackageNameVersion();\n        return data.version;\n    }\n\n    /**\n     * Returns the package of the currently running script. May throw if there are any \n     * errors.\n     */\n    public static readRawPackageNameVersion(): PackageMetadata {\n        const packagePath = pathModule.join(__dirname, '..', '..', 'package.json');\n        const data = FileUtils.loadJson(packagePath);\n        return {\n            version: data.version,\n            name: data.name\n        };\n    }\n    \n    /**\n     * Converts any dependencies using file:.. references to use compatible versions from\n     * the NPM repository.\n     * @param manifest Manifest to modify, typically loaded from a package.json file.\n     */\n    public static async repairPackageManifest(manifest: any) {\n        const currentVersion = ManifestUtils.readRawPackageVersion();\n        const dependencyVersion = RuntimeDependencyVersion.getDependencyRangeFromToolingVersion(currentVersion);\n\n        const token = 'file:../';\n\n        for (let dep of Object.keys(manifest.dependencies)) {\n            const value = manifest.dependencies[dep];\n\n            if (value && value.startsWith(token)) {\n                manifest.dependencies[dep] = dependencyVersion;\n            }\n        }\n    }\n\n    /**\n     * Returns the latest major version of the supplied package by name/version.\n     * @param nameVersion A name/version tuple\n     * @param stdOutput Output for reporting errors \n     */\n    public static async getLatestsMajorVersionFromNpm(\n        nameVersion: PackageMetadata,\n        stdOutput: StdOutput) {\n\n        const version = semver.parse(nameVersion.version);\n        if (!version) {\n            throw new Error(`Unable to parse version '${nameVersion.version}'.`);\n        }\n\n        // e.g. @alexa-games/sfb-f@1.*\n        const packageRange = `${nameVersion.name}@${version.major}.*`;\n        return await ManifestUtils.getLatestPackageVersionFromNpm(packageRange, stdOutput);\n    }\n\n    /**\n     * Queries NPM (online) for package versions.\n     * @param packageRange Package name or a string like pkg-name@1.2.* to get all versions starting with 1.2.\n     * @param stdOutput Output for reporting errors.\n     */\n    public static async getLatestPackageVersionFromNpm(packageRange: string, stdOutput: StdOutput) {\n\n        // Query all versions that are the same as our current tooling major version.\n        const livePkgVersion = await ManifestUtils.getPackageVersionsFromNpm(packageRange, stdOutput);\n\n        // If the regex does not match, we will assume we got back a single version\n        // and so initialize pkgVersion equal to the single version\n        let pkgVersion = livePkgVersion;\n\n        const versionRegex = /\\s+'(.*)'/gm;\n\n        // Loop through all matching values, keeping only the final one which will\n        // be the most recent version.\n        let match = versionRegex.exec(livePkgVersion);\n        while (match && match.length > 1) {\n            pkgVersion = match[1];\n            match = versionRegex.exec(livePkgVersion);\n        }\n\n        return pkgVersion;\n    }\n\n    public static async getPackageVersionsFromNpm(packageRange: string, stdOutput: StdOutput) {\n        let result = '';\n        const decoder = new StringDecoder('utf8');\n        const outputCapture = {\n            stdOut: function(chunk: Buffer | string | any) {\n                if (typeof chunk === 'string') {\n                    result += chunk;\n                } else {\n                    result += decoder.write(chunk);\n                }\n            },\n            stdErr: function(chunk: Buffer | string | any) {\n                stdOutput.stdErr(chunk);\n            }\n        }\n\n        await Utilities.runCommandAsync('npm', ['view', packageRange, 'version'],\n            outputCapture, { shell: true });\n\n        return result.trim();\n    }\n\n    /**\n     * Checks that the tooling it compatible with the story package.json file.\n     * @param manifest Package.json file loaded from the story's code folder.\n     * @param toolingMetadata Name and version of the currently running tooling.\n     */\n    public static checkDeploymentPackageVersionWithTooling(manifest: any, toolingMetadata: PackageMetadata, logger: Logger) {\n        const frameworkName = '@alexa-games/sfb-f';\n        const versionRangeExpression = manifest.dependencies[frameworkName];\n\n        if (!versionRangeExpression) {\n            throw new Error(`Cannot find required dependency ${frameworkName}.`);\n        }\n\n        const versionRange = semver.validRange(versionRangeExpression);\n        if (!versionRange) {\n            logger.warning(`Found invalid version range expression ${versionRangeExpression} for ${frameworkName}.`);\n            return;\n        }\n\n        if (!semver.satisfies(toolingMetadata.version, versionRange)) {\n            throw new Error(`Skill Flow Builder version ${toolingMetadata.version} is not compatible ` + \n            `because story's package.json specifies ${versionRangeExpression} for ${frameworkName}.`);\n        }\n    }\n\n}"]}