"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const pathModule = __importStar(require("path"));
const specialPaths_1 = require("./specialPaths");
const utilities_1 = require("./utilities");
const fileUtils_1 = require("./fileUtils");
const sfb_skill_1 = require("@alexa-games/sfb-skill");
class StageCommand {
    constructor(storyPath, logger, stdOutput) {
        this.storyPath = storyPath;
        this.logger = logger;
        this.stdOutput = stdOutput;
    }
    async run() {
        const specialDirectories = new specialPaths_1.SpecialPaths(this.storyPath);
        if (!fs.existsSync(specialDirectories.storyPath)) {
            throw new Error('Cannot find path ' + specialDirectories.storyPath);
        }
        const configHelper = await sfb_skill_1.ConfigAccessor.loadConfigFile(specialDirectories.abcConfig, specialDirectories.builtResourcesPath);
        const configDirs = specialDirectories.getConfigDirectories(configHelper);
        await this.makeAskPayload(specialDirectories, configDirs);
        await this.copyOverAskSkillFiles(specialDirectories, configDirs, configHelper.publishLocales, configHelper);
        await this.modifySkillManifest(specialDirectories, configDirs, configHelper.publishLocales);
        await this.preserveSkillManifest(specialDirectories, configDirs);
    }
    async preserveSkillManifest(dirs, configDirs) {
        const skillManifestStoragePath = pathModule.join(dirs.metaDataStoragePath, specialPaths_1.SKILL_MANIFEST_FILE);
        const skillManifestPath = pathModule.join(configDirs.askSkillFullPath, specialPaths_1.SKILL_MANIFEST_FILE);
        if (fs.existsSync(skillManifestPath) && !fs.existsSync(skillManifestStoragePath)) {
            fileUtils_1.FileUtils.makeDir(dirs.metaDataStoragePath);
            this.logger.status(`Copying ${specialPaths_1.SKILL_MANIFEST_FILE} for safe keeping.`);
            await fileUtils_1.FileUtils.copyFile(skillManifestPath, skillManifestStoragePath);
        }
    }
    async makeAskPayload(dirs, configDirs) {
        this.logger.status('Staging deployment folder layout with ASK template...');
        if (fs.existsSync(configDirs.askSkillFullPath)) {
            this.logger.status(`${configDirs.askSkillFullPath}: The skill folder already exists, skipping creation.`);
        }
        else {
            try {
                fileUtils_1.FileUtils.makeDir(dirs.deployPath);
                const askTemplateUrl = 'https://s3.amazonaws.com/ask-cli/templates/nodejs-templates.json';
                const askTemplateName = '"Hello World"';
                await utilities_1.Utilities.runCommandInDirectoryAsync(utilities_1.Utilities.npxBin, ['ask', 'new', '--url', askTemplateUrl, '--template', askTemplateName, '--skill-name', configDirs.askSkillDirectoryName], dirs.deployPath, this.stdOutput, { shell: true });
                if (fs.existsSync(configDirs.lambdaCodeDeployPath)) {
                    await fileUtils_1.FileUtils.deleteDir(configDirs.lambdaCodeDeployPath, this.stdOutput);
                }
            }
            finally {
                await fileUtils_1.FileUtils.deleteDir(`${configDirs.askSkillFullPath}/.git`, this.stdOutput);
            }
        }
        this.logger.success('Deployment folder layout was staged with ASK template.');
    }
    async copyOverAskSkillFiles(dirs, configDirs, publishLocales, configHelper) {
        this.logger.status('Copying over story specific files...');
        this.logger.status('Copying build output files...');
        await fileUtils_1.FileUtils.recursiveCopy(pathModule.join(dirs.buildOutputPath, '*'), configDirs.lambdaCodeDeployPath, { makeDestinationWritable: true });
        await fileUtils_1.FileUtils.recursiveCopy(pathModule.join(dirs.codeBuildOutputPath, '*'), configDirs.lambdaCodeDeployPath, { makeDestinationWritable: true });
        await this.setupNodeModulesUsingInstallProduction(dirs, configDirs, configHelper.getValue("sfbLocalTesting", undefined, "en-US"));
        if (!configHelper.getValue("skipFFMPEGInclude", undefined, "en-US")) {
            this.logger.status('Copying ffmpeg...');
            await fileUtils_1.FileUtils.copyFile(pathModule.join(dirs.aceRootPath, 'ffmpeg'), pathModule.join(configDirs.lambdaCodeDeployPath, 'ffmpeg'));
        }
        let failure = false;
        for (let locale of publishLocales) {
            this.logger.status(`Copying model for ${locale} to deployment path.`);
            const modelOutput = pathModule.join(dirs.getLocaleBuiltResourcesPath(locale), `${locale}.json`);
            if (fs.existsSync(modelOutput)) {
                fs.copyFileSync(modelOutput, pathModule.join(configDirs.modelsDeployPath, `${locale}.json`));
            }
            else {
                this.logger.status(`${modelOutput} does not exist.`);
                failure = true;
            }
        }
        if (failure) {
            throw new Error('Error copying models to deployment folder.');
        }
        this.logger.success('Story specific files copied over.');
    }
    async setupNodeModulesUsingInstallProduction(dirs, configDirs, isLocalTest) {
        this.logger.status('Installing production node_modules...');
        const lambdaPackageManifestFilePath = pathModule.join(configDirs.lambdaCodeDeployPath, specialPaths_1.PACKAGE_MANIFEST_FILE);
        const packageManifest = JSON.parse(fs.readFileSync(pathModule.join(dirs.codePath, specialPaths_1.PACKAGE_MANIFEST_FILE), "utf8"));
        delete packageManifest.devDependencies;
        fs.writeFileSync(lambdaPackageManifestFilePath, JSON.stringify(packageManifest, null, 4));
        if (isLocalTest) {
            await utilities_1.Utilities.runCommandInDirectoryAsync(utilities_1.Utilities.npxBin, [utilities_1.Utilities.yarnBin, 'install', '--production'], configDirs.lambdaCodeDeployPath, this.stdOutput, { shell: true });
        }
        else {
            await utilities_1.Utilities.runCommandInDirectoryAsync(utilities_1.Utilities.npmBin, ['install', '--production'], configDirs.lambdaCodeDeployPath, this.stdOutput, { shell: true });
        }
    }
    async modifySkillManifest(dirs, configDirs, publishLocales) {
        this.logger.status('Updating skill manifest...');
        const skillSourcePath = pathModule.join(dirs.metaDataStoragePath, specialPaths_1.SKILL_MANIFEST_FILE);
        const skillManifestPath = pathModule.join(configDirs.askSkillFullPath, specialPaths_1.SKILL_MANIFEST_FILE);
        if (fs.existsSync(skillSourcePath)) {
            await fileUtils_1.FileUtils.copyFile(skillSourcePath, skillManifestPath);
        }
        let manifest = fileUtils_1.FileUtils.loadJson(skillManifestPath);
        let updated = false;
        for (let locale of publishLocales) {
            if (!manifest.manifest.publishingInformation.locales[locale]) {
                updated = true;
                manifest.manifest.publishingInformation.locales[locale] = JSON.parse(JSON.stringify(manifest.manifest.publishingInformation.locales["en-US"]));
            }
        }
        for (let locale of Object.keys(manifest.manifest.publishingInformation.locales)) {
            if (!publishLocales.includes(locale)) {
                updated = true;
                delete manifest.manifest.publishingInformation.locales[locale];
            }
        }
        if (!manifest.manifest.apis.custom.interfaces) {
            manifest.manifest.apis.custom.interfaces = [
                {
                    "type": "ALEXA_PRESENTATION_APL"
                }
            ];
            updated = true;
        }
        if (updated) {
            fs.writeFileSync(skillManifestPath, JSON.stringify(manifest, null, 2));
        }
        this.logger.success('Skill manifest updated.');
    }
}
exports.StageCommand = StageCommand;
//# sourceMappingURL=stageCommand.js.map