"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
class Utilities {
    static async runCommandInDirectoryAsync(command, params, directory, stdOutput, options) {
        await this.runCommandAsyncInternal({
            command,
            params,
            directory,
            stdOutput,
            options
        });
    }
    static async runCommandAsync(command, params, stdOutput, options) {
        await this.runCommandAsyncInternal({
            command,
            params,
            stdOutput,
            options
        });
    }
    static async wrap(verbose, f, logger) {
        try {
            await f();
        }
        catch (e) {
            if (verbose || !('message' in e)) {
                logger.failure(`${JSON.stringify(e)}`);
                const error = e;
                if (error && error.stack) {
                    logger.error(error.stack);
                }
            }
            else {
                logger.failure(e.message);
            }
        }
    }
    static get isWin32() {
        return process.platform === "win32";
    }
    static get npmBin() {
        return 'npm';
    }
    static get yarnBin() {
        return 'yarn';
    }
    static get npxBin() {
        return 'npx';
    }
    static get awsBin() {
        return 'aws';
    }
    static runCommandAsyncInternal({ command, params, directory = undefined, stdOutput, options = {} }) {
        return new Promise((resolve, reject) => {
            let error = undefined;
            const spawnOptions = Object.assign({}, options);
            if (directory) {
                if (!fs.existsSync(directory)) {
                    reject(new Error(`Directory ${directory} not found.`));
                }
                spawnOptions.cwd = directory;
            }
            const child = child_process_1.spawn(command, params, spawnOptions);
            child.on('error', (err) => {
                error = err;
            });
            child.stdout.on('data', (data) => {
                stdOutput.stdOut(data);
            });
            child.stderr.on('data', (data) => {
                stdOutput.stdErr(data);
            });
            child.on('close', (code) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (code !== 0) {
                        reject(new Error(`${command} ${params.join(' ')} non-zero return code: ${code}`));
                    }
                    else {
                        resolve();
                    }
                }
            });
        });
    }
}
exports.Utilities = Utilities;
//# sourceMappingURL=utilities.js.map