"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const string_decoder_1 = require("string_decoder");
const semver_1 = __importDefault(require("semver"));
const path_1 = __importDefault(require("path"));
const fileUtils_1 = require("./fileUtils");
const utilities_1 = require("./utilities");
const runtimeDependencyVersion_1 = require("./runtimeDependencyVersion");
class ManifestUtils {
    static readPackageVersion(logger) {
        try {
            return ManifestUtils.readRawPackageVersion();
        }
        catch (e) {
            logger.error(e);
            return 'unknown';
        }
    }
    static readRawPackageVersion() {
        const data = ManifestUtils.readRawPackageNameVersion();
        return data.version;
    }
    static readRawPackageNameVersion() {
        const packagePath = path_1.default.join(__dirname, '..', '..', 'package.json');
        const data = fileUtils_1.FileUtils.loadJson(packagePath);
        return {
            version: data.version,
            name: data.name
        };
    }
    static async repairPackageManifest(manifest) {
        const currentVersion = ManifestUtils.readRawPackageVersion();
        const dependencyVersion = runtimeDependencyVersion_1.RuntimeDependencyVersion.getDependencyRangeFromToolingVersion(currentVersion);
        const token = 'file:../';
        for (let dep of Object.keys(manifest.dependencies)) {
            const value = manifest.dependencies[dep];
            if (value && value.startsWith(token)) {
                manifest.dependencies[dep] = dependencyVersion;
            }
        }
    }
    static async getLatestsMajorVersionFromNpm(nameVersion, stdOutput) {
        const version = semver_1.default.parse(nameVersion.version);
        if (!version) {
            throw new Error(`Unable to parse version '${nameVersion.version}'.`);
        }
        const packageRange = `${nameVersion.name}@${version.major}.*`;
        return await ManifestUtils.getLatestPackageVersionFromNpm(packageRange, stdOutput);
    }
    static async getLatestPackageVersionFromNpm(packageRange, stdOutput) {
        const livePkgVersion = await ManifestUtils.getPackageVersionsFromNpm(packageRange, stdOutput);
        let pkgVersion = livePkgVersion;
        const versionRegex = /\s+'(.*)'/gm;
        let match = versionRegex.exec(livePkgVersion);
        while (match && match.length > 1) {
            pkgVersion = match[1];
            match = versionRegex.exec(livePkgVersion);
        }
        return pkgVersion;
    }
    static async getPackageVersionsFromNpm(packageRange, stdOutput) {
        let result = '';
        const decoder = new string_decoder_1.StringDecoder('utf8');
        const outputCapture = {
            stdOut: function (chunk) {
                if (typeof chunk === 'string') {
                    result += chunk;
                }
                else {
                    result += decoder.write(chunk);
                }
            },
            stdErr: function (chunk) {
                stdOutput.stdErr(chunk);
            }
        };
        await utilities_1.Utilities.runCommandAsync('npm', ['view', packageRange, 'version'], outputCapture, { shell: true });
        return result.trim();
    }
    static checkDeploymentPackageVersionWithTooling(manifest, toolingMetadata, logger) {
        const frameworkName = '@alexa-games/sfb-f';
        const versionRangeExpression = manifest.dependencies[frameworkName];
        if (!versionRangeExpression) {
            throw new Error(`Cannot find required dependency ${frameworkName}.`);
        }
        const versionRange = semver_1.default.validRange(versionRangeExpression);
        if (!versionRange) {
            logger.warning(`Found invalid version range expression ${versionRangeExpression} for ${frameworkName}.`);
            return;
        }
        if (!semver_1.default.satisfies(toolingMetadata.version, versionRange)) {
            throw new Error(`Skill Flow Builder version ${toolingMetadata.version} is not compatible ` +
                `because story's package.json specifies ${versionRangeExpression} for ${frameworkName}.`);
        }
    }
}
exports.ManifestUtils = ManifestUtils;
//# sourceMappingURL=manifestUtils.js.map