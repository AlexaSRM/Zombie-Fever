"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// The module 'vscode' contains the VS Code extensibility API
// Import the necessary extensibility types to use in your code below
const vscode_1 = require("vscode");
const vscode = require("vscode");
const ExperimentOutlineProvider_1 = require("./ExperimentOutlineProvider");
const sfb_f_1 = require("@alexa-games/sfb-f");
const ExperimentModeExtensionHelper_1 = require("./ExperimentModeExtensionHelper");
const ExperimentModeExtensionHelper_2 = require("./ExperimentModeExtensionHelper");
const ExperimentModeExtensionHelper_3 = require("./ExperimentModeExtensionHelper");
const ExperimentModeExtensionHelper_4 = require("./ExperimentModeExtensionHelper");
const Util_1 = require("./Util");
const DEFAULT_MODE = { language: 'abc-format', scheme: 'file' };
let diagnosticCollection;
// This method is called when your extension is activated. Activation is
// controlled by the activation events defined in package.json.
async function activate(context) {
    diagnosticCollection = vscode.languages.createDiagnosticCollection();
    context.subscriptions.push(diagnosticCollection);
    if (vscode.window.activeTextEditor) {
        await updateDiagnostics(vscode.window.activeTextEditor.document, diagnosticCollection);
    }
    context.subscriptions.push(vscode.window.onDidChangeActiveTextEditor(e => updateDiagnostics(e.document, diagnosticCollection)));
    context.subscriptions.push(vscode.workspace.onDidChangeTextDocument(e => updateDiagnostics(e.document, diagnosticCollection)));
    context.subscriptions.push(vscode_1.languages.registerDefinitionProvider(DEFAULT_MODE, new ExperimentModeExtensionHelper_4.SceneDefinitionProvider()));
    context.subscriptions.push(vscode_1.languages.registerSignatureHelpProvider(DEFAULT_MODE, new ExperimentModeExtensionHelper_2.SceneContentProvider(), ' '));
    context.subscriptions.push(vscode_1.languages.registerHoverProvider(DEFAULT_MODE, new ExperimentModeExtensionHelper_3.SceneDefinitionHover()));
    context.subscriptions.push(vscode_1.languages.registerCompletionItemProvider(DEFAULT_MODE, new ExperimentModeExtensionHelper_1.SceneCompletionProvider("scene_property"), "*"));
    context.subscriptions.push(vscode_1.languages.registerCompletionItemProvider(DEFAULT_MODE, new ExperimentModeExtensionHelper_1.SceneCompletionProvider("scene_goto"), ' ', '>'));
    context.subscriptions.push(vscode_1.languages.registerCompletionItemProvider(DEFAULT_MODE, new ExperimentModeExtensionHelper_1.SceneCompletionProvider("available_slots"), "'"));
    const experimentStoryOutlineProvider = new ExperimentOutlineProvider_1.ExperimentOutlineProvider(context);
    vscode.window.registerTreeDataProvider("story-outline", experimentStoryOutlineProvider);
    vscode.commands.registerCommand('extension.openStorySelectionExperiment', range => experimentStoryOutlineProvider.select(range));
}
exports.activate = activate;
async function updateDiagnostics(document, collection) {
    if (document && document.languageId == DEFAULT_MODE.language) {
        console.log("Diagnostic start");
        let abcImporter = new sfb_f_1.ACEImporter();
        try {
            let contents = await Util_1.Util.getContentItemsFromDocument(document);
            console.log("importing for diagnostics.");
            const result = await abcImporter.importABCStory("default", "", "", "", false, {
                contents: contents
            });
            console.log("diag import done.");
            collection.clear();
        }
        catch (err) {
            console.log("diag import errored.");
            let importErrors = err.errorItems;
            let errorCollections = [];
            for (let errorItem of importErrors) {
                console.log(document.uri);
                if (errorItem.sourceID != document.uri.fsPath) {
                    continue;
                }
                let lineNumber = errorItem.lineNumber - 1;
                let textLine = document.lineAt(lineNumber);
                errorCollections.push({
                    code: '',
                    message: errorItem.errorMessage,
                    range: textLine.range,
                    severity: vscode.DiagnosticSeverity.Error,
                    source: '',
                    relatedInformation: []
                });
            }
            collection.set(document.uri, errorCollections);
        }
    }
    else {
        collection.clear();
    }
    console.log("Diagnostic end");
}
//# sourceMappingURL=extension.js.map