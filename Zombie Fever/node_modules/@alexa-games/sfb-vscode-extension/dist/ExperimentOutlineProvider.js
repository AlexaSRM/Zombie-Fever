"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vscode = require("vscode");
const sfb_f_1 = require("@alexa-games/sfb-f");
class ExperimentOutlineProvider {
    constructor(context) {
        this.context = context;
        this._onDidChangeTreeData = new vscode.EventEmitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
        this.tree = {};
        vscode.window.onDidChangeActiveTextEditor(() => this.onActiveEditorChanged());
        vscode.workspace.onDidChangeTextDocument(e => this.onDocumentChanged(e));
    }
    async refresh(offset) {
        const enabled = vscode.window.activeTextEditor.document.languageId === 'abc-format';
        if (enabled) {
            let titleChanged = false;
            let names = {};
            if (this.tree) {
                for (let index of Object.keys(this.tree)) {
                    names[this.tree[index].id] = true;
                }
            }
            let sceneRegex = /^[\s]*?@.+?$/gm;
            let matches = this.editor.document.getText().match(sceneRegex);
            for (let newTitle of matches) {
                if (!names[newTitle.replace(/[\@]+/g, "").trim().toLowerCase()]) {
                    titleChanged = true;
                }
            }
            if (!this.tree || matches.length != this.tree.length || titleChanged) {
                await this.parseTree();
            }
            if (offset) {
                this._onDidChangeTreeData.fire(offset);
            }
            else {
                this._onDidChangeTreeData.fire();
            }
        }
    }
    async onActiveEditorChanged() {
        if (vscode.window.activeTextEditor) {
            if (vscode.window.activeTextEditor.document.uri.scheme === 'file') {
                const enabled = vscode.window.activeTextEditor.document.languageId === 'abc-format';
                vscode.commands.executeCommand('setContext', 'abcExperimentOutlineEnabled', enabled);
                if (enabled) {
                    await this.parseTree();
                    await this.refresh();
                }
            }
        }
        else {
            vscode.commands.executeCommand('setContext', 'abcExperimentOutlineEnabled', false);
        }
    }
    async onDocumentChanged(changeEvent) {
        console.log("Tree on Document Changed start.");
        if (this.editor && changeEvent.document.uri.toString() === this.editor.document.uri.toString()) {
            let titleChanged = false;
            let names = {};
            if (this.tree) {
                for (let index of Object.keys(this.tree)) {
                    names[this.tree[index].id] = true;
                }
            }
            let sceneRegex = /(?:^[\s]*?@).+?$/gm;
            let matches = this.editor.document.getText().match(sceneRegex);
            if (matches == null) {
                this.tree = [];
                this._onDidChangeTreeData.fire();
                console.log("Tree on Document Changed end.");
                return;
            }
            else {
                for (let newTitle of matches) {
                    if (!names[newTitle.replace(/[\@]+/g, "").trim().toLowerCase()]) {
                        titleChanged = true;
                    }
                }
                if (!this.tree || matches.length != this.tree.length || titleChanged) {
                    await this.parseTree();
                    this._onDidChangeTreeData.fire();
                    console.log("Tree on Document Changed end.");
                    return;
                }
            }
        }
    }
    async parseTree() {
        const enabled = vscode.window.activeTextEditor.document.languageId === 'abc-format';
        if (enabled) {
            this.text = '';
            this.editor = vscode.window.activeTextEditor;
            this.tree = [];
            if (this.editor && this.editor.document) {
                this.text = this.editor.document.getText();
                let abcImporter = new sfb_f_1.ACEImporter();
                try {
                    let importedStory = await abcImporter.importABCStory("default", "", "", "", false, {
                        content: this.text,
                        ignoreSyntaxError: true
                    });
                    this.tree = importedStory.scenes;
                }
                catch (err) {
                    // ignore import error
                }
            }
        }
    }
    getChildren(scene) {
        if (scene) {
            return Promise.resolve([]);
        }
        else {
            return Promise.resolve(this.tree ? this.tree : []);
        }
    }
    getTreeItem(scene) {
        if (scene.id) {
            let treeItem = new vscode.TreeItem(scene.id, vscode.TreeItemCollapsibleState.None);
            let sourceLocation = this.editor.document.positionAt(scene.customProperties.sourceLocation);
            let letterAtPosition = this.editor.document.getText(new vscode.Range(sourceLocation, sourceLocation.translate(0, 1)));
            while (letterAtPosition !== "@" && this.editor.document.validatePosition(sourceLocation).isEqual(sourceLocation)) {
                sourceLocation = sourceLocation.translate(0, 1);
                letterAtPosition = this.editor.document.getText(new vscode.Range(sourceLocation, sourceLocation.translate(0, 1)));
            }
            treeItem.command = {
                command: 'extension.openStorySelectionExperiment',
                title: '',
                arguments: [new vscode.Range(sourceLocation, sourceLocation)]
            };
            treeItem.iconPath = {
                light: this.context.asAbsolutePath('resources/scene_icon.svg'),
                dark: this.context.asAbsolutePath('resources/scene_icon_dark.svg')
            };
            treeItem.contextValue = scene.type;
            treeItem.resourceUri;
            return treeItem;
        }
        return null;
    }
    select(range) {
        this.editor.revealRange(range, vscode.TextEditorRevealType.AtTop);
    }
}
exports.ExperimentOutlineProvider = ExperimentOutlineProvider;
//# sourceMappingURL=ExperimentOutlineProvider.js.map