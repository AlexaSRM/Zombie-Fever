"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sfb_f_1 = require("@alexa-games/sfb-f");
class AlexaExtension {
    async post(param) {
        const driver = param.driver;
        const handlerInput = param.userInputHelper.getHandlerInput();
        if (handlerInput) {
            const ssmlPromises = [
                driver.getSpeechSSMLText(),
                driver.getRepromptSSMLText()
            ];
            const resultSSML = await Promise.all(ssmlPromises);
            const speechOutput = resultSSML[0];
            let repromptOutput = resultSSML[1];
            if (!repromptOutput || repromptOutput.trim().length === 0) {
                repromptOutput = speechOutput;
            }
            if (sfb_f_1.StoryStateHelper.isStoryPaused(driver.getCurrentStoryState()) || sfb_f_1.StoryStateHelper.isEndingReached(driver.getCurrentStoryState())) {
                handlerInput.responseBuilder.withShouldEndSession(true);
            }
            else {
                handlerInput.responseBuilder.reprompt(repromptOutput);
            }
            handlerInput.responseBuilder
                .speak(speechOutput)
                .getResponse();
        }
    }
    async pre(param) {
        const inputHelper = param.userInputHelper;
        const handlerInput = inputHelper.getHandlerInput();
        if (handlerInput) {
            const parsedInput = this.parseASKHandlerInput(handlerInput);
            if (parsedInput.intent)
                inputHelper.setInputIntent(parsedInput.intent);
            if (parsedInput.value)
                inputHelper.setInputValue(parsedInput.value);
            if (parsedInput.slots)
                inputHelper.setInputSlots(parsedInput.slots);
        }
        const isPausingIntent = this.isPausingIntent(inputHelper.getInputIntent() || "");
        const isForceQuitIntent = this.isForceQuitIntent(inputHelper.getInputIntent() || "");
        const isIntentExpected = sfb_f_1.StoryStateHelper.isInputExpected(param.storyState, inputHelper.getUserInput(), param.locale);
        if (isForceQuitIntent || (isPausingIntent && !isIntentExpected)) {
            param.driver.pauseStory();
        }
    }
    parseASKHandlerInput(handlerInput) {
        let userInput = {};
        if (handlerInput.requestEnvelope.request.type === 'LaunchRequest' || handlerInput.requestEnvelope.request.type === 'SessionEndedRequest') {
            userInput.intent = handlerInput.requestEnvelope.request.type;
        }
        else if (handlerInput.requestEnvelope.request.type === 'IntentRequest') {
            userInput.intent = handlerInput.requestEnvelope.request.intent.name;
            let slots = handlerInput.requestEnvelope.request.intent.slots;
            let foundSlots = [];
            let valueStringCollections = "";
            if (slots) {
                for (let slotName of Object.keys(slots)) {
                    if (slots[slotName] && slots[slotName].value) {
                        let resolutionEntities = slots[slotName].resolutions;
                        let slotIndexToUse = 0;
                        if (resolutionEntities && resolutionEntities.resolutionsPerAuthority) {
                            for (let i = 0; i < resolutionEntities.resolutionsPerAuthority.length; i++) {
                                console.log("CHECKING " + i + " " + JSON.stringify(resolutionEntities.resolutionsPerAuthority[i]));
                                if (resolutionEntities.resolutionsPerAuthority[i].status.code === 'ER_SUCCESS_MATCH') {
                                    slotIndexToUse = i;
                                    console.log("BREAKING at : " + slotIndexToUse);
                                    break;
                                }
                            }
                        }
                        if (resolutionEntities && resolutionEntities.resolutionsPerAuthority && resolutionEntities.resolutionsPerAuthority[slotIndexToUse]
                            && resolutionEntities.resolutionsPerAuthority[slotIndexToUse].status.code === 'ER_SUCCESS_MATCH') {
                            let resolution = resolutionEntities.resolutionsPerAuthority[slotIndexToUse].values[0].value.name;
                            foundSlots.push({
                                name: slots[slotName].name,
                                value: resolution
                            });
                            valueStringCollections += " " + resolution;
                        }
                        else if (!resolutionEntities || !resolutionEntities.resolutionsPerAuthority) {
                            foundSlots.push({
                                name: slots[slotName].name,
                                value: slots[slotName].value || ""
                            });
                            valueStringCollections += " " + slots[slotName].value;
                        }
                    }
                }
            }
            if (valueStringCollections.trim().length > 0) {
                userInput.value = valueStringCollections.trim();
            }
            userInput.slots = foundSlots;
        }
        return userInput;
    }
    isPausingIntent(intent) {
        return intent == "AMAZON.PauseIntent" || intent == "AMAZON.CancelIntent";
    }
    isForceQuitIntent(intent) {
        return intent == "SessionEndedRequest" || intent == "AMAZON.StopIntent";
    }
}
exports.AlexaExtension = AlexaExtension;
//# sourceMappingURL=alexaExtension.js.map