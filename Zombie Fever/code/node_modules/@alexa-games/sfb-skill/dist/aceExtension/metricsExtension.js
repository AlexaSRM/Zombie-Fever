"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const sfb_f_1 = require("@alexa-games/sfb-f");
const v4_1 = __importDefault(require("uuid/v4"));
class MetricsExtension {
    constructor(sendMetricsFunction) {
        this.reservedKeys = new Set();
        if (sendMetricsFunction) {
            this.sendMetricsEvent = sendMetricsFunction;
        }
        this.reservedKeys.add('sceneId');
        this.reservedKeys.add('previousSceneId');
        this.metricEvent = this.getDefaultMetricsEvent();
    }
    async post(param) {
        const request = param.userInputHelper.getHandlerInput();
        const unhandledChoice = param.driver.isUnhandledChoice();
        if (unhandledChoice) {
            this.metricEvent.details.unhandledChoice = true;
        }
        this.metricEvent.details.sceneId = this.getLast(param.driver.getVisitedSceneIDsOnRun());
        this.metricEvent.locale = param.locale;
        this.addRequestParameters(request);
        const previousScenes = param.driver.getVisitedSceneIDsOnRun();
        try {
            if (previousScenes.length > 1) {
                await this.logPreviousScenes(previousScenes);
            }
            else {
                await this.sendMetricsEvent(this.metricEvent);
            }
            this.metricEvent = this.getDefaultMetricsEvent();
        }
        catch (err) {
            throw new Error('failed to send metrics');
        }
    }
    addRequestParameters(request) {
        try {
            if (request) {
                const session = request.requestEnvelope.session;
                const req = request.requestEnvelope.request;
                if (req) {
                    this.metricEvent.timestamp = req.timestamp;
                    this.metricEvent.requestId = req.requestId;
                }
                if (session) {
                    this.metricEvent.sessionId = session.sessionId;
                    this.metricEvent.customerIdentifier = session.user.userId;
                    this.metricEvent.skillId = session.application.applicationId;
                }
            }
        }
        catch (err) {
            console.warn('[METRICS-ERROR] Error parsing properties for metrics', err);
        }
    }
    pre(param) {
        this.metricEvent.details.previousSceneId = sfb_f_1.StoryStateHelper.getCurrentSceneID(param.driver.getCurrentStoryState()) || '';
        return Promise.resolve();
    }
    async trackMetric(param) {
        const detailKey = param.instructionParameters['type'];
        if (detailKey && this.canWriteKey(detailKey)) {
            const detailValue = param.instructionParameters['value'] || 1;
            this.checkForDetailOverwrite(detailKey, detailValue);
            this.metricEvent.details[detailKey] = detailValue;
        }
        else {
            console.error('[METRICS-ERROR] Cannot map type and value for trackMetric call.', JSON.stringify(param.instructionParameters));
        }
    }
    checkForDetailOverwrite(key, val) {
        if (this.metricEvent.details[key]) {
            console.error('[METRICS-ERROR] Overwriting value for type that is already set.', `
                type name: ${key}
                current value: ${this.metricEvent.details[key]}
                new value: ${val}
                `);
        }
    }
    canWriteKey(key) {
        if (this.reservedKeys.has(key)) {
            console.error(`[METRICS-ERROR] Cannot overwrite ${key}, it is reserved.`);
            return false;
        }
        return true;
    }
    async sendMetricsEvent(metricEvent) {
        console.log('[METRICS]', JSON.stringify(metricEvent));
    }
    ;
    getLast(arr) {
        if (arr.length === 0) {
            return undefined;
        }
        return arr[arr.length - 1];
    }
    async logPreviousScenes(previousScenes) {
        for (const [index, sceneId] of previousScenes.entries()) {
            const metricEvent = this.metricEvent;
            if (previousScenes[index - 1]) {
                metricEvent.details = {};
                metricEvent.details.previousSceneId = previousScenes[index - 1];
            }
            metricEvent.details.sceneId = sceneId;
            await this.sendMetricsEvent(metricEvent);
        }
    }
    getDefaultMetricsEvent() {
        return {
            skillId: '',
            timestamp: '',
            customerIdentifier: '',
            eventType: 'metrics',
            requestId: '',
            eventId: v4_1.default(),
            sessionId: '',
            stage: process.env.stage || 'stage env variable not defined',
            locale: '',
            metadata: {
                schemaVersion: '1.0'
            },
            details: {}
        };
    }
}
exports.MetricsExtension = MetricsExtension;
//# sourceMappingURL=metricsExtension.js.map