"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const sfb_f_1 = require("@alexa-games/sfb-f");
const sfb_test_1 = require("@alexa-games/sfb-test");
const __1 = require("../..");
const chai = __importStar(require("chai"));
const chai_exclude_1 = __importDefault(require("chai-exclude"));
const chai_1 = require("chai");
chai.use(chai_exclude_1.default);
describe('Metrics Extension', () => {
    let testStory;
    beforeEach("set up set up test", async (done) => {
        const instructions = new sfb_f_1.SceneDirectionBuilder();
        instructions.customDirection("fakeInstruction", {
            param1: "test-value"
        });
        const thenSection = instructions.build();
        const testStoryBuilder = new sfb_test_1.TestStoryBuilder("test-story");
        testStoryBuilder.addScene("testing scene1", "this is a test scene", thenSection);
        testStoryBuilder.addScene("testing scene2", "this is a test scene", thenSection);
        testStoryBuilder.addScene("testing scene3", "this is a test scene", thenSection);
        testStory = testStoryBuilder.build();
        done();
    });
    it('Performs a basic metrics workflow', async () => {
        const expectedOutput = [{
                skillId: 'test-application-id',
                customerIdentifier: 'test-user-id',
                eventType: 'metrics',
                requestId: 'test-request-id',
                sessionId: 'test-session-id',
                stage: 'stage env variable not defined',
                locale: 'en-US',
                metadata: { schemaVersion: '1.0' },
                details: { previousSceneId: 'testing scene2', sceneId: 'testing scene1' }
            }];
        let generatedOutput = [];
        const metricsExtension = new __1.MetricsExtension(async (m) => {
            chai_1.assert.isOk(m);
            generatedOutput.push(m);
        });
        sfb_f_1.StoryStateHelper.setCurrentSceneID(testStory, 'testing scene2');
        const extensionTester = new sfb_test_1.DriverExtensionTester({
            extensions: [],
            locale: "en-US",
            story: testStory,
            storyState: {
                system_bookmark: 'testing scene2'
            }
        });
        await extensionTester.givenIntentRequest("some random intent");
        const testParam = extensionTester.generateDriverExtensionParameter();
        testParam.driver.stage.logVisitedScene(('testing scene1'));
        sfb_f_1.StoryStateHelper.setCurrentSceneID(testStory, 'testing scene1');
        try {
            await metricsExtension.pre(testParam);
            await metricsExtension.post(testParam);
            chai_1.assert.deepEqualExcluding(generatedOutput, expectedOutput, ['eventId', 'timestamp']);
        }
        catch (err) {
            console.log(err);
            chai_1.assert.fail(err.message);
        }
    });
    it('Basic workflow with track metrics (using promise override)', async () => {
        const expectedOutput = [{
                skillId: 'test-application-id',
                customerIdentifier: 'test-user-id',
                eventType: 'metrics',
                requestId: 'test-request-id',
                sessionId: 'test-session-id',
                stage: 'stage env variable not defined',
                locale: 'en-US',
                metadata: { schemaVersion: '1.0' },
                details: {
                    previousSceneId: 'testing scene2',
                    sceneId: 'testing scene1',
                    'test-type': 'test-value'
                }
            }];
        let generatedOutput = [];
        const metricsExtension = new __1.MetricsExtension(async (m) => {
            chai_1.assert.isOk(m);
            return new Promise((resolve) => {
                generatedOutput.push(m);
                resolve();
            });
        });
        sfb_f_1.StoryStateHelper.setCurrentSceneID(testStory, 'testing scene2');
        const extensionTester = new sfb_test_1.DriverExtensionTester({
            extensions: [],
            locale: "en-US",
            story: testStory,
            storyState: {
                system_bookmark: 'testing scene2'
            }
        });
        await extensionTester.givenIntentRequest("some random intent");
        const testParam = extensionTester.generateDriverExtensionParameter();
        testParam.driver.stage.logVisitedScene(('testing scene1'));
        sfb_f_1.StoryStateHelper.setCurrentSceneID(testStory, 'testing scene1');
        try {
            await metricsExtension.pre(testParam);
            await metricsExtension.trackMetric({
                instructionParameters: {
                    type: 'test-type',
                    value: 'test-value'
                }
            });
            await metricsExtension.post(testParam);
            chai_1.assert.deepEqualExcluding(generatedOutput, expectedOutput, ['eventId', 'timestamp']);
        }
        catch (err) {
            console.log(err);
            chai_1.assert.fail(err.message);
        }
    });
    it('Does not overwrite previousScene and Scene', async () => {
        const expectedOutput = [{
                skillId: 'test-application-id',
                customerIdentifier: 'test-user-id',
                eventType: 'metrics',
                requestId: 'test-request-id',
                sessionId: 'test-session-id',
                stage: 'stage env variable not defined',
                locale: 'en-US',
                metadata: { schemaVersion: '1.0' },
                details: {
                    previousSceneId: 'testing scene2',
                    sceneId: 'testing scene1'
                }
            }];
        let generatedOutput = [];
        const metricsExtension = new __1.MetricsExtension(async (m) => {
            chai_1.assert.isOk(m);
            generatedOutput.push(m);
        });
        sfb_f_1.StoryStateHelper.setCurrentSceneID(testStory, 'testing scene2');
        const extensionTester = new sfb_test_1.DriverExtensionTester({
            extensions: [],
            locale: "en-US",
            story: testStory,
            storyState: {
                system_bookmark: 'testing scene2'
            }
        });
        await extensionTester.givenIntentRequest("some random intent");
        const testParam = extensionTester.generateDriverExtensionParameter();
        testParam.driver.stage.logVisitedScene(('testing scene1'));
        sfb_f_1.StoryStateHelper.setCurrentSceneID(testStory, 'testing scene1');
        try {
            await metricsExtension.pre(testParam);
            await metricsExtension.trackMetric({
                instructionParameters: {
                    type: 'sceneId',
                    value: 'test-value'
                }
            });
            await metricsExtension.trackMetric({
                instructionParameters: {
                    type: 'previousSceneId',
                    value: 'test-value'
                }
            });
            await metricsExtension.post(testParam);
            chai_1.assert.deepEqualExcluding(generatedOutput, expectedOutput, ['eventId', 'timestamp']);
        }
        catch (err) {
            console.log(err);
            chai_1.assert.fail(err.message);
        }
    });
    it('Handles promise rejection in override, expected to throw', async () => {
        const expectedOutput = [{
                skillId: 'test-application-id',
                customerIdentifier: 'test-user-id',
                eventType: 'metrics',
                requestId: 'test-request-id',
                sessionId: 'test-session-id',
                stage: 'stage env variable not defined',
                locale: 'en-US',
                metadata: { schemaVersion: '1.0' },
                details: {
                    previousSceneId: 'testing scene2',
                    sceneId: 'testing scene1',
                    'test-type': 'test-value'
                }
            }];
        let generatedOutput = [];
        const metricsExtension = new __1.MetricsExtension(async (m) => {
            chai_1.assert.isOk(m);
            return new Promise((resolve, reject) => {
                reject();
            });
        });
        sfb_f_1.StoryStateHelper.setCurrentSceneID(testStory, 'testing scene2');
        const extensionTester = new sfb_test_1.DriverExtensionTester({
            extensions: [],
            locale: "en-US",
            story: testStory,
            storyState: {
                system_bookmark: 'testing scene2'
            }
        });
        await extensionTester.givenIntentRequest("some random intent");
        const testParam = extensionTester.generateDriverExtensionParameter();
        testParam.driver.stage.logVisitedScene(('testing scene1'));
        sfb_f_1.StoryStateHelper.setCurrentSceneID(testStory, 'testing scene1');
        await metricsExtension.pre(testParam);
        try {
            await metricsExtension.post(testParam);
        }
        catch (err) {
            chai_1.expect(err.message).to.eq('failed to send metrics');
        }
    });
    it('Handles bad data on trackMetrics', async () => {
        const expectedOutput = [{
                skillId: 'test-application-id',
                customerIdentifier: 'test-user-id',
                eventType: 'metrics',
                requestId: 'test-request-id',
                sessionId: 'test-session-id',
                stage: 'stage env variable not defined',
                locale: 'en-US',
                metadata: { schemaVersion: '1.0' },
                details: {
                    previousSceneId: 'testing scene2',
                    sceneId: 'testing scene1',
                    'test-value': 1
                }
            }];
        let generatedOutput = [];
        const metricsExtension = new __1.MetricsExtension(async (m) => {
            chai_1.assert.isOk(m);
            generatedOutput.push(m);
        });
        sfb_f_1.StoryStateHelper.setCurrentSceneID(testStory, 'testing scene2');
        const extensionTester = new sfb_test_1.DriverExtensionTester({
            extensions: [],
            locale: "en-US",
            story: testStory,
            storyState: {
                system_bookmark: 'testing scene2'
            }
        });
        await extensionTester.givenIntentRequest("some random intent");
        const testParam = extensionTester.generateDriverExtensionParameter();
        testParam.driver.stage.logVisitedScene(('testing scene1'));
        sfb_f_1.StoryStateHelper.setCurrentSceneID(testStory, 'testing scene1');
        try {
            await metricsExtension.pre(testParam);
            await metricsExtension.trackMetric({
                instructionParameters: {
                    type: 'test-value'
                }
            });
            await metricsExtension.trackMetric({
                instructionParameters: {
                    value: 'test-value'
                }
            });
            await metricsExtension.trackMetric({
                instructionParameters: {
                    pie: 'test-value'
                }
            });
            await metricsExtension.post(testParam);
            chai_1.assert.deepEqualExcluding(generatedOutput, expectedOutput, ['eventId', 'timestamp']);
        }
        catch (err) {
            console.log(err);
            chai_1.assert.fail(err.message);
        }
    });
    it('Initializes', async () => {
        const metricsExtension = new __1.MetricsExtension();
        chai_1.assert.isOk(metricsExtension);
        const metricsExtensionWithOverload = new __1.MetricsExtension(async (m) => { });
        chai_1.assert.isOk(metricsExtensionWithOverload);
    });
});
//# sourceMappingURL=metricsExtension.spec.js.map