{"version":3,"file":"s3AudioAccessor.js","sourceRoot":"","sources":["../../audioAccessor/s3AudioAccessor.ts"],"names":[],"mappings":"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","sourcesContent":["import {AudioFileAccessor} from './audioFileAccessor';\nimport {S3} from 'aws-sdk';\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as urlParser from 'url';\n\nimport * as http from 'http';\nimport * as https from 'https';\n\nconst supportedProtocol: {[key: string]: any} = {\n    \"http:\": http,\n    \"https:\": https\n}\n\nexport enum S3FileStatus {\n    Unknown = 0,\n    Exists = 1,\n    NotExists = 2\n}\n\n// This cache prevents repeat S3 Head requests for files to speed up .exists commands,\n// and updates this cache when an upload is successful.\nexport const s3FileStatusStaticCache : {[key: string]: S3FileStatus} = {}; \n\n/**\n * Implentation of AudioFileAccessor to use S3 as cache storage.\n */\nexport class S3AudioAccessor implements AudioFileAccessor {\n    static readonly CACHE_DIR_NAME = \"pollyCache\";\n\n    private static s3Client: S3;\n\n    constructor(private setting: {\n        bucketName: string;\n        s3DomainName: string;\n        audioWorkingDir: string;\n        s3Client?: S3\n    }) {\n        if (setting.s3Client) {\n            S3AudioAccessor.s3Client = setting.s3Client;\n        } else {\n            S3AudioAccessor.s3Client = new S3();\n        }\n    }\n\n    exists(audioName: string): Promise<boolean> {\n        return new Promise<boolean> (async (resolve) => {\n\n            const key = `${S3AudioAccessor.CACHE_DIR_NAME}/${audioName}`;\n\n            const statusKey = this.setting.bucketName + \":\" + key;\n            const s3FileStatus = s3FileStatusStaticCache[statusKey];\n            if(s3FileStatus === S3FileStatus.Exists) {\n                return resolve(true); \n            } else if(s3FileStatus === S3FileStatus.NotExists) {\n                return resolve(false);\n            }\n\n            const params: S3.HeadObjectRequest = {\n                Bucket: this.setting.bucketName, \n                Key: key            \n            };\n        \n            try {\n                S3AudioAccessor.s3Client.headObject(params, function(err: any, data: any) {\n                    if (err) {\n                        s3FileStatusStaticCache[statusKey] = S3FileStatus.NotExists;\n                        resolve(false);\n                    } else {\n                        s3FileStatusStaticCache[statusKey] = S3FileStatus.Exists;\n                        resolve(true);\n                    }\n                });\n            } catch (err) {\n                // Don't update S3 file status cache on s3 exception, maybe it was a temporary error\n                resolve(false);\n            }\n        });        \n    }\n\n    async getAudioURL(audioName: string): Promise<string> {\n        return `https://${this.setting.s3DomainName}/${this.setting.bucketName}/pollyCache/${audioName}`;\n    }\n\n    async uploadAudio(audioName: string, workingDirectory: string): Promise<string> {\n        return new Promise<string> (async (resolve, reject) => {\n            const localFilePath = path.resolve(workingDirectory, audioName);\n\n            const key = `${S3AudioAccessor.CACHE_DIR_NAME}/${audioName}`;\n\n            const statusKey = this.setting.bucketName + \":\" + key;\n            const s3FileStatus = s3FileStatusStaticCache[statusKey];\n\n            // If the file already exists in S3, don't upload it again. To fix a bad file, you must go delete it.\n            if(s3FileStatus === S3FileStatus.Exists) {\n                return resolve(await this.getAudioURL(audioName)); \n            }\n\n            try {\n                if(!fs.existsSync(localFilePath)) {\n                    return reject(\"Upload audio filepath does not exist: \" + localFilePath);\n                }\n\n                const audioFileData = fs.readFileSync(localFilePath);\n\n                const params: S3.PutObjectRequest = {\n                    Bucket: this.setting.bucketName,\n                    Key: key,\n                    Body: audioFileData,\n                    ACL: 'public-read'\n                };\n\n                console.info(`Uploading audio file '${audioName}'.`);\n\n                S3AudioAccessor.s3Client.putObject(params, async (err: any, data: any) => {\n                    if (err) {\n                        return reject(err);\n                    }\n\n                    // On success, update the S3 file status cache\n                    s3FileStatusStaticCache[statusKey] = S3FileStatus.Exists;\n                    return resolve(await this.getAudioURL(audioName));\n                });\n            } catch (err) {\n                throw err;\n            }\n        });\n    }\n\n    async downloadAudio(audioUrl: string, workingDirectory: string): Promise<void> {\n        return new Promise<void> (async (resolve, reject) => {\n\n            const parsedUrl = urlParser.parse(audioUrl);\n            \n            const lib = supportedProtocol[parsedUrl.protocol || \"http:\"];\n\n            if (lib) {\n                lib.get(audioUrl, (response: any) => {\n                    const filename = path.basename(audioUrl);\n                    const localFilePath = path.resolve(workingDirectory, filename);\n                    const writeStream = fs.createWriteStream(localFilePath);\n\n                    const stream = response.pipe(writeStream);\n                    stream.on('close', function () {\n                        return resolve();\n                    });\n                });\n            } else {\n                return reject(\"invalid URL Protocol\");\n            }\n        });\n    }\n}"]}