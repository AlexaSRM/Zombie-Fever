"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const aws_sdk_1 = require("aws-sdk");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const urlParser = __importStar(require("url"));
const http = __importStar(require("http"));
const https = __importStar(require("https"));
const supportedProtocol = {
    "http:": http,
    "https:": https
};
var S3FileStatus;
(function (S3FileStatus) {
    S3FileStatus[S3FileStatus["Unknown"] = 0] = "Unknown";
    S3FileStatus[S3FileStatus["Exists"] = 1] = "Exists";
    S3FileStatus[S3FileStatus["NotExists"] = 2] = "NotExists";
})(S3FileStatus = exports.S3FileStatus || (exports.S3FileStatus = {}));
// This cache prevents repeat S3 Head requests for files to speed up .exists commands,
// and updates this cache when an upload is successful.
exports.s3FileStatusStaticCache = {};
/**
 * Implentation of AudioFileAccessor to use S3 as cache storage.
 */
class S3AudioAccessor {
    constructor(setting) {
        this.setting = setting;
        if (setting.s3Client) {
            S3AudioAccessor.s3Client = setting.s3Client;
        }
        else {
            S3AudioAccessor.s3Client = new aws_sdk_1.S3();
        }
    }
    exists(audioName) {
        return new Promise(async (resolve) => {
            const key = `${S3AudioAccessor.CACHE_DIR_NAME}/${audioName}`;
            const statusKey = this.setting.bucketName + ":" + key;
            const s3FileStatus = exports.s3FileStatusStaticCache[statusKey];
            if (s3FileStatus === S3FileStatus.Exists) {
                return resolve(true);
            }
            else if (s3FileStatus === S3FileStatus.NotExists) {
                return resolve(false);
            }
            const params = {
                Bucket: this.setting.bucketName,
                Key: key
            };
            try {
                S3AudioAccessor.s3Client.headObject(params, function (err, data) {
                    if (err) {
                        exports.s3FileStatusStaticCache[statusKey] = S3FileStatus.NotExists;
                        resolve(false);
                    }
                    else {
                        exports.s3FileStatusStaticCache[statusKey] = S3FileStatus.Exists;
                        resolve(true);
                    }
                });
            }
            catch (err) {
                // Don't update S3 file status cache on s3 exception, maybe it was a temporary error
                resolve(false);
            }
        });
    }
    async getAudioURL(audioName) {
        return `https://${this.setting.s3DomainName}/${this.setting.bucketName}/pollyCache/${audioName}`;
    }
    async uploadAudio(audioName, workingDirectory) {
        return new Promise(async (resolve, reject) => {
            const localFilePath = path.resolve(workingDirectory, audioName);
            const key = `${S3AudioAccessor.CACHE_DIR_NAME}/${audioName}`;
            const statusKey = this.setting.bucketName + ":" + key;
            const s3FileStatus = exports.s3FileStatusStaticCache[statusKey];
            // If the file already exists in S3, don't upload it again. To fix a bad file, you must go delete it.
            if (s3FileStatus === S3FileStatus.Exists) {
                return resolve(await this.getAudioURL(audioName));
            }
            try {
                if (!fs.existsSync(localFilePath)) {
                    return reject("Upload audio filepath does not exist: " + localFilePath);
                }
                const audioFileData = fs.readFileSync(localFilePath);
                const params = {
                    Bucket: this.setting.bucketName,
                    Key: key,
                    Body: audioFileData,
                    ACL: 'public-read'
                };
                console.info(`Uploading audio file '${audioName}'.`);
                S3AudioAccessor.s3Client.putObject(params, async (err, data) => {
                    if (err) {
                        return reject(err);
                    }
                    // On success, update the S3 file status cache
                    exports.s3FileStatusStaticCache[statusKey] = S3FileStatus.Exists;
                    return resolve(await this.getAudioURL(audioName));
                });
            }
            catch (err) {
                throw err;
            }
        });
    }
    async downloadAudio(audioUrl, workingDirectory) {
        return new Promise(async (resolve, reject) => {
            const parsedUrl = urlParser.parse(audioUrl);
            const lib = supportedProtocol[parsedUrl.protocol || "http:"];
            if (lib) {
                lib.get(audioUrl, (response) => {
                    const filename = path.basename(audioUrl);
                    const localFilePath = path.resolve(workingDirectory, filename);
                    const writeStream = fs.createWriteStream(localFilePath);
                    const stream = response.pipe(writeStream);
                    stream.on('close', function () {
                        return resolve();
                    });
                });
            }
            else {
                return reject("invalid URL Protocol");
            }
        });
    }
}
exports.S3AudioAccessor = S3AudioAccessor;
S3AudioAccessor.CACHE_DIR_NAME = "pollyCache";
//# sourceMappingURL=s3AudioAccessor.js.map