{"version":3,"file":"fuzzy-responses.js","sourceRoot":"","sources":["../fuzzy-responses.ts"],"names":[],"mappings":";AAAA;;EAEE;;AAEF,2CAA2C;AAW3C,0HAA0H;AAC1H,0FAA0F;AAC1F,SAAgB,gBAAgB,CAAC,cAAsB,EAAE,cAAwB,EAAE,GAAS;IAKxF,IAAI,mBAAmB,GAAmB,EAAE,CAAC;IAE7C,IAAG,CAAC,cAAc,EAAE;QAChB,cAAc,GAAG,EAAE,CAAC;KACvB;IAED,cAAc,CAAC,OAAO,CAAC,UAAS,aAAkB;QAE9C,IAAI,0BAA0B,GAAG,aAAa,CAAC;QAE/C,IAAG,GAAG,EAAE;YACJ,0BAA0B,GAAG,aAAa,CAAC,GAAG,CAAC,CAAC;SACnD;QAED,mBAAmB,CAAC,0BAA0B,CAAC,GAAG;YAC9C,KAAK,EAAE,CAAC;YACR,KAAK,EAAE,CAAC;SACX,CAAC;QAEF,cAAc,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,UAAS,IAAI;YAC3C,IAAI,MAAM,GAAG,IAAI,MAAM,CAAC,SAAS,GAAG,wBAAY,CAAC,IAAI,CAAC,GAAG,SAAS,EAAE,IAAI,CAAC,CAAC;YAE1E,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,0BAA0B,CAAC,CAAC,KAAK,IAAI,EAAE;gBACvD,mBAAmB,CAAC,0BAA0B,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC;gBAE3D,2IAA2I;gBAC3I,MAAM;aACT;QACL,CAAC,CAAC,CAAC;QAEH,mBAAmB,CAAC,0BAA0B,CAAC,CAAC,KAAK,GAAG,mBAAmB,CAAC,0BAA0B,CAAC,CAAC,KAAK,GAAC,0BAA0B,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC;IAC/J,CAAC,CAAC,CAAC;IAEH,IAAI,gBAAgB,GAAkB,IAAI,CAAC;IAC3C,IAAI,qBAAqB,GAAG;QACxB,KAAK,EAAE,CAAC;QACR,KAAK,EAAE,CAAC;KACX,CAAC;IAEF,KAAK,MAAM,aAAa,IAAI,mBAAmB,EAAE;QAE7C,IAAI,kBAAkB,GAAG,mBAAmB,CAAC,aAAa,CAAC,CAAC;QAE5D,IAAI,kBAAkB,CAAC,KAAK,IAAI,qBAAqB,CAAC,KAAK,IAAI,kBAAkB,CAAC,KAAK,IAAI,qBAAqB,CAAC,KAAK,EAAE;YACpH,gBAAgB,GAAG,aAAa,CAAC;YACjC,qBAAqB,GAAG,kBAAkB,CAAC;SAC9C;KACJ;IAED,IAAI,YAAY,GAAG,CAAC,CAAC,CAAC;IACtB,IAAI,WAAW,GAAkB,IAAI,CAAC;IACtC,IAAG,CAAC,GAAG,EAAE;QACL,YAAY,GAAG,cAAc,CAAC,OAAO,CAAC,gBAAgB,IAAI,EAAE,CAAC,CAAC;QAC9D,WAAW,GAAG,gBAAgB,CAAC;KAClC;SAAM;QACH,KAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC3C,IAAI,IAAI,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;YAE7B,IAAI,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;YACxB,IAAG,gBAAgB,KAAK,OAAO,EAAE;gBAC7B,YAAY,GAAG,CAAC,CAAC;gBACjB,WAAW,GAAG,IAAI,CAAC;gBACnB,MAAM;aACT;SACJ;KACJ;IAED,IAAI,qBAAqB,CAAC,KAAK,GAAG,CAAC,EAAE;QACjC,OAAO;YACH,KAAK,EAAE,YAAY;YACnB,QAAQ,EAAE,WAAW;SACxB,CAAC;KACL;SAAM;QACH,OAAO,SAAS,CAAC;KACpB;AACL,CAAC;AAhFD,4CAgFC","sourcesContent":["/*\n// fuzzy-responses module: a helper module to pick a fuzzy response from an actual response\n*/\n\nimport { escapeRegExp } from './utilities';\n\ntype ResponseScore = {\n    match: number,\n    ratio: number\n};\n\ntype ResponseScores = {\n    [key: string] : ResponseScore\n};\n\n// Pick best response from the given list of strings, if key is provided, instead of a list of strings you can pass a list\n// of objects and the item inside of the object named key will be used for the text match.\nexport function pickBestResponse(actualResponse: string, fuzzyResponses: string[], key?: any): {\n    index: number,\n    response: string | null\n} | undefined\n {\n    let fuzzyResponseScores: ResponseScores = {};\n\n    if(!actualResponse) {\n        actualResponse = \"\";\n    }\n\n    fuzzyResponses.forEach(function(fuzzyResponse: any) {\n\n        let fuzzyResponseComparisonVal = fuzzyResponse;\n\n        if(key) {\n            fuzzyResponseComparisonVal = fuzzyResponse[key];\n        }\n\n        fuzzyResponseScores[fuzzyResponseComparisonVal] = {\n            match: 0,\n            ratio: 0\n        };\n\n        actualResponse.split(\" \").forEach(function(item) {\n            let regExp = new RegExp('(^|\\\\s)' + escapeRegExp(item) + '($|\\\\s)', 'ig');\n\n            while ((regExp.exec(fuzzyResponseComparisonVal)) !== null) {\n                fuzzyResponseScores[fuzzyResponseComparisonVal].match += 1;\n\n                // @larpente: Changing so that repeated words in the response string only count for 1 (like for word 'the' for example), by 'break'ing here\n                break;\n            }\n        }); \n\n        fuzzyResponseScores[fuzzyResponseComparisonVal].ratio = fuzzyResponseScores[fuzzyResponseComparisonVal].match/fuzzyResponseComparisonVal.split(\" \").length;\n    });\n\n    let fuzzyResponseMax: string | null = null;\n    let fuzzyResponseMaxScore = {\n        match: 0,\n        ratio: 0\n    };\n\n    for (const fuzzyResponse in fuzzyResponseScores) {\n\n        let fuzzyResponseScore = fuzzyResponseScores[fuzzyResponse];\n\n        if (fuzzyResponseScore.match >= fuzzyResponseMaxScore.match && fuzzyResponseScore.ratio >= fuzzyResponseMaxScore.ratio) {\n            fuzzyResponseMax = fuzzyResponse;\n            fuzzyResponseMaxScore = fuzzyResponseScore;\n        }\n    }\n\n    let matchedIndex = -1;\n    let matchedItem: string | null = null;\n    if(!key) {\n        matchedIndex = fuzzyResponses.indexOf(fuzzyResponseMax || '');\n        matchedItem = fuzzyResponseMax;\n    } else {\n        for(let i = 0; i < fuzzyResponses.length; i++) {\n            let resp = fuzzyResponses[i];\n\n            let content = resp[key];\n            if(fuzzyResponseMax === content) {\n                matchedIndex = i;\n                matchedItem = resp;\n                break;\n            }\n        }        \n    }\n    \n    if (fuzzyResponseMaxScore.match > 0) {\n        return {\n            index: matchedIndex,\n            response: matchedItem\n        };\n    } else {\n        return undefined;\n    }\n}\n"]}