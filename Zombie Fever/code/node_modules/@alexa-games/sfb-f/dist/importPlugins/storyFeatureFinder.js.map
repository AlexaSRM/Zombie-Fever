{"version":3,"file":"storyFeatureFinder.js","sourceRoot":"","sources":["../../importPlugins/storyFeatureFinder.ts"],"names":[],"mappings":"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","sourcesContent":["import { \n    StoryBlockFinder, \n    EndType, \n    BlockStartExpressions\n} from './storyBlockFinder';\nimport { StoryBlockRange } from './storyBlockRange';\nimport { StoryBlock, SceneStoryBlock } from './storyBlock';\n\nexport class StoryFeatureFinder {\n    // Looks for -> scene or <-> scene style references on a line\n    private static readonly ReferenceNotationMatch = /^\\s*<?->\\s+(.*)\\s*$/;\n\n    // Looks for { } or spaces on a line. Other characters result in no-match\n    private static readonly BracesOrSpaces = /^[\\s\\{\\}]*$/;\n\n\n    constructor(private lines: string[]) {\n    }\n\n    /**\n     * Finds the range of the given scene. Returns undefined if the scene is not present.\n     * @param sceneId ID of the scene to find.\n     */\n    public findScene(sceneId: string): SceneStoryBlock | undefined {\n        sceneId = sceneId.trim();\n\n        const sceneFinder = new StoryBlockFinder({\n            blockEndType: EndType.NextBlock,\n            blockName: sceneId,\n            lines: this.lines,\n            blockStartMatch: BlockStartExpressions.SceneMatch\n        });\n        \n        const result = sceneFinder.getNextBlock();\n        if (result) {\n            return new SceneStoryBlock(result.lines, result.blockName, result.range);\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Returns Ranges containing references to the specified scene. \n     * @param sceneId Scene ID to find references to.\n     */\n    public getReferences(sceneId: string): StoryBlockRange[] {\n        sceneId = sceneId.trim();\n\n        const result: StoryBlockRange[] = [];\n\n        const sceneFinder = new StoryBlockFinder({\n            blockEndType: EndType.NextBlock,\n            lines: this.lines,\n            blockStartMatch: BlockStartExpressions.SceneMatch\n        });\n\n        let sceneBlock = sceneFinder.getNextBlock();\n        while (sceneBlock) {\n            const thenFinder = new StoryBlockFinder({\n                blockEndType: EndType.NextBlock,\n                blockName: 'then',\n                lines: this.lines,\n                range: sceneBlock.range,\n                blockStartMatch: BlockStartExpressions.ScenePropMatch            \n            });\n    \n            let thenBlock = thenFinder.getNextBlock();\n            while (thenBlock) {\n                const refFinder = new StoryBlockFinder({\n                    blockEndType: EndType.OneLine,\n                    range: thenBlock.range,\n                    lines: this.lines,\n                    blockStartMatch: StoryFeatureFinder.ReferenceNotationMatch,\n                    blockName: sceneId            \n                });\n\n                let reference = refFinder.getNextBlock();\n                while (reference) {\n                    result.push(reference.range);\n                    reference = refFinder.getNextBlock();\n                }\n\n                if (result.length > 0) {\n                    this.expandToSimpleHearBlocks(result, thenBlock.range);\n                }\n    \n                thenBlock = thenFinder.getNextBlock();\n            }\n\n            sceneBlock = sceneFinder.getNextBlock();\n        }\n\n        return result;\n    }\n\n    /**\n     * Return range of the given property type or undefined if it is not found.\n     * @param sceneBlock Range to include in the quest for the scene property.\n     * @param propertyType Values like 'say', 'then', etc.\n     */\n    public getScenePropertyByType(sceneBlock: StoryBlockRange, propertyType: string): StoryBlock | undefined {\n        const blockFinder = new StoryBlockFinder({\n            blockEndType: EndType.NextBlock,\n            blockName: propertyType,\n            lines: this.lines,\n            range: sceneBlock,\n            blockStartMatch: BlockStartExpressions.ScenePropMatch            \n        });\n\n        return blockFinder.getNextBlock();\n    }\n\n    /**\n     * Find simple hear blocks (blocks with nothing else but a single reference) and replaces the reference to the\n     * entire hear block.\n     * @param result List of references to expand\n     * @param thenBlock Range to scan\n     */\n    private expandToSimpleHearBlocks(result: StoryBlockRange[], thenBlock: StoryBlockRange): void {\n        \n        const hearFinder = new StoryBlockFinder({\n            blockEndType: EndType.BraceMatch,\n            range: thenBlock,\n            lines: this.lines,\n            blockStartMatch: BlockStartExpressions.HearMatch            \n        });\n\n        let index = 0;\n\n        let hearBlock = hearFinder.getNextBlock();\n        while (index < result.length && hearBlock) {\n            while (index < result.length &&\n                result[index].end.row < hearBlock.range.start.row) {\n                // Skip past results that precede the current hear block.\n                index++;\n            }\n\n            if (index < result.length && \n                result[index].intersectsWith(hearBlock.range)) {\n                // Is hear block simple? use it!\n                if (this.isBlockSimple(hearBlock.range, result[index])) {\n                    result[index] = hearBlock.range;\n                }\n                index++;\n            }\n\n            hearBlock = hearFinder.getNextBlock();\n        }\n    }\n\n    // A simple block has only spaces or braces on lines that are outside of the ignore range.\n    // The first line may have any characters.  For example:\n    //     hear foo \n    //     {\n    //         -> test (ignored)\n    //\n    //     }\n    private isBlockSimple(block: StoryBlockRange, ignore: StoryBlockRange): boolean {\n        for (let i = block.start.row + 1; i <= block.end.row; i++) {\n            let line = block.cropToRange(this.lines[i], i);\n\n            if (i === ignore.start.row && i < ignore.end.row) {\n                continue;\n            }\n\n            if (!StoryFeatureFinder.BracesOrSpaces.test(line)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}"]}