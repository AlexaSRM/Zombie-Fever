{"version":3,"file":"storyBlockFinder.js","sourceRoot":"","sources":["../../importPlugins/storyBlockFinder.ts"],"names":[],"mappings":"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","sourcesContent":["import { StoryBlockRange } from './storyBlockRange';\nimport { StoryBlock } from './storyBlock';\n\nexport class BlockStartExpressions {\n     // Matches lines whose first non-whitespace character is a @\n     public static readonly SceneMatch = /^\\s*@\\s*(.*)$/;\n\n     // Match lines whose first non-whitespace character is a *\n     public static readonly ScenePropMatch = /^\\s*\\*\\s*(.*)$/;\n \n     // Match lines that start with a 'hear' statement.\n     public static readonly HearMatch = /^\\s*hear\\s+(.*)\\s*$/i;\n}\n\n\nexport enum EndType {\n    /**\n     * Current block ends when next block is found, or end of the range is found.\n     */\n    NextBlock,\n\n    /**\n     * Current block ends when a final closing brace is found.\n     */\n    BraceMatch,\n\n    /**\n     * Block is always one line long\n     */\n    OneLine\n}\n\nexport interface StoryBlockFinderParameters {\n    /**\n     * Array of strings that represent the story to be searched\n     */\n    lines: string[];\n\n    /**\n     * Range within the provided lines to be searched.\n     */\n    range?: StoryBlockRange;\n\n    /**\n     * Regular expression that will match when a line is the start of a block\n     */\n    blockStartMatch: RegExp;\n\n    /**\n     * Indicates what marks the end of a block. \n     */\n    blockEndType: EndType;\n    \n    /**\n     * If this property is specified, then block is considered a \n     * match if group 1 of the blockStartMatch expression matches this string.\n     */\n    blockName?: string;\n}\n\n/**\n * Class that finds a block of code that starts with the supplied regex and ends with a specified method.\n */\nexport class StoryBlockFinder {\n\n    private currentRow = -1;\n\n    private readonly lines: string[];\n    private readonly range: StoryBlockRange;\n    private readonly blockStartMatch: RegExp;\n    private readonly blockEndType: EndType;\n    private readonly blockName?: string;\n\n    constructor(props: StoryBlockFinderParameters) {\n        this.lines = props.lines;\n        this.blockEndType = props.blockEndType;\n        this.blockStartMatch = props.blockStartMatch;\n        this.blockName = props.blockName;\n\n        if (!props.range) {\n            const endColumn = this.lines.length === 0 ? 0 : this.lines[this.lines.length - 1].length;\n            this.range = new StoryBlockRange(0, 0, this.lines.length - 1, endColumn);\n        } else {\n            this.range = props.range;\n        }\n\n        if (this.range.start.row < 0 || this.range.end.row >= this.lines.length) {\n            throw new Error('range property outside of provided line array.')\n        }\n    }\n\n    public getNextBlock(): StoryBlock | undefined {\n        if (this.currentRow >= this.lines.length) {\n            return undefined;\n        }\n\n        if (this.currentRow < 0) {\n            this.currentRow = this.range!.start.row;\n        }\n\n        let result: StoryBlockRange | undefined = undefined;\n\n        let braces = { balance: 0, count: 0 };\n        let startRow = -1;\n        let blockName = '';\n        \n        while (!result && this.currentRow <= this.range!.end.row) {\n            const line = this.range.cropToRange(this.lines[this.currentRow], this.currentRow);\n\n            if (startRow < 0) {\n                const match = line.match(this.blockStartMatch);\n                if (this.positiveMatch(match)) {\n                    startRow = this.currentRow;\n\n                    if (match!.length > 1) {\n                        blockName = match![1].trim();\n                    }\n\n                    if (this.blockEndType === EndType.BraceMatch) {\n                        braces = { balance: 0, count: 0 };\n                        this.countBraces(line, braces);\n                    } else if (this.blockEndType === EndType.OneLine) {\n                        result = this.makeWholeLineRange(startRow, startRow);\n                    }\n                }\n            } else {\n                switch (this.blockEndType) {\n                    case EndType.BraceMatch: \n                        this.countBraces(line, braces);\n                        if (braces.count > 0 && braces.balance === 0) {\n                            result = this.makeWholeLineRange(startRow, this.currentRow);\n                        }\n                        break;\n                    case EndType.NextBlock:\n                        const match = line.match(this.blockStartMatch);\n                        if (match) {\n                            this.currentRow--;\n                            result = this.makeWholeLineRange(startRow, this.currentRow);\n                        }\n                        break;\n                }\n            }\n\n            this.currentRow++;\n        }\n\n        if (!result && startRow >= 0 && this.blockEndType === EndType.NextBlock) {\n            // End of range marks the end of current block when using NextBlock end type.\n            result = this.makeWholeLineRange(startRow, this.currentRow - 1);\n        }\n\n        if (result) {\n            return new StoryBlock(this.lines, blockName, result);\n        }\n        \n        return undefined;\n    }\n\n    private positiveMatch(match: RegExpMatchArray | null): boolean {\n        if (!match) { \n            return false;\n        }\n\n        if (match.length > 1 && !!this.blockName) {\n            return this.blockName === match[1].trim();\n        }\n\n        return true;\n    }\n\n    private countBraces(line: string, value: { balance: number, count: number }): void  {\n        \n        let prev = ' ';\n        for (let i = 0; i < line.length; i++) {\n            const ch = line[i];\n            if (ch === '/' && prev === '/') {\n                // break on comment\n                break;\n            }\n            else if (ch === '{') {\n                value.balance++;\n                value.count++;\n            } else if (ch === '}') {\n                value.balance--;\n                value.count++;\n            }\n\n            prev = line[i];\n        }\n    }\n\n    /**\n     * Returns a range that includes the whole block ending on column 0 of the next line.\n     * If the last row is the same as the last line, then the range ends on the last column\n     * of the last line.\n     * @param startRow First row of the block\n     * @param endRow Last row of the block\n     */\n    private makeWholeLineRange(startRow: number, endRow: number): StoryBlockRange {\n        let endColumn = 0;\n        if (endRow >= 0) {\n            if (endRow + 1 <= this.range.end.row) {\n                endRow++;\n            } else {\n                endRow = this.range.end.row;\n                endColumn = this.range.end.column;\n            }\n        }\n\n        return new StoryBlockRange(startRow, 0, endRow, endColumn);\n    }\n}"]}