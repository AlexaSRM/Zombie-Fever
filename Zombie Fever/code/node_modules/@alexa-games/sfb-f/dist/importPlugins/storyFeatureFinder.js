"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const storyBlockFinder_1 = require("./storyBlockFinder");
const storyBlock_1 = require("./storyBlock");
class StoryFeatureFinder {
    constructor(lines) {
        this.lines = lines;
    }
    /**
     * Finds the range of the given scene. Returns undefined if the scene is not present.
     * @param sceneId ID of the scene to find.
     */
    findScene(sceneId) {
        sceneId = sceneId.trim();
        const sceneFinder = new storyBlockFinder_1.StoryBlockFinder({
            blockEndType: storyBlockFinder_1.EndType.NextBlock,
            blockName: sceneId,
            lines: this.lines,
            blockStartMatch: storyBlockFinder_1.BlockStartExpressions.SceneMatch
        });
        const result = sceneFinder.getNextBlock();
        if (result) {
            return new storyBlock_1.SceneStoryBlock(result.lines, result.blockName, result.range);
        }
        return undefined;
    }
    /**
     * Returns Ranges containing references to the specified scene.
     * @param sceneId Scene ID to find references to.
     */
    getReferences(sceneId) {
        sceneId = sceneId.trim();
        const result = [];
        const sceneFinder = new storyBlockFinder_1.StoryBlockFinder({
            blockEndType: storyBlockFinder_1.EndType.NextBlock,
            lines: this.lines,
            blockStartMatch: storyBlockFinder_1.BlockStartExpressions.SceneMatch
        });
        let sceneBlock = sceneFinder.getNextBlock();
        while (sceneBlock) {
            const thenFinder = new storyBlockFinder_1.StoryBlockFinder({
                blockEndType: storyBlockFinder_1.EndType.NextBlock,
                blockName: 'then',
                lines: this.lines,
                range: sceneBlock.range,
                blockStartMatch: storyBlockFinder_1.BlockStartExpressions.ScenePropMatch
            });
            let thenBlock = thenFinder.getNextBlock();
            while (thenBlock) {
                const refFinder = new storyBlockFinder_1.StoryBlockFinder({
                    blockEndType: storyBlockFinder_1.EndType.OneLine,
                    range: thenBlock.range,
                    lines: this.lines,
                    blockStartMatch: StoryFeatureFinder.ReferenceNotationMatch,
                    blockName: sceneId
                });
                let reference = refFinder.getNextBlock();
                while (reference) {
                    result.push(reference.range);
                    reference = refFinder.getNextBlock();
                }
                if (result.length > 0) {
                    this.expandToSimpleHearBlocks(result, thenBlock.range);
                }
                thenBlock = thenFinder.getNextBlock();
            }
            sceneBlock = sceneFinder.getNextBlock();
        }
        return result;
    }
    /**
     * Return range of the given property type or undefined if it is not found.
     * @param sceneBlock Range to include in the quest for the scene property.
     * @param propertyType Values like 'say', 'then', etc.
     */
    getScenePropertyByType(sceneBlock, propertyType) {
        const blockFinder = new storyBlockFinder_1.StoryBlockFinder({
            blockEndType: storyBlockFinder_1.EndType.NextBlock,
            blockName: propertyType,
            lines: this.lines,
            range: sceneBlock,
            blockStartMatch: storyBlockFinder_1.BlockStartExpressions.ScenePropMatch
        });
        return blockFinder.getNextBlock();
    }
    /**
     * Find simple hear blocks (blocks with nothing else but a single reference) and replaces the reference to the
     * entire hear block.
     * @param result List of references to expand
     * @param thenBlock Range to scan
     */
    expandToSimpleHearBlocks(result, thenBlock) {
        const hearFinder = new storyBlockFinder_1.StoryBlockFinder({
            blockEndType: storyBlockFinder_1.EndType.BraceMatch,
            range: thenBlock,
            lines: this.lines,
            blockStartMatch: storyBlockFinder_1.BlockStartExpressions.HearMatch
        });
        let index = 0;
        let hearBlock = hearFinder.getNextBlock();
        while (index < result.length && hearBlock) {
            while (index < result.length &&
                result[index].end.row < hearBlock.range.start.row) {
                // Skip past results that precede the current hear block.
                index++;
            }
            if (index < result.length &&
                result[index].intersectsWith(hearBlock.range)) {
                // Is hear block simple? use it!
                if (this.isBlockSimple(hearBlock.range, result[index])) {
                    result[index] = hearBlock.range;
                }
                index++;
            }
            hearBlock = hearFinder.getNextBlock();
        }
    }
    // A simple block has only spaces or braces on lines that are outside of the ignore range.
    // The first line may have any characters.  For example:
    //     hear foo 
    //     {
    //         -> test (ignored)
    //
    //     }
    isBlockSimple(block, ignore) {
        for (let i = block.start.row + 1; i <= block.end.row; i++) {
            let line = block.cropToRange(this.lines[i], i);
            if (i === ignore.start.row && i < ignore.end.row) {
                continue;
            }
            if (!StoryFeatureFinder.BracesOrSpaces.test(line)) {
                return false;
            }
        }
        return true;
    }
}
exports.StoryFeatureFinder = StoryFeatureFinder;
// Looks for -> scene or <-> scene style references on a line
StoryFeatureFinder.ReferenceNotationMatch = /^\s*<?->\s+(.*)\s*$/;
// Looks for { } or spaces on a line. Other characters result in no-match
StoryFeatureFinder.BracesOrSpaces = /^[\s\{\}]*$/;
//# sourceMappingURL=storyFeatureFinder.js.map