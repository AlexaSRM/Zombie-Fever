"use strict";
/**
 * abc-importer
 *
 * Imports and exports between various branched content formats and the Alexa Branching Content (ABC) format.
 */
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const DefaultFormatImportPlugin_1 = require("../importPlugins/DefaultFormatImportPlugin");
const alexa_abc_verifier_1 = require("../verificationHandlers/alexa-abc-verifier");
const storyMetadata_1 = require("./../story/storyMetadata");
const VoiceModelBuilder_1 = require("../bakeUtilities/VoiceModelBuilder");
const BuiltInIntents_1 = require("../bakeUtilities/BuiltInIntents");
const ACEExtension_1 = require("../extensions/ACEExtension");
const storyMetadataHelper_1 = require("../importPlugins/storyMetadataHelper");
const sourceContentHelper_1 = require("../importPlugins/sourceContentHelper");
const sfb_util_1 = require("@alexa-games/sfb-util");
const fs = __importStar(require("fs"));
class ACEImporter {
    // Constructor
    constructor(customImporters, customerExporters, extensions) {
        this.importHandlersByType = {};
        this.exportHandlersByType = {};
        this.importExtensions = [];
        this.verifier = new alexa_abc_verifier_1.AlexaABCVerifier();
        let importPlugins = [
            new DefaultFormatImportPlugin_1.DefaultFormatImportPlugin()
        ];
        if (customImporters) {
            importPlugins = importPlugins.concat(customImporters);
        }
        for (let importPlug of importPlugins) {
            this.importHandlersByType[importPlug.pluginName] = importPlug;
        }
        if (customerExporters) {
            Object.assign(this.exportHandlersByType, customerExporters);
        }
        if (extensions) {
            this.importExtensions = extensions;
        }
    }
    async importABCStory(format, filename, storyTitle, storyID, autoIntentGrouping, param = {}) {
        let contents = [];
        if (param.content) {
            contents.push({
                id: "default",
                text: param.content
            });
        }
        else if (param.contents) {
            contents = param.contents;
        }
        else {
            contents.push({
                id: filename,
                text: sfb_util_1.readUtf8FileExcludingBomSync(filename)
            });
        }
        for (let extension of this.importExtensions) {
            if (ACEExtension_1.isImporterExtension(extension)) {
                const sourceHelper = new sourceContentHelper_1.SourceContentHelper(contents);
                await extension.extendSourceContent(sourceHelper);
                param.contents = sourceHelper.getAllSourceContents();
            }
        }
        let importHandler = this.importHandlersByType[format];
        const contentVersion = param.version || 1;
        const optimalVersion = importHandler.getVersion();
        if (optimalVersion < contentVersion) {
            throw new Error(`Unsupported Language Version: Importer expected content version ${optimalVersion}, but detected version ${contentVersion}.`);
        }
        let thisObj = this;
        const importResult = await importHandler.importData(contents, param);
        const importedScenes = importResult.importedScenes;
        const importErrors = importResult.errors || [];
        let jsonObjOutput = {
            pluginName: importHandler.pluginName,
            scenes: importedScenes,
            storyID: storyID,
            storyTitle: storyTitle
        };
        for (let extension of this.importExtensions) {
            try {
                if (ACEExtension_1.isImporterExtension(extension)) {
                    const metadataHelper = new storyMetadataHelper_1.StoryMetadataHelper(jsonObjOutput);
                    await extension.extendImportedContent(metadataHelper);
                    jsonObjOutput = await metadataHelper.getStoryMetadata();
                }
            }
            catch (err) {
                const extensionError = {
                    lineNumber: 0,
                    errorMessage: err,
                    errorName: `Import Extension Error on ${extension.constructor.name}`
                };
                importErrors.push(extensionError);
            }
        }
        if (!param.ignoreSyntaxError) {
            const finalError = await thisObj.verifier.verify(jsonObjOutput);
            finalError.forEach((errorItem) => {
                importErrors.push(errorItem);
            });
        }
        try {
            let modelBuilder;
            if (param.modelBuilder) {
                modelBuilder = param.modelBuilder;
            }
            else {
                modelBuilder = new VoiceModelBuilder_1.AlexaVoiceModelBuilder();
            }
            const locale = param.locale || "en-US";
            const language = locale.split("-")[0];
            const storyHelper = new storyMetadataHelper_1.StoryMetadataHelper(jsonObjOutput);
            const localizedBuiltIn = BuiltInIntents_1.BUILT_IN_INTENT_UTTERANCES[locale] || BuiltInIntents_1.BUILT_IN_INTENT_UTTERANCES[language];
            if (ACEImporter.fallBackEnabledLocales.includes(locale) || ACEImporter.fallBackEnabledLocales.includes(language)) {
                localizedBuiltIn["AMAZON.FallbackIntent"] = [];
            }
            const voiceModel = modelBuilder.build({
                customSlots: Object.assign(param.customSlots || {}),
                builtInIntents: localizedBuiltIn,
                invocationName: jsonObjOutput.storyTitle,
                story: storyHelper,
                locale: locale,
            });
            const finalStoryMetadata = await storyHelper.getStoryMetadata();
            if (autoIntentGrouping) {
                finalStoryMetadata.alexaVoiceModel = voiceModel;
            }
            else {
                let allUtterances = {};
                for (let scene of finalStoryMetadata.scenes) {
                    for (let content of scene.contents) {
                        if (content.sceneDirections) {
                            for (let direction of content.sceneDirections) {
                                if (direction.directionType == storyMetadata_1.InstructionType.CHOICE) {
                                    allUtterances[direction.parameters.utterances] = 1;
                                }
                            }
                        }
                    }
                }
                finalStoryMetadata.alexaVoiceModel = Object.keys(allUtterances);
            }
            jsonObjOutput = finalStoryMetadata;
        }
        catch (err) {
            if (err instanceof Error) {
                importErrors.push({
                    errorName: "VoiceModelBuildError",
                    lineNumber: 0,
                    errorMessage: err.message + "\n" + err.stack
                });
            }
            else {
                importErrors.push({
                    errorName: "VoiceModelBuildError",
                    lineNumber: 0,
                    errorMessage: err
                });
            }
        }
        if (importErrors && importErrors.length > 0) {
            throw {
                errorItems: importErrors,
                importedData: jsonObjOutput
            };
        }
        else {
            return jsonObjOutput;
        }
    }
    exportTo(format, filename, outputFilename) {
        let fileData = sfb_util_1.readUtf8FileExcludingBomSync(filename);
        let jsonInputObj = JSON.parse(fileData);
        let exportHandler = this.exportHandlersByType[format];
        console.log(this.exportHandlersByType);
        exportHandler.exportData(jsonInputObj, function (outputData) {
            console.log("Output Data:");
            console.log(outputData);
            fs.writeFileSync(outputFilename, outputData);
        });
    }
}
exports.ACEImporter = ACEImporter;
ACEImporter.fallBackEnabledLocales = [
    "en",
    "de-DE"
];
//# sourceMappingURL=importer.js.map