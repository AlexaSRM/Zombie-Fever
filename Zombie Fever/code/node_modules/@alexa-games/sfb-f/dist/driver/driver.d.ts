import { UserInput, SceneAudioItem, VisualOptions, ResultOption } from './driverEntity';
import { ABCImportPlugin } from './../importPlugins/importerPlugin';
import { StoryMetadata } from '../story/storyMetadata';
import { StoryAccessor } from '../story/storyAccessor';
import { InstructionExtension, ImporterExtension, DriverExtension } from '../extensions/ACEExtension';
import { PlayStage } from './PlayStage';
import { AudioFileAccessor, PollyUtil } from '@alexa-games/sfb-polly';
import { AudioItemUtil } from './AudioItemUtil';
declare type ACEExtensionType = ImporterExtension | DriverExtension | InstructionExtension;
export interface Narrator {
    name: string;
    pitch: string;
    rate: string;
    volume: string;
    engine?: string;
}
export interface DriverPollyConfig {
    enabled: boolean;
    enabledInPreview?: boolean;
    previewPollyVoice?: string;
    combineAudioTags: boolean;
    dontUseCache: boolean;
    s3DomainName: string;
    bucketName: string;
    FFMPEGLocation: string;
    workingDir: string;
    cognito?: {
        identityPoolId: string;
        loginWithAmazonAccessToken?: string;
    };
    [key: string]: any;
}
export declare class ACEDriver {
    static readonly SSML_AUDIO_LIMIT = 5;
    static debug: boolean;
    static testing: boolean;
    /**
     * flag this variable to alway run the average value for dice rolls.
     */
    static probabilityOff: boolean;
    private isPollyAsDefault;
    private importHandlersByType;
    private customExtensions;
    private resultOptions;
    storyState: {
        [key: string]: any;
    };
    storyAccessor: StoryAccessor;
    stage: PlayStage;
    audioItemUtil: AudioItemUtil;
    private playQueue;
    private unhandledChoiceFlag;
    private isPausing;
    private isRepeating;
    private locale;
    pollyConfig: DriverPollyConfig;
    private defaultNarrator;
    private pollyUtil;
    private audioAccessor;
    private callStack;
    historySize: number;
    constructor(storyMetadata: StoryMetadata, customImportPlugins?: ABCImportPlugin[], extensions?: ACEExtensionType[], pollyConfiguration?: DriverPollyConfig, locale?: string, audioAccessor?: AudioFileAccessor, pollyUtil?: PollyUtil);
    /**
     * invoke before calling resumeStory if the story history and progress needs to be reset by running the start sequence.
     * onStart implementation of all registered extensions are run.
     *
     * @param startingStoryState
     */
    resetStory(startingStoryState?: {
        [key: string]: any;
    }): Promise<void>;
    /**
     * Resume the story.
     * If story has been paused, run the resume cycle by playing the 'Resume' scene first.
     * Otherwise, Run normally from the bookmarked scene ID.
     *
     * @param userInput
     * @param startingStoryState
     */
    resumeStory(_userInput: UserInput, startingStoryState?: {
        [key: string]: any;
    }): Promise<void>;
    pauseStory(): void;
    /**
     * Run the pause sequence by playing the 'Pause' scene.
     *
     * @param startingStoryState
     */
    private executePauseSequence;
    /**
     * Configure the default polly narrator settings.
     */
    configureDefaultPollyNarrator(narrator: Narrator): void;
    /**
     * Turning on the 'default polly' causes all narration texts (including the ones not surrounded by the 'voice' tag) to be read in polly voice.
     * The polly voice setting for this can be configured by calling configureDefaultPollyNarrator().
     */
    turnOnDefaultPolly(): void;
    /**
     * Turning off the 'default polly' causes all narration texts (texts NOT surrounded by the 'voice' tag) to be processed as non-polly voice.
     */
    turnOffDefaultPolly(): void;
    getSpeechSSMLText(): Promise<string>;
    getSpeechSSMLTextPerScene(): Promise<any>;
    getVisitedSceneIDsOnRun(): string[];
    getSpeechSSMLAndPrettyText(): Promise<{
        ssml: string;
        pretty: string;
        errorMessage: string | undefined;
    }>;
    getRepromptSSMLText(): Promise<string>;
    getRepromptSSMLAndPrettyText(): Promise<{
        ssml: string;
        pretty: string;
        errorMessage: string | undefined;
    }>;
    getVisuals(): Promise<VisualOptions[] | undefined>;
    buildAudioScenes(sceneAudioItemList: SceneAudioItem[]): Promise<{
        ssml: string;
        pretty: string;
        errorMessage?: string;
    }>;
    /**
     * Get the current story state.
     */
    getCurrentStoryState(): {
        [key: string]: any;
    };
    getResultOptions(): ResultOption[];
    /**
     * See if the scene marked as ending, or scene leading to no new choice has been reached as a result of the current resume/run.
     */
    isEndingReached(): boolean;
    /**
     * See if a choice was unhandled and allow the caller to do something else if they need to.
     */
    isUnhandledChoice(): boolean;
    /**
     * Execute the selected choice indicated by the user input.
     */
    processChoice(userInput: UserInput): Promise<any>;
    /**
     * Process the current scene. Updating speech, reprompt, variables as indicated by the scene.
     */
    private processScene;
    /**
     * Peform given list of scene directions in order.
     *
     * @param directions Scene Directions to peform.
     * @return returns the resulting scene direction where all the variables are replaced by the actual values.
     */
    performInstructions(instructionAddress: string): Promise<boolean>;
    /**
     * Compute a dice roll given a standard dice string.
     *
     * @param diceString
     */
    private evaluateDiceRoll;
}
export {};
