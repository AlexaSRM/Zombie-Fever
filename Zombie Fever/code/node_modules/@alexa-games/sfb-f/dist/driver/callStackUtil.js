"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Story's call stack manager for generating addresses, and accessing instructions in the story based on the address.
 */
class CallStackUtil {
    constructor(story) {
        this.story = story;
        this.PUBLISHED_VERSION = 1;
    }
    getChoiceAddress(originAddress, lineNumber) {
        const address = this.deserialize(originAddress);
        address.sequence.push({
            line: lineNumber,
            source: address.sequence[address.sequence.length - 1].source,
            type: "choice"
        });
        return this.serialize(address);
    }
    getConditionAddress(originAddress, lineNumber) {
        const address = this.deserialize(originAddress);
        address.sequence.push({
            line: lineNumber,
            source: address.sequence[address.sequence.length - 1].source,
            type: "condition"
        });
        return this.serialize(address);
    }
    getSceneAddress(sceneID, lineNumber) {
        const address = {
            version: this.PUBLISHED_VERSION,
            sequence: [
                {
                    type: "scene",
                    source: sceneID,
                    line: lineNumber
                }
            ]
        };
        return this.serialize(address);
    }
    getReturnAddress(originAddress, lineNumber) {
        const address = this.deserialize(originAddress);
        address.sequence.push({
            line: lineNumber,
            source: address.sequence[address.sequence.length - 1].source,
            type: "jump"
        });
        return this.serialize(address);
    }
    getSourceScene(address) {
        if (this.isNewCallStack(address)) {
            const addressStructure = this.deserialize(address);
            return addressStructure.sequence[addressStructure.sequence.length - 1].source;
        }
        else {
            return address.split(":")[0];
        }
    }
    isNewCallStack(address) {
        try {
            const addressStructure = address.split("@");
            return addressStructure && parseInt(addressStructure[0]) <= this.PUBLISHED_VERSION;
        }
        catch (err) {
            return false;
        }
    }
    deserialize(addressString) {
        const result = {
            version: this.PUBLISHED_VERSION,
            sequence: []
        };
        if (this.isNewCallStack(addressString)) {
            const sequencePre = addressString.split("@");
            const version = parseInt(sequencePre[0]);
            result.version = version;
            for (let i = 1; i < sequencePre.length; i++) {
                const sequenceProps = sequencePre[i].split("::");
                result.sequence.push({
                    source: sequenceProps[0],
                    type: sequenceProps[1],
                    line: parseInt(sequenceProps[2]),
                    option: sequenceProps[3]
                });
            }
            result;
        }
        else {
            result.sequence = [
                {
                    source: addressString.split("::")[0],
                    line: -1,
                    type: "legacy",
                    option: addressString
                }
            ];
        }
        return result;
    }
    serialize(address) {
        let serializedString = String(address.version);
        for (let sequenceItem of address.sequence) {
            let sequenceItemSerialized = `@${sequenceItem.source}::${sequenceItem.type}::${sequenceItem.line}::`;
            if (sequenceItem.option) {
                sequenceItemSerialized += sequenceItem.option;
            }
            serializedString += sequenceItemSerialized;
        }
        return serializedString;
    }
    getInstructions(address, storyState) {
        const addressStructure = this.deserialize(address);
        let instructions = [];
        for (let addressItem of addressStructure.sequence) {
            switch (addressItem.type) {
                case "scene": {
                    const sceneInstructions = this.story.getSceneInstructions(addressItem.source);
                    instructions = this.getInstructionSection(addressItem.line, sceneInstructions);
                    break;
                }
                case "jump": {
                    instructions = this.getInstructionSection(addressItem.line + 1, instructions);
                    break;
                }
                case "condition": {
                    const section = this.getInstructionSection(addressItem.line, instructions);
                    const conditionalInstruction = section[0].parameters.directions;
                    instructions = (conditionalInstruction || []).concat(this.getInstructionSection(addressItem.line + 1, instructions));
                    break;
                }
                case "choice": {
                    const section = this.getInstructionSection(addressItem.line, instructions);
                    const choiceInstruction = section[0].parameters.directions;
                    instructions = choiceInstruction || [];
                    break;
                }
                case "legacy": {
                    if (addressItem.option && storyState.system_instruction_mem && storyState.system_instruction_mem[addressItem.option]) {
                        // For backward compatibility, needs to stay
                        instructions = storyState.system_instruction_mem[addressItem.option];
                    }
                }
            }
        }
        return instructions;
    }
    getInstructionSection(lineNumber, instructions) {
        if (lineNumber >= instructions.length) {
            return [];
        }
        else if (lineNumber > 0) {
            return instructions.slice(lineNumber);
        }
        else {
            return instructions;
        }
    }
    callStackExists(state) {
        return state.system_call_stack && state.system_call_stack.length > 0;
    }
    addressInStack(state, address) {
        return state.system_call_stack && state.system_call_stack.includes(address);
    }
}
exports.CallStackUtil = CallStackUtil;
//# sourceMappingURL=callStackUtil.js.map