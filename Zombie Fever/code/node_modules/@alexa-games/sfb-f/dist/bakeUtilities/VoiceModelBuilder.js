"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const storyMetadata_1 = require("./../story/storyMetadata");
const languageModel_1 = require("./languageModel");
const segmenter_1 = require("./../transformers/segmenter");
var CategoryType;
(function (CategoryType) {
    CategoryType[CategoryType["INTENT"] = 0] = "INTENT";
    CategoryType[CategoryType["CUSTOM_SLOT"] = 1] = "CUSTOM_SLOT";
    CategoryType[CategoryType["AUTO_SLOT"] = 2] = "AUTO_SLOT";
    CategoryType[CategoryType["BUILT_IN_INTENT"] = 3] = "BUILT_IN_INTENT";
})(CategoryType = exports.CategoryType || (exports.CategoryType = {}));
const SLOT_VERSION_BASE = 26;
const A_CHAR_CODE = 'a'.charCodeAt(0);
const SLOT_INTENT_NAME = 'CatchAllSlotIntent';
const INTENT_NUMBER_LIMIT = 220;
const OVERFLOW_INTENT_SLOT_NAME = "OverflowIntentSlot";
class AlexaVoiceModelBuilder {
    /**
     * Given a imported story structure for SFB, automatically generate an Alexa Interaction Model.
     */
    build(param) {
        const storyAccessor = param.story;
        ModelBuilderHelper.autoIntentCount = 0;
        ModelBuilderHelper.autoSlotCount = 0;
        const builtInIntents = ModelBuilderHelper.buildBuiltInSampleToIntentMap(param.builtInIntents);
        const categories = ModelBuilderHelper.categorizeByIntent(storyAccessor, builtInIntents);
        const voiceModel = ModelBuilderHelper.buildVoiceModelFromCategory(categories, param.invocationName, param.customSlots, param.builtInIntents);
        return voiceModel;
    }
}
exports.AlexaVoiceModelBuilder = AlexaVoiceModelBuilder;
class ModelBuilderHelper {
    static buildBuiltInSampleToIntentMap(intentToSamples) {
        const sampleToBuiltIn = {};
        for (let intentName in intentToSamples) {
            intentToSamples[intentName].forEach((sample) => {
                sampleToBuiltIn[sample.toLowerCase()] = intentName;
            });
        }
        return sampleToBuiltIn;
    }
    static isBuiltInIntent(intent) {
        return intent.startsWith("AMAZON.");
    }
    static isWildCardUtterance(utterance) {
        return utterance === "*";
    }
    /**
     * Given a SFB story metadata divide utterances based on the intent of the utterance.
     */
    static categorizeByIntent(story, builtInIntents) {
        let result = [];
        const utteranceToCategory = {};
        story.getAllScenes().forEach((scene) => {
            scene.contents.forEach((content) => {
                const categories = ModelBuilderHelper.getCategoriesFromScene(utteranceToCategory, builtInIntents, content);
                result = result.concat(categories);
            });
        });
        ModelBuilderHelper.registerCategoryToStory(story, utteranceToCategory);
        return result;
    }
    /**
     * Given the category list, construct a voice model object.
     */
    static buildVoiceModelFromCategory(categories, invocationName, customSlots, builtInIntents) {
        const modelBuilder = new languageModel_1.LanguageModelBuilder(invocationName);
        for (let item of categories) {
            if (item.utterances.length === 0) {
                continue;
            }
            if (item.type === CategoryType.INTENT) {
                modelBuilder.addIntent({
                    name: item.id,
                    samples: item.utterances
                });
            }
            else if (item.type === CategoryType.AUTO_SLOT) {
                const generatedSlotName = item.id;
                const generatedSlotTypeName = `${generatedSlotName}Type`;
                const utterances = ModelBuilderHelper.convertSlotUtteranceForModel(item.utterances);
                modelBuilder.addSlotValues(generatedSlotTypeName, utterances);
                modelBuilder.addSlotSamplesToIntent(SLOT_INTENT_NAME, [`{${generatedSlotName}}`], [{
                        name: generatedSlotName,
                        type: generatedSlotTypeName
                    }]);
            }
            else if (item.type === CategoryType.CUSTOM_SLOT) {
                const slots = ModelBuilderHelper.getSlotsFromUtterances(item.utterances);
                const utterances = ModelBuilderHelper.convertSlotUtteranceForModel(item.utterances);
                slots.forEach((slot) => {
                    const customSlotTypeName = slot.type;
                    const customSlotValues = customSlots[customSlotTypeName] || [];
                    if (!ModelBuilderHelper.isBuiltInIntent(customSlotTypeName)) {
                        modelBuilder.addSlotValues(customSlotTypeName, customSlotValues);
                    }
                });
                modelBuilder.addSlotSamplesToIntent(SLOT_INTENT_NAME, utterances, slots);
            }
        }
        for (let intentName of Object.keys(builtInIntents)) {
            modelBuilder.addIntent({
                name: intentName
            });
        }
        return modelBuilder.build();
    }
    static getCategoriesFromScene(utteranceToCategory, builtInIntents, sceneContent) {
        const instructions = sceneContent.sceneDirections;
        if (!instructions) {
            return [];
        }
        const registeredSlots = ModelBuilderHelper.buildSlotMap(instructions);
        const sceneCategory = [];
        let instructionsQueue = JSON.parse(JSON.stringify(instructions));
        const usedIntent = {};
        while (instructionsQueue.length > 0) {
            const checking = instructionsQueue.splice(0, 1)[0];
            if (checking.directionType === storyMetadata_1.InstructionType.CHOICE) {
                const utterances = checking.parameters.utterances;
                const choiceCategories = ModelBuilderHelper.buildCategoriesForChoice(utterances, usedIntent, registeredSlots, builtInIntents, utteranceToCategory);
                choiceCategories.forEach((item) => sceneCategory.push(item));
            }
            else if (checking.directionType === storyMetadata_1.InstructionType.CONDITION) {
                if (checking.parameters.directions && checking.parameters.directions.length > 0) {
                    instructionsQueue = instructionsQueue.concat(checking.parameters.directions);
                }
            }
        }
        return sceneCategory;
    }
    static buildCategoriesForChoice(utterances, usedIntent, slotNameToType, builtInIntentMap, utteranceToCategory) {
        const utteranceTypingResult = ModelBuilderHelper.splitUtteranceType(utterances, builtInIntentMap, slotNameToType);
        utteranceTypingResult.autoIntents.forEach((utterance) => {
            const categoryForUtterance = utteranceToCategory[utterance];
            if (categoryForUtterance) {
                const intentID = categoryForUtterance.id;
                if (usedIntent[intentID]) {
                    // remove utterance from the existing category for re-assignment
                    const i = utteranceToCategory[utterance].utterances.indexOf(utterance);
                    utteranceToCategory[utterance].utterances.splice(i, 1);
                    delete utteranceToCategory[utterance];
                }
            }
        });
        const choiceCategories = ModelBuilderHelper.buildCategoriesFromUtteranceTyping(utteranceTypingResult.builtInIntents, utteranceTypingResult.autoIntents, utteranceTypingResult.autoSlots, utteranceTypingResult.customSlots, builtInIntentMap, utteranceToCategory);
        choiceCategories.filter((category) => {
            return category.type === CategoryType.INTENT;
        }).forEach((category) => {
            usedIntent[category.id] = true;
        });
        return choiceCategories;
    }
    static buildCategoriesFromUtteranceTyping(builtIns, autoIntents, autoSlots, customSlots, builtInIntentMap, utteranceToCategory) {
        const categories = [];
        if (builtIns.length > 0) {
            builtIns.forEach((utterance) => {
                const intentName = builtInIntentMap[utterance];
                const category = {
                    id: intentName,
                    type: CategoryType.BUILT_IN_INTENT,
                    utterances: []
                };
                utteranceToCategory[utterance] = category;
                categories.push(category);
            });
        }
        if (autoSlots.length > 0) {
            categories.push({
                id: OVERFLOW_INTENT_SLOT_NAME,
                type: CategoryType.AUTO_SLOT,
                utterances: autoSlots
            });
            ModelBuilderHelper.autoSlotCount++;
        }
        if (customSlots.length > 0) {
            categories.push({
                id: 'custom',
                type: CategoryType.CUSTOM_SLOT,
                utterances: customSlots
            });
        }
        if (autoIntents.length > 0) {
            let categoryInUse = [];
            autoIntents.forEach((utterance) => {
                const recentCategory = categoryInUse.length > 0 ? categoryInUse[categoryInUse.length - 1] : undefined;
                if (utteranceToCategory[utterance] && (!recentCategory || utteranceToCategory[utterance].id !== recentCategory.id)) {
                    categoryInUse.push(utteranceToCategory[utterance]);
                }
                else if (!recentCategory) {
                    const intentName = `flex${ModelBuilderHelper.numberToAlphabetCounting(ModelBuilderHelper.autoIntentCount)}Intent`;
                    const generatedCategory = {
                        id: intentName,
                        type: CategoryType.INTENT,
                        utterances: [utterance]
                    };
                    if (ModelBuilderHelper.autoIntentCount > INTENT_NUMBER_LIMIT) {
                        generatedCategory.id = OVERFLOW_INTENT_SLOT_NAME;
                        generatedCategory.type = CategoryType.AUTO_SLOT;
                    }
                    categoryInUse.push(generatedCategory);
                    utteranceToCategory[utterance] = generatedCategory;
                    ModelBuilderHelper.autoIntentCount++;
                }
                else if (!utteranceToCategory[utterance]) {
                    utteranceToCategory[utterance] = recentCategory;
                    recentCategory.utterances.push(utterance);
                }
            });
            categoryInUse.forEach((cat) => categories.push(cat));
        }
        return categories;
    }
    /**
     * Split a list of utterances in by their utterance type.
     * Three utterances types are:
     * 1. Auto Intent
     * 2. Built In Intents
     * 3. Auto Slot
     * 4. Custom Slot
     */
    static splitUtteranceType(utterances, builtInIntents, registeredSlots) {
        const autoSlotUtterances = [];
        const customSlotUtterances = [];
        const intentUtterances = [];
        const builtInUtterances = [];
        for (let utterance of utterances) {
            const segmenter = new segmenter_1.Segmenter([{
                    brackets: "{}",
                    preserve: false,
                    type: segmenter_1.SegmentType.Element
                }]);
            const segments = segmenter.parse(utterance);
            const normalizedUtterance = segments.map((seg) => {
                return seg.type === segmenter_1.SegmentType.Element ? seg.original : seg.value.toLowerCase();
            }).reduce((prev, curr) => {
                if (prev) {
                    return prev + curr;
                }
                else {
                    return curr;
                }
            });
            if (ModelBuilderHelper.isWildCardUtterance(normalizedUtterance)) {
                continue;
            }
            else if (ModelBuilderHelper.isBuiltInIntent(normalizedUtterance)) {
                continue;
            }
            else if (builtInIntents[normalizedUtterance]) {
                builtInUtterances.push(normalizedUtterance);
            }
            else if (ModelBuilderHelper.hasUserDefinedSlots(normalizedUtterance)) {
                const slotStandardUtterance = ModelBuilderHelper.standarizeSlottedUtterance(normalizedUtterance, registeredSlots);
                customSlotUtterances.push(slotStandardUtterance);
            }
            else if (ModelBuilderHelper.hasNumerics(normalizedUtterance)) {
                autoSlotUtterances.push(normalizedUtterance);
            }
            else {
                intentUtterances.push(normalizedUtterance);
            }
        }
        return {
            autoIntents: intentUtterances,
            builtInIntents: builtInUtterances,
            autoSlots: autoSlotUtterances,
            customSlots: customSlotUtterances
        };
    }
    /**
     * Build a map of { slot name : slot type } registered within the given list of scene instructions.
     */
    static buildSlotMap(instructions) {
        const registeredSlots = {};
        let instructionsQueue = JSON.parse(JSON.stringify(instructions));
        while (instructionsQueue.length > 0) {
            const checking = instructionsQueue.splice(0, 1)[0];
            if (checking.directionType === storyMetadata_1.InstructionType.SLOT) {
                const name = checking.parameters.variableName;
                const type = checking.parameters.variableType;
                registeredSlots[name] = type;
            }
            else if (checking.directionType === storyMetadata_1.InstructionType.CONDITION) {
                if (checking.parameters.directions && checking.parameters.directions.length > 0) {
                    instructionsQueue = instructionsQueue.concat(checking.parameters.directions);
                }
            }
        }
        return registeredSlots;
    }
    static standarizeSlottedUtterance(utterance, slotMap) {
        return utterance.replace(/{([\s\S]+?)(?:[ \t]+?as[ \t]+?([\s\S]+?))?}/g, (match, slotName, slotType) => {
            if (slotName && !slotType && slotMap[slotName]) {
                return `{${slotName} as ${slotMap[slotName]}}`;
            }
            else if (slotName && !slotType && !slotMap[slotName]) {
                return `{${slotName} as ${slotName}}`;
            }
            else {
                return match;
            }
        });
    }
    static hasUserDefinedSlots(utterance) {
        return !!utterance.match(/{[\s\S]+?([ \t]+?as[ \t]+?[\s\S]+?)?}/g);
    }
    static hasNumerics(utterance) {
        return !!utterance.match(/[\d]+?/g);
    }
    static numberToAlphabetCounting(i) {
        const base26Count = i.toString(SLOT_VERSION_BASE);
        const alphaBaseCount = base26Count.replace(/./g, (match) => {
            if (isNaN(parseInt(match, 10))) {
                return String.fromCharCode(match.charCodeAt(0) + 10);
            }
            else {
                return String.fromCharCode(A_CHAR_CODE + parseInt(match, 10));
            }
        });
        return alphaBaseCount;
    }
    static getSlotsFromUtterances(utterances) {
        const slots = {};
        utterances.forEach((item) => {
            const segmenter = new segmenter_1.Segmenter([{
                    brackets: "{}",
                    preserve: false,
                    type: segmenter_1.SegmentType.Element
                }]);
            const segments = segmenter.parse(item);
            for (let segment of segments) {
                const value = segment.value;
                if (segment.type === segmenter_1.SegmentType.Element) {
                    const slotRegex = /^([\s\S]+?)[ \t]+?as[ \t]+?([\s\S]+?)$/;
                    const match = slotRegex.exec(value);
                    if (match === null) {
                        throw new Error(`Unexpected slot format '${value}' in Utterance '${item}'`);
                    }
                    const type = match[2];
                    const name = match[1];
                    slots[name] = {
                        name: name,
                        type: type
                    };
                }
            }
        });
        return Object.values(slots);
    }
    static convertSlotUtteranceForModel(utterances) {
        const flattenedUtterance = JSON.stringify(utterances);
        const slotRegex = /{([\s\S]+?)[ \t]+?as[ \t]+?([\s\S]+?)}/g;
        const correctedUtterances = flattenedUtterance.replace(slotRegex, (match, slotName, slotType) => {
            return `{${slotName}}`;
        });
        return JSON.parse(correctedUtterances);
    }
    static registerCategoryToStory(story, utteranceToCategory) {
        const scenes = story.getAllScenes();
        for (let scene of scenes) {
            for (let content of scene.contents) {
                if (!content.sceneDirections) {
                    continue;
                }
                ModelBuilderHelper.registerCategoryToInstructions(content.sceneDirections, utteranceToCategory);
            }
        }
        story.setAllScenes(scenes);
    }
    static registerCategoryToInstruction(instruction, utteranceToCategory) {
        if (instruction.parameters.utterances) {
            const uniqueIntentsUsed = {};
            for (let utterance of instruction.parameters.utterances) {
                const category = utteranceToCategory[utterance];
                if (category) {
                    uniqueIntentsUsed[category.id] = true;
                }
            }
            if (!instruction.parameters.utteranceIDs) {
                instruction.parameters.utteranceIDs = [];
            }
            instruction.parameters.utteranceIDs = instruction.parameters.utteranceIDs.concat(Object.keys(uniqueIntentsUsed));
        }
    }
    static registerCategoryToInstructions(instructions, utteranceToCategory) {
        for (let instruction of instructions) {
            if (instruction.directionType === storyMetadata_1.InstructionType.CHOICE) {
                ModelBuilderHelper.registerCategoryToInstruction(instruction, utteranceToCategory);
            }
            else if (instruction.directionType === storyMetadata_1.InstructionType.CONDITION) {
                if (instruction.parameters.directions && instruction.parameters.directions.length > 0) {
                    ModelBuilderHelper.registerCategoryToInstructions(instruction.parameters.directions, utteranceToCategory);
                }
            }
        }
    }
}
exports.ModelBuilderHelper = ModelBuilderHelper;
ModelBuilderHelper.autoSlotCount = 0;
ModelBuilderHelper.autoIntentCount = 0;
//# sourceMappingURL=VoiceModelBuilder.js.map