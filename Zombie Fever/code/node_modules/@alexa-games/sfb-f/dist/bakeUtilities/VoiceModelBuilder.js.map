{"version":3,"file":"VoiceModelBuilder.js","sourceRoot":"","sources":["../../bakeUtilities/VoiceModelBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { VoiceModel } from \"./languageModel\";\nimport { StoryMetadataHelper } from './../importPlugins/storyMetadataHelper';\nimport { Instruction, InstructionType, SceneVariation } from './../story/storyMetadata';\nimport { LanguageModelBuilder, LanguageModelSlot, LanguageModelValue } from './languageModel';\nimport { Segmenter, SegmentType } from './../transformers/segmenter';\n\nexport interface IntentCategory {\n    id: string,\n    type: CategoryType,\n    utterances: string[],\n}\n\nexport enum CategoryType {\n    INTENT,\n    CUSTOM_SLOT,\n    AUTO_SLOT,\n    BUILT_IN_INTENT\n}\n\nconst SLOT_VERSION_BASE = 26;\n\nconst A_CHAR_CODE = 'a'.charCodeAt(0);\n\nconst SLOT_INTENT_NAME = 'CatchAllSlotIntent';\n\nconst INTENT_NUMBER_LIMIT: number = 220;\n\nconst OVERFLOW_INTENT_SLOT_NAME: string = \"OverflowIntentSlot\"\n\nexport interface ModelBuildParameter {\n    story: StoryMetadataHelper;\n    locale: string;\n    invocationName: string;\n    customSlots: {[key: string]: string[]|LanguageModelValue[]};\n    builtInIntents: {[key: string]: string[]};\n}\n\nexport interface ModelBuilder {\n    build(param: ModelBuildParameter): VoiceModel;\n}\n\nexport class AlexaVoiceModelBuilder implements ModelBuilder {\n    /**\n     * Given a imported story structure for SFB, automatically generate an Alexa Interaction Model.\n     */\n    public build(param: ModelBuildParameter): VoiceModel {\n        const storyAccessor = param.story;\n        \n        ModelBuilderHelper.autoIntentCount = 0;\n        ModelBuilderHelper.autoSlotCount = 0;\n\n        const builtInIntents = ModelBuilderHelper.buildBuiltInSampleToIntentMap(param.builtInIntents);\n        const categories = ModelBuilderHelper.categorizeByIntent(storyAccessor, builtInIntents);\n        const voiceModel = ModelBuilderHelper.buildVoiceModelFromCategory(categories, param.invocationName, param.customSlots, param.builtInIntents);\n\n        return voiceModel;\n    }\n}\n\nexport class ModelBuilderHelper {\n    static autoSlotCount: number = 0;\n    static autoIntentCount: number = 0;\n\n    static buildBuiltInSampleToIntentMap(intentToSamples: {[key: string]: string[];}): {[key: string]: string} {\n        const sampleToBuiltIn: {[key: string]: string} = {};\n        for (let intentName in intentToSamples) {\n            intentToSamples[intentName].forEach((sample) => {\n                sampleToBuiltIn[sample.toLowerCase()] = intentName;\n            });\n        }\n\n        return sampleToBuiltIn;\n    }\n\n    static isBuiltInIntent(intent: string) {\n        return intent.startsWith(\"AMAZON.\");\n    }\n\n    static isWildCardUtterance(utterance: string) {\n        return utterance === \"*\";\n    }\n\n    /**\n     * Given a SFB story metadata divide utterances based on the intent of the utterance.\n     */\n    static categorizeByIntent(story: StoryMetadataHelper, builtInIntents: {[key: string]: string}): IntentCategory[] {\n        let result: IntentCategory[] = [];\n\n        const utteranceToCategory: {[key: string]: IntentCategory} = {};\n\n        story.getAllScenes().forEach((scene) => {\n\n            scene.contents.forEach((content) => {\n                const categories = ModelBuilderHelper.getCategoriesFromScene(utteranceToCategory, builtInIntents, content);\n\n                result = result.concat(categories);\n            });\n        });\n\n        ModelBuilderHelper.registerCategoryToStory(story, utteranceToCategory);\n\n        return result;\n    }\n\n    /**\n     * Given the category list, construct a voice model object.\n     */\n    static buildVoiceModelFromCategory(categories: IntentCategory[], invocationName: string, customSlots: {[key: string]: (string|LanguageModelValue)[]}, builtInIntents: {[key:string]: string[]}): VoiceModel {\n        const modelBuilder = new LanguageModelBuilder(invocationName);\n\n        for (let item of categories) {\n            if (item.utterances.length === 0) {\n                continue;\n            }\n\n            if (item.type === CategoryType.INTENT) {\n                modelBuilder.addIntent({\n                    name: item.id,\n                    samples: item.utterances\n                });\n            } else if (item.type === CategoryType.AUTO_SLOT) {\n                const generatedSlotName = item.id;\n                const generatedSlotTypeName = `${generatedSlotName}Type`;\n                const utterances = ModelBuilderHelper.convertSlotUtteranceForModel(item.utterances);\n\n                modelBuilder.addSlotValues(generatedSlotTypeName, utterances);\n                modelBuilder.addSlotSamplesToIntent(SLOT_INTENT_NAME, [`{${generatedSlotName}}`], [{\n                    name: generatedSlotName,\n                    type: generatedSlotTypeName\n                }]);\n            } else if (item.type === CategoryType.CUSTOM_SLOT) {\n                const slots = ModelBuilderHelper.getSlotsFromUtterances(item.utterances);\n                const utterances = ModelBuilderHelper.convertSlotUtteranceForModel(item.utterances);\n\n                slots.forEach((slot) => {\n                    const customSlotTypeName = slot.type;\n                    const customSlotValues = customSlots[customSlotTypeName] || [];\n\n\n                    if (!ModelBuilderHelper.isBuiltInIntent(customSlotTypeName)) {\n                        modelBuilder.addSlotValues(customSlotTypeName, customSlotValues);\n                    }\n                });\n                modelBuilder.addSlotSamplesToIntent(SLOT_INTENT_NAME, utterances, slots);\n            }\n        }\n\n        for (let intentName of Object.keys(builtInIntents)) {\n            modelBuilder.addIntent({\n                name: intentName\n            });\n        }\n\n        return modelBuilder.build();\n    }\n\n    static getCategoriesFromScene(utteranceToCategory: {[key:string]: IntentCategory}, builtInIntents: {[key: string]: string}, sceneContent: SceneVariation): IntentCategory[] {\n        const instructions = sceneContent.sceneDirections;\n\n        if (!instructions) {\n            return [];\n        }\n\n        const registeredSlots = ModelBuilderHelper.buildSlotMap(instructions);\n        const sceneCategory: IntentCategory[] = [];\n\n        let instructionsQueue = JSON.parse(JSON.stringify(instructions));\n\n        const usedIntent: {[key: string]: boolean} = {};\n\n        while (instructionsQueue.length > 0) {\n            const checking = instructionsQueue.splice(0, 1)[0];\n            \n            if (checking.directionType === InstructionType.CHOICE) {\n                const utterances = (<string[]>checking.parameters.utterances);\n\n                const choiceCategories = ModelBuilderHelper.buildCategoriesForChoice(utterances, usedIntent, registeredSlots, builtInIntents, utteranceToCategory);\n                \n                choiceCategories.forEach((item) => sceneCategory.push(item));\n            } else if (checking.directionType === InstructionType.CONDITION) {\n                if (checking.parameters.directions && checking.parameters.directions.length > 0) {\n                    instructionsQueue = instructionsQueue.concat(checking.parameters.directions);\n                }\n            }\n        }\n\n        return sceneCategory;\n    }\n\n    static buildCategoriesForChoice(utterances: string[], usedIntent: {[key: string]: boolean}, slotNameToType: {[key:string]: string}, builtInIntentMap: {[key: string]: string}, utteranceToCategory: {[key:string]: IntentCategory}): IntentCategory[] {\n        const utteranceTypingResult = ModelBuilderHelper.splitUtteranceType(utterances, builtInIntentMap, slotNameToType);\n\n        utteranceTypingResult.autoIntents.forEach((utterance) => {\n            const categoryForUtterance = utteranceToCategory[utterance];\n            if (categoryForUtterance) {\n                const intentID = categoryForUtterance.id;\n                if (usedIntent[intentID]) {\n                    // remove utterance from the existing category for re-assignment\n                    const i = utteranceToCategory[utterance].utterances.indexOf(utterance);\n                    utteranceToCategory[utterance].utterances.splice(i, 1);\n                    delete utteranceToCategory[utterance];\n                }\n            }            \n        });\n\n        const choiceCategories = ModelBuilderHelper.buildCategoriesFromUtteranceTyping (\n            utteranceTypingResult.builtInIntents,\n            utteranceTypingResult.autoIntents,\n            utteranceTypingResult.autoSlots,\n            utteranceTypingResult.customSlots,\n            builtInIntentMap,\n            utteranceToCategory\n        );\n\n        choiceCategories.filter((category) => {\n            return category.type === CategoryType.INTENT;\n        }).forEach((category) => {\n            usedIntent[category.id] = true\n        })\n\n        return choiceCategories\n    }\n\n    static buildCategoriesFromUtteranceTyping(builtIns: string[], autoIntents: string[], autoSlots: string[], customSlots: string[], builtInIntentMap: {[key: string]: string}, utteranceToCategory: {[key:string]: IntentCategory}): IntentCategory[] {\n        const categories: IntentCategory[] = [];\n\n        if (builtIns.length > 0) {\n            builtIns.forEach((utterance) => {\n                const intentName = builtInIntentMap[utterance];\n                const category = {\n                    id: intentName,\n                    type: CategoryType.BUILT_IN_INTENT,\n                    utterances: []\n                }\n\n                utteranceToCategory[utterance] = category;\n                categories.push(category);\n            });\n        }\n\n        if (autoSlots.length > 0) {\n            categories.push({\n                id: OVERFLOW_INTENT_SLOT_NAME,\n                type: CategoryType.AUTO_SLOT,\n                utterances: autoSlots\n            });\n\n            ModelBuilderHelper.autoSlotCount ++;\n        }\n\n        if (customSlots.length > 0) {\n            categories.push({\n                id: 'custom',\n                type: CategoryType.CUSTOM_SLOT,\n                utterances: customSlots\n            });\n        }\n\n        if (autoIntents.length > 0) {\n            let categoryInUse: IntentCategory[] = [];\n            autoIntents.forEach((utterance) => {\n                const recentCategory = categoryInUse.length > 0? categoryInUse[categoryInUse.length - 1]: undefined;\n\n                if (utteranceToCategory[utterance] && (!recentCategory || utteranceToCategory[utterance].id !== recentCategory.id)) {\n                    categoryInUse.push(utteranceToCategory[utterance]);\n                } else if (!recentCategory) {\n                    const intentName = `flex${ModelBuilderHelper.numberToAlphabetCounting(ModelBuilderHelper.autoIntentCount)}Intent`;\n\n                    const generatedCategory: IntentCategory = {\n                        id: intentName,\n                        type: CategoryType.INTENT,\n                        utterances: [utterance]\n                    };\n\n                    if (ModelBuilderHelper.autoIntentCount > INTENT_NUMBER_LIMIT) {\n                        generatedCategory.id = OVERFLOW_INTENT_SLOT_NAME;\n                        generatedCategory.type = CategoryType.AUTO_SLOT;\n                    }\n\n                    categoryInUse.push(generatedCategory);\n                    utteranceToCategory[utterance] = generatedCategory;\n                    ModelBuilderHelper.autoIntentCount ++;\n                } else if (!utteranceToCategory[utterance]) {\n                    utteranceToCategory[utterance] = recentCategory;\n                    recentCategory.utterances.push(utterance);    \n                }\n            });\n            categoryInUse.forEach((cat) => categories.push(cat));\n        }\n\n        return categories;\n    }\n\n    /**\n     * Split a list of utterances in by their utterance type.\n     * Three utterances types are:\n     * 1. Auto Intent\n     * 2. Built In Intents\n     * 3. Auto Slot\n     * 4. Custom Slot\n     */\n    static splitUtteranceType(utterances: string[], builtInIntents: {[key: string]: string}, registeredSlots:  {[key: string]: string}): {\n        autoIntents: string[],\n        builtInIntents: string[],\n        autoSlots: string[],\n        customSlots: string[]\n    } {\n        const autoSlotUtterances: string[] = [];\n        const customSlotUtterances: string[] = [];\n        const intentUtterances: string[] = [];\n        const builtInUtterances: string[] = [];\n\n        for (let utterance of utterances) {\n            const segmenter = new Segmenter([{\n                brackets: \"{}\",\n                preserve: false,\n                type: SegmentType.Element\n            }]);\n            \n            const segments = segmenter.parse(utterance);\n\n            const normalizedUtterance = segments.map((seg) => {\n                return seg.type === SegmentType.Element? seg.original: seg.value.toLowerCase();\n            }).reduce((prev, curr): string => {\n                if (prev) {\n                    return prev + curr;\n                } else {\n                    return curr;\n                }\n            });\n\n            if (ModelBuilderHelper.isWildCardUtterance(normalizedUtterance)) {\n                continue;\n            } else if (ModelBuilderHelper.isBuiltInIntent(normalizedUtterance)) {\n                continue;\n            } else if (builtInIntents[normalizedUtterance]) {\n                builtInUtterances.push(normalizedUtterance);\n            } else if (ModelBuilderHelper.hasUserDefinedSlots(normalizedUtterance)) {\n                const slotStandardUtterance = ModelBuilderHelper.standarizeSlottedUtterance(normalizedUtterance, registeredSlots);\n\n                customSlotUtterances.push(slotStandardUtterance);\n            } else if (ModelBuilderHelper.hasNumerics(normalizedUtterance)) {\n                autoSlotUtterances.push(normalizedUtterance);\n            } else {\n                intentUtterances.push(normalizedUtterance);\n            }\n        }\n\n        return {\n            autoIntents: intentUtterances,\n            builtInIntents: builtInUtterances,\n            autoSlots: autoSlotUtterances,\n            customSlots: customSlotUtterances\n        }\n    }\n\n    /**\n     * Build a map of { slot name : slot type } registered within the given list of scene instructions.\n     */\n    static buildSlotMap(instructions: Instruction[]): {[key: string]: string} {\n        const registeredSlots: {[key:string]: string} = {};\n\n        let instructionsQueue = JSON.parse(JSON.stringify(instructions));\n\n        while (instructionsQueue.length > 0) {\n            const checking = instructionsQueue.splice(0, 1)[0];\n            \n            if (checking.directionType === InstructionType.SLOT) {\n                const name: string = checking.parameters.variableName;\n                const type: string = checking.parameters.variableType;\n\n                registeredSlots[name] = type;\n            } else if (checking.directionType === InstructionType.CONDITION) {\n                if (checking.parameters.directions && checking.parameters.directions.length > 0) {\n                    instructionsQueue = instructionsQueue.concat(checking.parameters.directions);\n                }\n            }\n        }\n\n        return registeredSlots;\n    }\n\n    static standarizeSlottedUtterance(utterance: string, slotMap: {[key: string]: string;}): string {\n        return utterance.replace(/{([\\s\\S]+?)(?:[ \\t]+?as[ \\t]+?([\\s\\S]+?))?}/g,\n            (match: any, slotName: string, slotType: string) => {\n                if (slotName && !slotType && slotMap[slotName]) {\n                    return `{${slotName} as ${slotMap[slotName]}}`;\n                } else if (slotName && !slotType && !slotMap[slotName]) {\n                    return `{${slotName} as ${slotName}}`;\n                } else {\n                    return match;\n                }\n            });\n    }\n\n    static hasUserDefinedSlots(utterance: string) {\n        return !!utterance.match(/{[\\s\\S]+?([ \\t]+?as[ \\t]+?[\\s\\S]+?)?}/g);\n    }\n\n    static hasNumerics(utterance: string) {\n        return !!utterance.match(/[\\d]+?/g);\n    }\n\n    static numberToAlphabetCounting(i: number) {\n        const base26Count = i.toString(SLOT_VERSION_BASE);\n    \n        const alphaBaseCount = base26Count.replace(/./g, (match): string => {\n            if (isNaN(parseInt(match, 10))) {\n                return String.fromCharCode(match.charCodeAt(0) + 10);\n            } else {\n                return String.fromCharCode(A_CHAR_CODE + parseInt(match, 10));\n            }\n        });\n    \n        return alphaBaseCount;\n    }\n\n    static getSlotsFromUtterances(utterances: string[]): LanguageModelSlot[] {\n        const slots: {[key:string]: LanguageModelSlot}= {};\n        utterances.forEach((item) => {\n            const segmenter = new Segmenter([{\n                brackets: \"{}\",\n                preserve: false,\n                type: SegmentType.Element\n            }]);\n            \n            const segments = segmenter.parse(item);\n\n            for (let segment of segments) {\n                const value = segment.value;\n\n                if (segment.type === SegmentType.Element) {\n                    const slotRegex = /^([\\s\\S]+?)[ \\t]+?as[ \\t]+?([\\s\\S]+?)$/; \n                    const match = slotRegex.exec(value);\n\n                    if (match === null) {\n                        throw new Error(`Unexpected slot format '${value}' in Utterance '${item}'`);\n                    }\n\n                    const type = match[2];\n                    const name = match[1];\n\n                    slots[name] = {\n                        name: name,\n                        type: type\n                    }\n                }\n            }\n        });\n\n        return Object.values(slots);\n    }\n\n    static convertSlotUtteranceForModel(utterances: string[]): string[] {\n        const flattenedUtterance = JSON.stringify(utterances);\n\n        const slotRegex = /{([\\s\\S]+?)[ \\t]+?as[ \\t]+?([\\s\\S]+?)}/g; \n\n        const correctedUtterances = flattenedUtterance.replace(slotRegex, (match, slotName, slotType): string => {\n            return `{${slotName}}`;\n        });\n\n        return <string[]>JSON.parse(correctedUtterances);\n    }\n\n    static registerCategoryToStory(story: StoryMetadataHelper, utteranceToCategory: {[key:string]: IntentCategory;}) {\n        const scenes = story.getAllScenes();\n        for (let scene of scenes) {\n            for (let content of scene.contents) {\n                if (!content.sceneDirections) {\n                    continue;\n                }\n    \n                ModelBuilderHelper.registerCategoryToInstructions(content.sceneDirections, utteranceToCategory);\n            }\n        }\n        story.setAllScenes(scenes);\n    }\n\n    static registerCategoryToInstruction(instruction: Instruction, utteranceToCategory: {[key:string]: IntentCategory;}) {\n        if (instruction.parameters.utterances) {\n            const uniqueIntentsUsed: any = {};\n\n            for (let utterance of <string[]>instruction.parameters.utterances) {\n                const category = utteranceToCategory[utterance];\n\n                if (category) {\n                    uniqueIntentsUsed[category.id] = true;\n                }             \n            }\n\n            if (!instruction.parameters.utteranceIDs) {\n                instruction.parameters.utteranceIDs = [];\n            }\n            \n            instruction.parameters.utteranceIDs = instruction.parameters.utteranceIDs.concat(Object.keys(uniqueIntentsUsed));\n        }\n    }\n\n    static registerCategoryToInstructions(instructions: Instruction[], utteranceToCategory: {[key:string]: IntentCategory;}) {\n        for (let instruction of instructions) {\n            if (instruction.directionType === InstructionType.CHOICE) {\n                ModelBuilderHelper.registerCategoryToInstruction(instruction, utteranceToCategory);\n            } else if (instruction.directionType === InstructionType.CONDITION) {\n                if (instruction.parameters.directions && instruction.parameters.directions.length > 0) {\n                    ModelBuilderHelper.registerCategoryToInstructions(instruction.parameters.directions, utteranceToCategory);\n                }\n            }\n        }\n    }\n}"]}