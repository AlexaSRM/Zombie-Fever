"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
//import assert = require('assert');
const assert_1 = require("assert");
const __1 = require("..");
const driver_1 = require("../driver/driver");
const sfb_polly_1 = require("@alexa-games/sfb-polly");
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const testOutputDir = path.resolve(".", ".out");
class HappyAudioAccessor {
    async exists(audioName) {
        return true;
    }
    async downloadAudio(audioName, workingDirectoryPath) {
        //do nothing
    }
    async getAudioURL(audioName) {
        return `fake.url/${audioName}`;
    }
    async uploadAudio(audioName, workingDirectoryPath) {
        return await this.getAudioURL(audioName);
    }
}
class HappyPollyUtil extends sfb_polly_1.PollyUtil {
    async synthesize(request, workingDir, filename, outputFormat) {
        return;
    }
    async estimateSSMLDuration(ssml, workingDir) {
        return 1000;
    }
}
class ACEContentTester {
    constructor(storyData, extensions, ffmpegPath) {
        this.ffmpegPath = ffmpegPath;
        this.story = storyData;
        this.state = {};
        this.extensions = extensions;
        this.driver = this.getTestDriverInstance();
    }
    getTestDriverInstance() {
        if (!fs.existsSync(testOutputDir)) {
            fs.mkdirSync(testOutputDir);
        }
        return new driver_1.ACEDriver(this.story, [], this.extensions, {
            "enabled": false,
            "combineAudioTags": true,
            "dontUseCache": true,
            "FFMPEGLocation": this.ffmpegPath,
            "workingDir": testOutputDir,
            "bucketName": "test-bucket",
            "s3DomainName": "s3.amazon.com",
            "cognito": {
                identityPoolId: "us-east-1:11cce95b-36e9-4d5e-8e95-db76d27d1ab0",
                loginWithAmazonAccessToken: ""
            }
        }, undefined, new HappyAudioAccessor(), new HappyPollyUtil(new HappyAudioAccessor()));
    }
    /**
     * Resets the state of the test, and prepare for a new test run.
     */
    resetTest() {
        this.state = {};
        this.driver = this.getTestDriverInstance();
    }
    /**
     * Cleans out the current run state.
     */
    givenCleanState() {
        this.state = {};
    }
    givenAttribute(attributeName, value) {
        this.state[attributeName] = value;
    }
    givenAttributes(attributes) {
        this.state = Object.assign(this.state, attributes);
    }
    /**
     * Sets the test, so that the current scene is as defined by sceneID
     * @param sceneID scene ID the test should move to.
     */
    givenCurrentScene(sceneID) {
        __1.StoryStateHelper.setCurrentSceneID(this.state, sceneID);
    }
    /**
     * Run the story for given user input.
     * @param userInput instance of UserInput class of SFB module
     */
    async givenUserInput(userInput) {
        this.driver = this.getTestDriverInstance();
        await this.driver.resumeStory(userInput, this.state);
        this.state = this.driver.getCurrentStoryState();
    }
    /**
     * Invoke system level pause by signaling for pause event.
     */
    async givenPauseInvoked() {
        this.driver = this.getTestDriverInstance();
        await this.driver.resumeStory({
            intent: "AMAZON.PauseIntent"
        }, this.state);
        this.state = this.driver.getCurrentStoryState();
    }
    /**
     * Invoke system level resume by signlaing for resume event.
     */
    async givenResumeInvoked() {
        this.driver = this.getTestDriverInstance();
        await this.driver.resumeStory({
            intent: "LaunchRequest",
            value: "LaunchRequest"
        }, this.state);
        this.state = this.driver.getCurrentStoryState();
    }
    /**
     * Invoke system level start by signaling for start/launch event.
     */
    async givenStartInvoked() {
        this.driver = this.getTestDriverInstance();
        await this.givenResumeInvoked();
    }
    assertAttributeDefined(attributeName) {
        assert_1.strict.equal(this.state[attributeName] == undefined, false, `Attribute Assertion Failed`);
    }
    assertAttributeUndefined(attributeName) {
        assert_1.strict.equal(this.state[attributeName] == undefined, true, `Attribute Assertion Failed`);
    }
    assertAttributeEquals(attributeName, expected) {
        assert_1.strict.equal(this.state[attributeName], expected, `Attribute Assertion Failed`);
    }
    assertAttributeNotEquals(attributeName, expected) {
        assert_1.strict.notEqual(this.state[attributeName], expected, `Attribute Assertion Failed`);
    }
    assertSceneID(sceneID, msg = "") {
        let actualScene = __1.StoryStateHelper.getCurrentSceneID(this.state);
        assert_1.strict.equal(actualScene == null ? null : actualScene.trim().toLocaleLowerCase(), sceneID.trim().toLowerCase(), `Scene ID Assertion Failed: ${msg}`);
    }
    async assertSpeech(expected) {
        let actual = await this.driver.getSpeechSSMLText();
        assert_1.strict.equal(actual.trim(), expected.trim(), `Speech Assertion Failed`);
    }
    async assertPrettySpeech(expected) {
        let ssmlAndPretty = await this.driver.getSpeechSSMLAndPrettyText();
        let actual = ssmlAndPretty.pretty;
        assert_1.strict.equal(actual.trim(), expected.trim(), `Pretty Speech Assertion Failed`);
    }
    async assertPrettySpeechSSML(expected) {
        let ssmlAndPretty = await this.driver.getSpeechSSMLAndPrettyText();
        let actual = ssmlAndPretty.ssml;
        assert_1.strict.equal(actual.trim(), expected.trim(), `Pretty Speech SSML Assertion Failed`);
    }
    async assertSpeechSSMLPerScene(expected) {
        let scenesAndSsmlList = await this.driver.getSpeechSSMLTextPerScene();
        // TODO: Make this actually do something
    }
    async assertSpeechOneOf(expected) {
        let actual = await this.driver.getSpeechSSMLText();
        assert_1.strict(expected.includes(actual.trim()), `Speech Assertion Failed.`);
    }
    async assertReprompt(expected) {
        let actual = await this.driver.getRepromptSSMLText();
        assert_1.strict.equal(actual.trim(), expected.trim(), `Reprompt Assertion Failed`);
    }
    async getSpeech() {
        return await this.driver.getSpeechSSMLText();
    }
    async getReprompt() {
        return await this.driver.getRepromptSSMLText();
    }
    async getAttributeValue(attributeName) {
        return this.state[attributeName];
    }
    async assertAttributeExists(attributeName) {
        let actual = this.state[attributeName];
        assert_1.strict(actual != undefined, attributeName + ' undefined');
    }
    async assertTime(timeAttribute, before, after) {
        let time = +this.state[timeAttribute];
        assert_1.strict(time >= before && time <= after, 'Invalid time');
    }
}
exports.ACEContentTester = ACEContentTester;
//# sourceMappingURL=ACEContentTester.js.map