{"version":3,"file":"tokenReplacer.spec.js","sourceRoot":"","sources":["../../../../test/unitTests/parsers/tokenReplacer.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { TokenReplacer } from '../../../transformers/tokenReplacer';\nimport { strict as assert } from 'assert';\nimport { SegmenterBuilder } from '../../../transformers/segmenter';\nimport { substituteSlotValues } from '../../../transformers/legacy';\n\n// Segmenter is stateless and so can be used globally.\n\nconst data = {\n    one: 1,\n    two: 2,\n    threestr: 'its 3rd',\n    complex: {\n        four: 4,\n        five: 5,\n        level2: {\n            six: 6\n        },\n        loop: '{complex.loop}'\n    },\n    level1: {\n        level2: {\n            level3: {\n                data: 'Test value goes here',\n                data1: 'More test data.'\n            }\n        }\n    },\n    loop: '{loop}',\n    location1: 'Ballard',\n    location2: 'Seattle',\n    index: 2,\n    pick1: 2,\n    pick2: 1\n};\n\ndescribe(\"TokenReplacer\", function () {\n\n    // *say this will cause a infinite {loop}\n    // *say you are at {location{index}}\n\n    const tokenReplacer = new TokenReplacer(SegmenterBuilder.getVariableSegmenter(), data);\n\n    it(\"simple example\", function () {\n        \n        const input = \"Should get {one} here.\";\n        const output = tokenReplacer.replaceTokens(input, true);\n        const orig = substituteSlotValues(input, data, true);\n\n        assert.equal(output, 'Should get 1 here.');\n        assert.equal(output, orig.value, 'New method outputs same as original');\n    });\n\n    it(\"multiple variable example, is condition false\", function () {\n        \n        const input = \"This {threestr} sentence has {one} and {two} values to replace.\";\n        const output = tokenReplacer.replaceTokens(input, false);\n        const orig = substituteSlotValues(input, data, false);\n        \n        assert.equal(output, 'This its 3rd sentence has 1 and 2 values to replace.');\n        assert.equal(output, orig.value, 'New method outputs same as original');\n    });\n\n    it(\"multiple variable complex type\", function () {\n        \n        const input = \"Delving {complex.four} gives {complex.level2.six}\";\n        const output = tokenReplacer.replaceTokens(input, false);\n        const orig = substituteSlotValues(input, data, false);\n        \n        assert.equal(output, 'Delving 4 gives 6');\n        assert.equal(output, orig.value, 'New method outputs same as original');\n    });\n\n    it(\"variable path part one is quoted, second is wrongly quoted\", function () {\n        \n        const input = \"Delving {'complex'.four} gives {complex.'level2'.six}\";\n        const output = tokenReplacer.replaceTokens(input, false);\n        const orig = substituteSlotValues(input, data, false);\n        \n        assert.equal(output, 'Delving 4 gives 6');\n        assert.equal(output, orig.value, 'New method outputs same as original');\n    });\n\n    it(\"missing second part of a complex property.\", function () {\n        \n        const input = \"{complex.notHere}\";\n        const output = tokenReplacer.replaceTokens(input, false);\n        const orig = substituteSlotValues(input, data, false);\n        \n        assert.equal(output, 'undefined');\n        assert.equal(output, orig.value, 'New method outputs same as original');\n    });\n\n    it(\"missing first part of a complex property.\", function () {\n        \n        const input = \"{notHere.complex}\";\n        const output = tokenReplacer.replaceTokens(input, false);\n        const orig = substituteSlotValues(input, data, false);\n        \n        assert.equal(output, 'false');\n        assert.equal(output, orig.value, 'New method outputs same as original');\n    });\n\n    it(\"missing simple property.\", function () {\n        \n        const input = \"{notHere}\";\n        const output = tokenReplacer.replaceTokens(input, false);\n        const orig = substituteSlotValues(input, data, false);\n        \n        assert.equal(output, 'false');\n        assert.equal(output, orig.value, 'New method outputs same as original');\n    });\n\n    it(\"incomplete path for complex property.\", function () {\n        \n        const input = \"Incomplete: {complex.level2} Complete: {complex.level2.six}\";\n        const output = tokenReplacer.replaceTokens(input, false);\n        const orig = substituteSlotValues(input, data, false);\n        \n        assert.equal(output, 'Incomplete: [object Object] Complete: 6');\n        assert.equal(output, orig.value, 'New method outputs same as original');\n    });\n\n    it(\"two pass value {location{index}}.\", function () {\n        \n        const input = \"You are at {location{index}}.\";\n        const output = tokenReplacer.replaceTokens(input, false);\n        const orig = substituteSlotValues(input, data, false);\n\n        assert.equal(output, 'You are at Seattle.');\n        assert.equal(output, orig.value, 'New method outputs same as original');\n    });\n\n    it(\"three pass value {location{pick{index}}.\", function () {\n        \n        const input = \"You are at {location{pick{index}}}.\";\n        const output = tokenReplacer.replaceTokens(input, false);\n        const orig = substituteSlotValues(input, data, false);\n\n        assert.equal(output, 'You are at Ballard.');\n        assert.equal(output, orig.value, 'New method outputs same as original');\n    });\n\n    it(\"Infinite loop test.\", function () {\n        // console.log('Starting loop test');\n        \n        const input = \"Will this ever stop {loop}ing.\";\n        const output = tokenReplacer.replaceTokens(input, false);\n\n        // The answer is 'no' for the substituteSlotValues function\n        //const orig = substituteSlotValues(input, data, false);\n\n        //console.log(`output=${output} orig=${orig.value}`);\n        \n        assert.equal(output, 'Will this ever stop {loop}ing.');\n        //assert.equal(output, orig.value, 'New method outputs same as original');\n    });\n\n});"]}