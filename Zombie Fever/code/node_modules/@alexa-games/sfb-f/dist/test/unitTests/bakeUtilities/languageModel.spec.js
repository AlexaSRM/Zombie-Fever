"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const languageModel_1 = require("./../../../bakeUtilities/languageModel");
const assert_1 = require("assert");
const TEST_INVOCATION = "test";
describe("Voice Model Builder Test", function () {
    it("Add Intent.", async function () {
        const builder = new languageModel_1.LanguageModelBuilder(TEST_INVOCATION);
        const addingIntent = {
            name: "TestIntent",
            samples: ["utterance1", "utterance2"]
        };
        builder.addIntent(addingIntent);
        const result = builder.build();
        assert_1.strict.equal(result.languageModel.intents.length, 1, "Number of intents in the model does not match the expected number.");
        assert_1.strict.equal(result.languageModel.intents[0].name, addingIntent.name, "Content of the intent added does not match the expected value.");
        assert_1.strict.ok(addingIntent.samples);
        if (addingIntent.samples && result.languageModel.intents[0].samples) {
            assert_1.strict.equal(result.languageModel.intents[0].samples.length, addingIntent.samples.length, "Content of the intent added does not match the expected value.");
        }
    });
    it("Add Overlapping Intent.", async function () {
        const builder = new languageModel_1.LanguageModelBuilder(TEST_INVOCATION);
        const testIntent = {
            name: "TestIntent",
            samples: ["utterance1", "utterance2"]
        };
        const overlappingIntent = {
            name: "TestIntent",
            samples: ["utterance2", "utterance3"]
        };
        const otherIntent = {
            name: "TestIntent2",
            samples: ["utterance1", "utterance2"]
        };
        builder.addIntent(testIntent);
        builder.addIntent(otherIntent);
        builder.addIntent(overlappingIntent);
        const result = builder.build();
        assert_1.strict.equal(result.languageModel.intents.length, 2, "Number of intents in the model does not match the expected number.");
        let target = undefined;
        for (let intent of result.languageModel.intents) {
            if (intent.name === overlappingIntent.name) {
                target = intent;
                break;
            }
        }
        if (target && target.samples) {
            assert_1.strict.equal(target.samples.length, 2);
        }
        else {
            assert_1.strict.fail("Expected Intent was not found in the result.");
        }
    });
    it("Add Slot Type.", async function () {
        const testSlotType = "TestSlot";
        const testSlotValues = ["value1", "value2"];
        const builder = new languageModel_1.LanguageModelBuilder(TEST_INVOCATION);
        builder.addSlotValues(testSlotType, testSlotValues);
        const result = builder.build();
        assert_1.strict.ok(result.languageModel.types);
        if (result.languageModel.types) {
            assert_1.strict.equal(result.languageModel.types[0].name, testSlotType);
            assert_1.strict.equal(result.languageModel.types[0].values.length, testSlotValues.length);
        }
        else {
            assert_1.strict.fail("Expected slot types does not exist in the model.");
        }
    });
    it("Add Slot Values To Existing Slot Type.", async function () {
        const testSlotType = "TestSlot";
        const testSlotValues = ["value1", "value2"];
        const builder = new languageModel_1.LanguageModelBuilder(TEST_INVOCATION);
        builder.addSlotType({
            name: testSlotType,
            values: []
        });
        builder.addSlotValues(testSlotType, testSlotValues);
        const result = builder.build();
        assert_1.strict.ok(result.languageModel.types);
        if (result.languageModel.types) {
            assert_1.strict.equal(result.languageModel.types[0].name, testSlotType);
            assert_1.strict.equal(result.languageModel.types[0].values.length, testSlotValues.length);
        }
        else {
            assert_1.strict.fail("Expected slot types does not exist in the model.");
        }
    });
    it("Replace Existing Slot Type.", async function () {
        const testSlotType = "TestSlot";
        const testSlotValues = [
            {
                name: {
                    value: "value1"
                }
            },
            {
                name: {
                    value: "value2"
                }
            }
        ];
        const builder = new languageModel_1.LanguageModelBuilder(TEST_INVOCATION);
        builder.addSlotType({
            name: testSlotType,
            values: []
        });
        builder.addSlotType({
            name: testSlotType,
            values: testSlotValues
        });
        const result = builder.build();
        assert_1.strict.ok(result.languageModel.types);
        if (result.languageModel.types) {
            assert_1.strict.equal(result.languageModel.types[0].name, testSlotType);
            assert_1.strict.equal(result.languageModel.types[0].values.length, testSlotValues.length);
        }
        else {
            assert_1.strict.fail("Expected slot types does not exist in the model.");
        }
    });
    it("Add Slot Sample to Intent As First Entry.", async function () {
        const testIntentName = "TestIntent";
        const utterances = ["value {one}", "value {two}"];
        const slots = [
            {
                name: "one",
                type: "SlotType1"
            },
            {
                name: "two",
                type: "SlotType2"
            }
        ];
        const builder = new languageModel_1.LanguageModelBuilder(TEST_INVOCATION);
        builder.addSlotSamplesToIntent(testIntentName, utterances, slots);
        const result = builder.build();
        assert_1.strict.equal(result.languageModel.intents.length, 1);
        assert_1.strict.equal(result.languageModel.intents[0].name, testIntentName);
        if (result.languageModel.intents[0].slots) {
            assert_1.strict.equal(result.languageModel.intents[0].slots.length, slots.length);
        }
        else {
            assert_1.strict.fail();
        }
        if (result.languageModel.intents[0].samples) {
            assert_1.strict.equal(result.languageModel.intents[0].samples.length, utterances.length);
        }
        else {
            assert_1.strict.fail();
        }
    });
    it("Add Slot Sample to Emmpty Intent.", async function () {
        const testIntentName = "TestIntent";
        const utterances = ["value {one}", "value {two}"];
        const slots = [
            {
                name: "one",
                type: "SlotType1"
            },
            {
                name: "two",
                type: "SlotType2"
            }
        ];
        const builder = new languageModel_1.LanguageModelBuilder(TEST_INVOCATION);
        builder.addIntent({
            name: testIntentName
        });
        builder.addSlotSamplesToIntent(testIntentName, utterances, slots);
        const result = builder.build();
        assert_1.strict.equal(result.languageModel.intents.length, 1);
        assert_1.strict.equal(result.languageModel.intents[0].name, testIntentName);
        if (result.languageModel.intents[0].slots) {
            assert_1.strict.equal(result.languageModel.intents[0].slots.length, slots.length);
        }
        else {
            assert_1.strict.fail();
        }
        if (result.languageModel.intents[0].samples) {
            assert_1.strict.equal(result.languageModel.intents[0].samples.length, utterances.length);
        }
        else {
            assert_1.strict.fail();
        }
    });
    it("isSlotValue() Test.", async function () {
        assert_1.strict.ok(!languageModel_1.LanguageModelBuilder.isSlotValue("some string"), "identified 'string' as LanguageModelValue.");
        assert_1.strict.ok(!languageModel_1.LanguageModelBuilder.isSlotValue({}), "identified empty 'object' as LanguageModelValue.");
        assert_1.strict.ok(!languageModel_1.LanguageModelBuilder.isSlotValue([]), "identified empty array as LanguageModelValue.");
        assert_1.strict.ok(!languageModel_1.LanguageModelBuilder.isSlotValue({
            id: {},
            name: {
                value: "value"
            }
        }), "property 'id' can't be an object.");
        assert_1.strict.ok(!languageModel_1.LanguageModelBuilder.isSlotValue({
            id: "string name",
            name: {}
        }), "property 'name' cannot have empty object.");
        assert_1.strict.ok(!languageModel_1.LanguageModelBuilder.isSlotValue({
            id: "string name",
            name: "test"
        }), "property 'name' cannot be string.");
        assert_1.strict.ok(languageModel_1.LanguageModelBuilder.isSlotValue({
            name: {
                value: "value",
                synonyms: ["something"]
            }
        }), "property 'id' is optional");
        assert_1.strict.ok(languageModel_1.LanguageModelBuilder.isSlotValue({
            id: "string name",
            name: {
                value: "value"
            }
        }), "property 'synonyms' of 'name' is optional");
        assert_1.strict.ok(languageModel_1.LanguageModelBuilder.isSlotValue({
            id: "string name",
            name: {
                value: "value",
                synonyms: []
            }
        }), "property 'synonyms' can be an empty array.");
        assert_1.strict.ok(!languageModel_1.LanguageModelBuilder.isSlotValue({
            id: "string name",
            name: {
                value: "value",
                synonyms: "something"
            }
        }), "property 'synonyms' cannot be string.");
        assert_1.strict.ok(!languageModel_1.LanguageModelBuilder.isSlotValue({
            id: "string name",
            name: {
                value: "value",
                synonyms: [{}]
            }
        }), "property 'synonyms' cannot have type 'object' as an item.");
        assert_1.strict.ok(languageModel_1.LanguageModelBuilder.isSlotValue({
            id: "string name",
            name: {
                value: "value",
                synonyms: ["item", "item2"]
            }
        }), "property 'synonyms' should have type 'string' as an item.");
    });
});
//# sourceMappingURL=languageModel.spec.js.map